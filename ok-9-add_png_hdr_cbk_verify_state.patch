commit d2154450b1742f3e46c4cdf06a9e9a0663046df7
Author: Dmitry Grinberg <dmitrygr@gmail.com>
Date:   Fri Dec 23 18:14:20 2022 -0600

    add callback after PNG header parsing to verify density and dimensions, properly alloc state

diff --git a/Src/PkmnMain.c b/Src/PkmnMain.c
index bf5f61e..eb69002 100644
--- a/Src/PkmnMain.c
+++ b/Src/PkmnMain.c
@@ -54,7 +54,7 @@ void DrawPkmnSprite(UInt16 selectedPkmnId)
 		return;
 	}
 	
-	pngDrawAt(&ds, MemHandleLock(pngMemHandle), MemHandleSize(pngMemHandle), 1, 16, 64, 64); 
+	pngDrawAt(&ds, MemHandleLock(pngMemHandle), MemHandleSize(pngMemHandle), 1, 16, 64, 64, 0); 
 
 	DmReleaseResource(pngMemHandle);
 	if (dbRef)
diff --git a/Src/armcalls.c b/Src/armcalls.c
index b641722..8db8cbb 100644
--- a/Src/armcalls.c
+++ b/Src/armcalls.c
@@ -14,6 +14,11 @@ void armCallsInit(void *set_emulStateP, void *set_call68KFuncP)
 	call68KFuncP = set_call68KFuncP;
 }
 
+unsigned long armCallDo(unsigned long m68kFunc, const void *stackParams, unsigned long paramLen)
+{
+	return call68KFuncP(emulStateP, m68kFunc, stackParams, paramLen);
+}
+
 void* MemPtrNew(uint32_t size)
 {
 	uint32_t stackParam = __builtin_bswap32(size);
diff --git a/Src/armcalls.h b/Src/armcalls.h
index de004bd..7d82386 100644
--- a/Src/armcalls.h
+++ b/Src/armcalls.h
@@ -5,5 +5,6 @@
 
 void armCallsInit(void *emulStateP, void *call68KFuncP);
 
+unsigned long armCallDo(unsigned long m68kFunc, const void *stackParams, unsigned long paramLen);
 
 #endif
diff --git a/Src/pngDraw-68k.c b/Src/pngDraw-68k.c
index 51afbe0..f564776 100644
--- a/Src/pngDraw-68k.c
+++ b/Src/pngDraw-68k.c
@@ -24,13 +24,14 @@ void __attribute__((visibility("hidden"),always_inline)) on_draw(pngle_t *pngle,
 	*dst = color;
 }
 
-int pngDrawDecode(struct DrawState *ds, const void *data, uint32_t dataSz)
+int pngDrawDecode(struct DrawState *ds, const void *data, uint32_t dataSz, PngHdrDecodedCbkF hdrCbk)
 {
 	pngle_t *pngle;
 	int ret;
 
 	pngle = pngle_new();
 	pngle_set_draw_callback(pngle, ds);
+	pngle_set_init_callback(pngle, hdrCbk);
 	ret = pngle_feed(pngle, data, dataSz);
 	pngle_destroy(pngle);
 	
diff --git a/Src/pngDraw.c b/Src/pngDraw.c
index c2493fa..a3a1c16 100644
--- a/Src/pngDraw.c
+++ b/Src/pngDraw.c
@@ -4,11 +4,65 @@
 #include "pngDraw.h"
 
 
-static struct DrawState* setupDrawState(uint32_t w, uint32_t h) {
+void pngDrawStateFree(struct DrawState *ds)
+{
+	BmpDelete(ds->b);
+	MemPtrFree(ds);
+}
+
+void pngDrawRedraw(struct DrawState *ds, int16_t x, int16_t y)
+{
+	WinDrawBitmap(ds->b, x, y);
+}
+
+
+static unsigned char pngDrawHdrCbk(struct DrawState *ds, uint32_t w, uint32_t h)
+{
+	UInt16 rowBytes;
+	BitmapPtr b;
+	UInt32 val;
 	Err err;
-	BitmapPtr b = BmpCreate(w, h, 16, NULL, &err);
 
-	// Check if BmpCreate succeeded
+	//check for exact integer or 1/2 multiple of size, same for W & H
+	if (w * 2 % ds->expectedW || h * 2 % ds->expectedW || w * 2 / ds->expectedW != h * 2 / ds->expectedW)
+		return false;
+	
+	//see WHICH multiple it is, along the way, verify we support & expect that density
+	switch (w * 2 / ds->expectedW) {
+		case 2:	//expected size
+			ds->density = kDensityLow;
+			break;
+		
+		case 3:	//1.5 the size
+			ds->density = kDensityOneAndAHalf;
+			if (!(ds->densitySupportFlags & PNG_VARIOUS_DENSITIES_SUPPORTED))
+				return false;
+			break;
+		
+		case 4:	//2x the size
+			ds->density = kDensityDouble;
+			if (!(ds->densitySupportFlags & (PNG_VARIOUS_DENSITIES_SUPPORTED | PNG_DOUBLE_DENSITY_SUPPORTED)))
+				return false;
+			break;
+		
+		case 6:	//3x the density
+			ds->density = kDensityTriple;
+			if (!(ds->densitySupportFlags & PNG_VARIOUS_DENSITIES_SUPPORTED))
+				return false;
+			break;
+		
+		case 8:	//4x the density
+			ds->density = kDensityQuadruple;
+			if (!(ds->densitySupportFlags & PNG_VARIOUS_DENSITIES_SUPPORTED))
+				return false;
+			break;
+		
+		default:
+			return false;
+	}
+
+	
+	b = BmpCreate(w, h, 16, NULL, &err);
 	if (b == NULL) {
 		if (err == sysErrParamErr)
 		{
@@ -19,51 +73,22 @@ static struct DrawState* setupDrawState(uint32_t w, uint32_t h) {
 			ErrFatalDisplay("Not enough memory!");
 		}
 		ErrFatalDisplay("Error creating bitmap!");
-		return NULL;
-	}
-
-	struct DrawState *ds = (struct DrawState *)MemPtrNew(sizeof(struct DrawState));
-
-	// Check if MemPtrNew succeeded
-	if (!ds) {
-		BmpDelete(b);
-		ErrFatalDisplay("Error allocating memory for draw state!");
-		return NULL;
+		
+		return false;
 	}
-
-	MemSet(ds, sizeof(struct DrawState), 0);
-	UInt16 rowBytes;
-
-	BmpGetDimensions(b, NULL, NULL, &rowBytes);
-	ds->rowHalfwords = rowBytes / sizeof(UInt16);
-	ds->b = b;
 	ds->bits = BmpGetBits(b);
-
 	if (ds->bits == NULL) {
 		BmpDelete(b);
 		ErrFatalDisplay("Error getting bitmap bits!");
-		return NULL;
+		
+		return false;
 	}
-
-	return ds;
-}
-
-static void finish(struct DrawState *ds, uint32_t x, uint32_t y)
-{
-	WinDrawBitmap(ds->b, x, y);
-	BmpDelete(ds->b);
-	MemPtrFree(ds);
-}
-
-void pngDrawStateFree(struct DrawState *ds)
-{
-	BmpDelete(ds->b);
-	MemPtrFree(ds);
-}
-
-void pngDrawRedraw(struct DrawState *ds, int16_t x, int16_t y)
-{
-	WinDrawBitmap(ds->b, x, y);
+	
+	BmpGetDimensions(b, NULL, NULL, &rowBytes);
+	ds->rowHalfwords = rowBytes / sizeof(UInt16);
+	ds->b = b;
+	
+	return true;
 }
 
 int pngDrawDecodeCall(struct DrawState *ds, const void *data, uint32_t dataSz)
@@ -79,28 +104,33 @@ int pngDrawDecodeCall(struct DrawState *ds, const void *data, uint32_t dataSz)
 			.ds = ds,
 			.data = data,
 			.dataSz = dataSz,
+			.hdrDecodedF = pngDrawHdrCbk,
 		};
-		
+				
 		ret = PceNativeCall((NativeFuncType*)MemHandleLock(armH = DmGetResource('armc', 1)), &p);
 		MemHandleUnlock(armH);
 		DmReleaseResource(armH);
 	}
 	else {
 		
-		ret = pngDrawDecode(ds, data, dataSz);
+		ret = pngDrawDecode(ds, data, dataSz, pngDrawHdrCbk);
 	}
 	
 	return ret;
 }
 
-void pngDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_t x, int16_t y, uint32_t w, uint32_t h)
+void pngDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_t x, int16_t y, uint32_t expectedW, uint32_t expectedH, uint8_t densitySupportFlags)
 {
 	struct DrawState *ds;
 	int ret;
 	
-	// Start the PNG decoding and drawing to memory
-	ds = setupDrawState(64, 64);
-	ErrFatalDisplayIf(!ds, "Failed to setup DrawState!");
+	ds = (struct DrawState *)MemPtrNew(sizeof(struct DrawState));
+	if (!ds)
+		return;
+	MemSet(ds, sizeof(*ds), 0);
+	ds->expectedW = expectedW;
+	ds->expectedH = expectedH;
+	ds->densitySupportFlags = densitySupportFlags;
 
 	ret = pngDrawDecodeCall(ds, data, dataSz);
 	ErrFatalDisplayIf(ret < 0, "Error feeding PNG data!");
diff --git a/Src/pngDraw.h b/Src/pngDraw.h
index f70f9e8..5b75d66 100644
--- a/Src/pngDraw.h
+++ b/Src/pngDraw.h
@@ -7,8 +7,11 @@
 struct BitmapType;
 struct DrawState;
 
+#define PNG_DOUBLE_DENSITY_SUPPORTED		1		//sonyHR only supports double
+#define PNG_VARIOUS_DENSITIES_SUPPORTED		2		//palmHR supports various
+
 //decodes and stores state in "dsP"
-void pngDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_t x, int16_t y, uint32_t w, uint32_t h); 
+void pngDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_t x, int16_t y, uint32_t expectedW, uint32_t expectedH, uint8_t densitysupportFlags); 
 
 //delete am already-decoded state
 void pngDrawStateFree(struct DrawState *ds);
diff --git a/Src/pngDrawArm.c b/Src/pngDrawArm.c
index 2080bf1..eedf6a1 100644
--- a/Src/pngDrawArm.c
+++ b/Src/pngDrawArm.c
@@ -3,6 +3,11 @@
 #include "armcalls.h"
 
 
+struct DrawStateWrapper {
+	struct DrawState ds;	//must be first
+	uint32_t m68kCallback;
+};
+
 void on_draw(pngle_t *pngle, uint_fast16_t x, uint_fast16_t y, uint_fast16_t vR, uint_fast16_t vG, uint_fast16_t vB, uint_fast16_t vA, struct DrawState *ds)
 {
 	uint_fast16_t r = vR & 0xf8;
@@ -15,7 +20,7 @@ void on_draw(pngle_t *pngle, uint_fast16_t x, uint_fast16_t y, uint_fast16_t vR,
 	*dst = __builtin_bswap16(color);
 }
 
-static uint32_t read32(const void *fromP)
+static uint32_t read32(const void *fromP)			//read unaligned 32 bit in BE
 {
 	const uint8_t *from = fromP;
 	uint32_t ret = 0;
@@ -28,31 +33,92 @@ static uint32_t read32(const void *fromP)
 	return ret;
 }
 
+static uint16_t read16(const void *fromP)			//read unaligned 16 bit in BE
+{
+	const uint8_t *from = fromP;
+	uint16_t ret = 0;
+	
+	ret = (ret << 8) + from[0];
+	ret = (ret << 8) + from[1];
+	
+	return ret;
+}
+
+static void write32(void *dstP, uint32_t val)		//write unaligned 32 bit in LE
+{
+	uint8_t *dst = dstP;
+	
+	dst[0] = val;
+	dst[1] = val >> 8;
+	dst[2] = val >> 16;
+	dst[3] = val >> 24;
+}
+
+static void write16(void *dstP, uint16_t val)		//write unaligned 16 bit in LE
+{
+	uint8_t *dst = dstP;
+	
+	dst[0] = val;
+	dst[1] = val >> 8;
+}
+
+static void prvSwapDs(struct DrawState *dst, const struct DrawState *src)
+{
+	write32(&dst->b, read32(&src->b));
+	write32(&dst->bits, read32(&src->bits));
+	write32(&dst->expectedW, read32(&src->expectedW));
+	write32(&dst->expectedH, read32(&src->expectedH));
+	write16(&dst->rowHalfwords, read16(&src->rowHalfwords));
+	write16(&dst->density, read16(&src->density));
+	dst->densitySupportFlags = src->densitySupportFlags;
+}
+
+static unsigned char pngDrawHdrCbk(struct DrawState *ds, uint32_t w, uint32_t h)
+{
+	struct DrawStateWrapper *dsw = (struct DrawStateWrapper*)ds;
+	struct DrawState ds68k;
+	unsigned char ret;
+	struct {
+		struct DrawState *ds;
+		uint32_t w;
+		uint32_t h;
+	} params = {
+		.ds = (void*)__builtin_bswap32((uintptr_t)&ds68k),
+		.w = __builtin_bswap32(w),
+		.h = __builtin_bswap32(h),
+	};
+	
+	prvSwapDs(&ds68k, ds);
+	ret = armCallDo(dsw->m68kCallback, &params, sizeof(params));
+	prvSwapDs(ds, &ds68k);
+	
+	return ret;
+}
+
 int __attribute__((used)) ArmletMain(void *emulStateP, struct ArmParams *pp, void *call68KFuncP)
 {
+	struct DrawStateWrapper dsw;
 	struct DrawState *ds68k;
-	struct DrawState dsArm;
 	pngle_t *pngle;
 	int ret;
 
 	armCallsInit(emulStateP, call68KFuncP);
 
-
 	ds68k = (struct DrawState*)read32(&pp->ds);
-	dsArm.b = (struct BitmapType*)read32(&ds68k->b);
-	dsArm.bits = (uint16_t*)read32(&ds68k->bits);
-	dsArm.rowHalfwords = __builtin_bswap16(ds68k->rowHalfwords);
-
+	prvSwapDs(&dsw.ds, ds68k);
+	dsw.m68kCallback = read32(&pp->hdrDecodedF);
+	
 	pngle = pngle_new();
 	if (!pngle)
 		return -1;
 
-	pngle_set_draw_callback(pngle, &dsArm);
-
+	pngle_set_draw_callback(pngle, &dsw.ds);
+	pngle_set_init_callback(pngle, pngDrawHdrCbk);
 
 	ret = pngle_feed(pngle, (const void*)read32(&pp->data), read32(&pp->dataSz));
 	
 	pngle_destroy(pngle);
+	prvSwapDs(ds68k, &dsw.ds);
 
 	return ret;
 }
diff --git a/Src/pngDrawInt.h b/Src/pngDrawInt.h
index 6e103ec..11bb57b 100644
--- a/Src/pngDrawInt.h
+++ b/Src/pngDrawInt.h
@@ -1,23 +1,36 @@
 #ifndef _PNG_DRAW_INT_H_
 #define _PNG_DRAW_INT_H_
 
+#include <stdbool.h>
 #include <stdint.h>		//avoid PalmOS includes in ARM code
 
 struct BitmapType;
 
 struct DrawState {
-    struct BitmapType *b;
-    uint16_t *bits;
-    uint16_t rowHalfwords;
+	struct BitmapType *b;
+	uint16_t *bits;
+	
+	uint32_t expectedW;
+	uint32_t expectedH;
+	
+	uint16_t rowHalfwords;
+	uint16_t density;
+	
+	uint8_t densitySupportFlags;
 };
 
+//callback on size
+typedef unsigned char (*PngHdrDecodedCbkF)(struct DrawState *ds, uint32_t width, uint32_t height);
+
 //68k entry
-int pngDrawDecode(struct DrawState *ds, const void *data, uint32_t dataSz);
+int pngDrawDecode(struct DrawState *ds, const void *data, uint32_t dataSz, PngHdrDecodedCbkF hdrCbk);
 
 struct ArmParams {
 	struct DrawState *ds;
 	const void *data;
 	uint32_t dataSz;
+	
+	PngHdrDecodedCbkF hdrDecodedF;
 };
 
 #endif
diff --git a/Src/pngle.c b/Src/pngle.c
index a7b87a4..454b927 100644
--- a/Src/pngle.c
+++ b/Src/pngle.c
@@ -312,7 +312,7 @@ static inline uint16_t get_value(pngle_t *pngle, size_t *ridx, int *bitcount, in
 
 static int pngle_draw_pixels(pngle_t *pngle, size_t scanline_ringbuf_xidx)
 {
-	uint16_t v[4]; // MAX_CHANNELS
+	uint16_t v[4] = {}; // MAX_CHANNELS
 	int bitcount = 0;
 	uint8_t pixel_depth = (pngle->hdr.color_type & 1) ? 8 : pngle->hdr.depth;
 	uint16_t maxval = (1UL << pixel_depth) - 1;
@@ -582,7 +582,8 @@ static int pngle_handle_chunk(pngle_t *pngle, const uint8_t *buf, size_t len)
 		if (set_interlace_pass(pngle, pngle->hdr.interlace ? 1 : 0) < 0) return -1;
 
 		// callback
-		if (pngle->init_callback) pngle->init_callback(pngle, pngle->hdr.width, pngle->hdr.height);
+		if (pngle->init_callback && !pngle->init_callback(pngle->draw_state, pngle->hdr.width, pngle->hdr.height))
+			return PNGLE_ERROR("Image decode rejected by user");
 
 		break;
 
diff --git a/Src/pngle.h b/Src/pngle.h
index b7a3548..b81ce68 100644
--- a/Src/pngle.h
+++ b/Src/pngle.h
@@ -40,8 +40,7 @@ struct DrawState;
 typedef struct _pngle_t pngle_t;
 
 // Callback signatures
-typedef void (*pngle_init_callback_t)(pngle_t *pngle, uint32_t w, uint32_t h);
-typedef void (*pngle_draw_callback_t)(pngle_t *pngle, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint8_t rgba[4], struct DrawState *ds);
+typedef unsigned char (*pngle_init_callback_t)(struct DrawState *ds, uint32_t w, uint32_t h);		//return 0 to bail out
 typedef void (*pngle_done_callback_t)(pngle_t *pngle);
 
 // ----------------
