commit 2c2fed316cad8b33d536b84f43d86a761c08de20
Author: Dmitry Grinberg <dmitrygr@gmail.com>
Date:   Tue Jan 3 15:40:31 2023 -0600

    even more image compression improvements
    
    now allows disjoint framing, tests both with and without frame at
    compression time.

diff --git a/Src/aciDecode.c b/Src/aciDecode.c
index 943c6cd..981256b 100644
--- a/Src/aciDecode.c
+++ b/Src/aciDecode.c
@@ -6,7 +6,8 @@
 
 #define FLAGS_V1			0x01		//must be set for this v1 format, if clear, format differs
 #define FLAGS_HAS_CLUT		0x02		//if no, assume greyscale of given depth and no actual CLUT
-#define FLAGS_BOUNDED		0x04
+#define FLAGS_BOUNDED		0x04
+#define FLAGS_RFU			0xf8		//if any of these are set, we do not know how to decode this, do not try
 
 #define LOG(...)
 
@@ -39,10 +40,14 @@ int aciDecode(struct DrawState *ds, const void *data, uint32_t dataSz, ImgHdrDec
 	if (dataSz < sizeof(struct ACIhdr))
 		return -1;
 	
-	//verify we understadn the version
+	//verify we understang the version
 	if (!(hdr->flags & FLAGS_V1))
 		return -1;
 	
+	//verify we do not see any features we do not understand
+	if (hdr->flags & FLAGS_RFU)
+		return -1;
+	
 	numColors = 2 + hdr->numColorsM2;
 	
 	//at least one byte of data is mandatory, thus LE and not LT
diff --git a/tools/aci/README.txt b/tools/aci/README.txt
index 465807c..15a9950 100644
--- a/tools/aci/README.txt
+++ b/tools/aci/README.txt
@@ -1,12 +1,12 @@
 ACI (Adequately Compressed Image) Format is an image compression format designed for low-colour-number sprites with a few major colours.
 The format optionally supports a colour table (for colour images). Greyscale images do not provide a colour table and thus save space.
-The file format is maximally smiple and optimized for adequate decoding speed on the m68k platform. The first four bytes in the file are width and height, in big-endian 16-bit format. Then comes a single flags/version byte. wWat follows depends on it. Currently only version 1 of the format is defined, which is designated by the bit #0 of the flags/version byte being set. If so, the other bits in the byte are as follows: bit #1 - set if there is a colour table. Other bits reserved and must be clear. Next comes a byte (called numColoursM2) specifying how many colours the bitmap has. It is offset by one, thus a value of 7 means that this image has 8 colours. That is, the image is composed of (numColoursM2 + 1) colours. If there is a colour table, it comes next, three bytes for each: R, G, and B. There are (numColoursM2 + 1) entries. The colours are sorted by the encoder from most common to least. This allows the decoder to give preference to more common colours when displaying the image, if the number of colours that can be displayed is limited. If there is not a colour table, the image is greyscale, and the proper grey scale (from full white to full black) will be created by the decoder to create the required number of colours. Next, come (numColoursM2 + 1) bytes that are "ranges" - they describe relative frequency of each colour (in colour table order) in the source image. There is an implied, but not written extra value, which would make these all add up to 256. The extra symbol is called "RLE marker" and means "same as last pixel". Then comes the data, arithmetically-coded based on the provided range widths.
+The file format is maximally smiple and optimized for adequate decoding speed on the m68k platform. The first four bytes in the file are width and height, in big-endian 16-bit format. Then comes a single flags/version byte. What follows depends on it. Currently only version 1 of the format is defined, which is designated by the bit #0 of the flags/version byte being set. If so, the other bits in the byte are as follows: Bit #1 - set if there is a colour table. Bit #2 - set if the image is framed (full rows and columns on some sides of a fixed color). Other bits reserved and must be clear. Next comes a byte (called numColoursM2) specifying how many colours the bitmap has. It is offset by one, thus a value of 7 means that this image has 8 colours. That is, the image is composed of (numColoursM2 + 1) colours. If the image is framed, now come 5 bytes to specify frame size in rows ans columnts. top, bottom, left, right, color index. The compresed image data is encoded as if those rows/colums do not exist - the decoder must fill them with that given color all by itself. If there is a colour table, it comes next, three bytes for each: R, G, and B. There are (numColoursM2 + 1) entries. The colours are sorted by the encoder from most common to least. This allows the decoder to give preference to more common colours when displaying the image, if the number of colours that can be displayed is limited. If there is not a colour table, the image is greyscale, and the proper grey scale (from full white to full black) will be created by the decoder to create the required number of colours. Next, come (numColoursM2 + 1) bytes that are "ranges" - they describe relative frequency of each colour (in colour table order) in the source image. There is an implied, but not written extra value, which would make these all add up to 256. The extra symbol is called "RLE marker" and means "same as last pixel". Then comes the data, arithmetically-coded based on the provided range widths.
 
-The provided encoder/decoder is NOT meant for pseed, but as a reference. It can be used to decompress an image into a 24-bit BMP easily, like so:
+The provided encoder/decoder is NOT meant for speed, but as a reference. It can be used to decompress an image into a 24-bit BMP easily, like so:
 	./aci d < img.aci > img.bmp
 It can be used to compress an image like so:
 	./aci c < img.bmp > img.aci
 The bitmap must be a 24-bits-per-pixel uncompressed bitmap, preferably with a low number of colours. This will produce an ACI image with a colourtable.
-If you wish to produce a greyscale colour-table-less image, instead of "c", pass "c4", "c2", or "c1" parameters, for 4bpp, 2bpp, or 1bpp colour (16, 4, 2 colours). The format is not limited to this, but this tool, for ease, is. All incoming images will be converted to greyscale if not already so.
+If you wish to produce a greyscale colour-table-less image, instead of "c", pass "c4", "c2", or "c1" parameters, for 4bpp, 2bpp, or 1bpp colour (16, 4, 2 colours). The format is not limited to this, but this tool, for ease, is. All incoming images will be converted to greyscale if not already so. The encoder will try both framed and not-framed mode to see which produces a smaller size.
 
 The decoder in 68k assembly is optimised for speed in the common cases and is pretty fast. It provides the colour table in a callback at the start of the decoding process (even for greyscale images) and always outputs one byte per pixel.
\ No newline at end of file
diff --git a/tools/aci/aci.c b/tools/aci/aci.c
index 991de22..af42dec 100644
--- a/tools/aci/aci.c
+++ b/tools/aci/aci.c
@@ -8,6 +8,7 @@
 #define FLAGS_V1			0x01		//must be set for this v1 format, if clear, format differs
 #define FLAGS_HAS_CLUT		0x02		//if no, assume greyscale of given depth and no actual CLUT
 #define FLAGS_BOUNDED		0x04
+#define FLAGS_RFU			0xf8		//if any of these are set, we do not know how to decode this, do not try
 
 #define LOG(...)		//fprintf(stderr, __VA_ARGS__)
 
@@ -48,14 +49,20 @@ struct PixelRange {
 	uint16_t end;
 };
 
-struct BitBuffer {
+struct BitBufferR {
+	uint8_t bitBuf;
+	uint8_t numBitsHere;
+};
+
+struct BitBufferW {
+	uint8_t *dst;
 	uint8_t bitBuf;
 	uint8_t numBitsHere;
 };
 
 static bool readIn(void *dstP, uint32_t len);
 
-static uint_fast8_t bbRead(struct BitBuffer *bb)	//read a bit
+static uint_fast8_t bbRead(struct BitBufferR *bb)	//read a bit
 {
 	uint_fast8_t ret;
 	
@@ -76,28 +83,29 @@ static uint_fast8_t bbRead(struct BitBuffer *bb)	//read a bit
 	return ret;
 }
 
-static void bbWrite(struct BitBuffer *bb, uint_fast8_t val)
+static void bbWrite(struct BitBufferW *bb, uint_fast8_t val)
 {
 	bb->bitBuf += val << bb->numBitsHere;
 	if (++bb->numBitsHere == 8) {
-		putchar(bb->bitBuf);
+		*bb->dst++ = bb->bitBuf;
 		bb->bitBuf = 0;
 		bb->numBitsHere = 0;
 	}
 }
 
-static void bbFlush(struct BitBuffer *bb)
+static void bbFlush(struct BitBufferW *bb)
 {
 	while (bb->numBitsHere)
 		bbWrite(bb, 0);
 }
 
-static void compressImage(const struct Pixel *pixels, uint32_t w, uint32_t h, uint_fast8_t numGreyBits)
+//return num bytes produced
+static uint32_t compressImage(uint8_t *dst, const struct Pixel *pixels, uint32_t w, uint32_t h, uint_fast8_t numGreyBits, bool allowBorder)
 {
+	uint32_t numColors = 1, i, j, k, r, c, rtop, rbottom, cleft, cright, numTruncated = 0, numEncodedPixels = 0, borderColorIdx, framePix;
 	struct PixelHist *hist = calloc(sizeof(struct PixelHist), w * h);
-	uint32_t numColors = 1, i, j, k, r, c, rtop, rbottom, cleft, cright, numTruncated = 0, numEncodedPixels = 0, borderColorIdx;
 	struct PixelRange *ranges;
-	struct BitBuffer bb = {};
+	struct BitBufferW bb = {.dst = dst, };
 	struct Pixel prevPixel;
 	uint16_t min, max;
 	
@@ -127,7 +135,7 @@ static void compressImage(const struct Pixel *pixels, uint32_t w, uint32_t h, ui
 		cright++;
 	}
 	
-	//they must all be nonzero (we COULD handle not, but why?)
+	//they must all be representable as a byte
 	if (rtop > 255)
 		rtop = 255;
 	if (rbottom > 255)
@@ -136,11 +144,38 @@ static void compressImage(const struct Pixel *pixels, uint32_t w, uint32_t h, ui
 		cleft = 255;
 	if (cright > 255)
 		cright = 255;
-	if (cleft && cright && rtop && rbottom)
-		fprintf(stderr, "top: %u bottom %u, left %u right %u\n", rtop, rbottom, cleft, cright);
-	else
-		cleft = cright = rtop = rbottom = 0;
 	
+	//if we have disjoint areas, verify they are the same color, and if not, pick the larger to stick with
+	if (rtop && rbottom && !cleft && !cright) {									//separate top and bottom
+		
+		if (memcmp(pixels, pixels + (h - 1) * w, sizeof(struct Pixel))) {		//colors differ
+			
+			if (rtop > rbottom)
+				rbottom = 0;
+			else
+				rtop = 0;
+		}
+	}
+	else if (cleft && cright && !rbottom && !rtop) {							//separate right and left
+		
+		if (memcmp(pixels, pixels + w - 1, sizeof(struct Pixel))) {		//colors differ
+			
+			if (cleft > cright)
+				cright = 0;
+			else
+				cleft = 0;
+		}
+	}
+	
+	//it may not be worth it. we'll try both ways
+	framePix = (rtop + rbottom) * w + (cleft + cright) * h - (rtop + rbottom) * (cleft + cright);
+	if (allowBorder && (rtop || rbottom || cleft || cright)) {
+		
+		LOG("Border with %u pixels found and will be used: top: %u bottom %u, left %u right %u\n", framePix, rtop, rbottom, cleft, cright);
+	}
+	else {
+		cleft = cright = rtop = rbottom = 0;
+	}
 	//here, 0th color means "same as last" (pseudo-RLE)
 	
 	//collect histogram
@@ -254,41 +289,41 @@ static void compressImage(const struct Pixel *pixels, uint32_t w, uint32_t h, ui
 			ranges[i].counter, ranges[i].start, ranges[i].end);
 	
 	//emit W & H
-	putchar(w >> 8);
-	putchar(w);
-	putchar(h >> 8);
-	putchar(h);
+	*bb.dst++ = w >> 8;
+	*bb.dst++ = w;
+	*bb.dst++ = h >> 8;
+	*bb.dst++ = h;
 	
 	//flags/status byte
-	putchar(FLAGS_V1 | (numGreyBits ? 0 : FLAGS_HAS_CLUT) | (rtop ? FLAGS_BOUNDED : 0));
+	*bb.dst++ = FLAGS_V1 | (numGreyBits ? 0 : FLAGS_HAS_CLUT) | (rtop ? FLAGS_BOUNDED : 0);
 	
 	//emit num colors
-	putchar(numColors - 2);	//do not count RLE color, and offset by one to allow for 256 colors
+	*bb.dst++ = numColors - 2;	//do not count RLE color, and offset by one to allow for 256 colors
 	
 	if (rtop) {
-		putchar(rtop);
-		putchar(rbottom);
-		putchar(cleft);
-		putchar(cright);
+		*bb.dst++ = rtop;
+		*bb.dst++ = rbottom;
+		*bb.dst++ = cleft;
+		*bb.dst++ = cright;
 		
 		//find index of border
 		for (j = 0; j < numColors - 1 && memcmp(pixels, &ranges[j].color, sizeof(struct Pixel)); j++);
-		putchar(j);
+		*bb.dst++ = j;
 	}
 	
 	if (!numGreyBits) {
 		//emit clut
 		for (i = 0; i < numColors - 1; i++) {
 			
-			putchar(ranges[i].color.r);
-			putchar(ranges[i].color.g);
-			putchar(ranges[i].color.b);
+			*bb.dst++ = ranges[i].color.r;
+			*bb.dst++ = ranges[i].color.g;
+			*bb.dst++ = ranges[i].color.b;
 		}
 	}
 	
 	//emit "start" of each value (except first for which we know it)
 	for (i = 1; i < numColors; i++)
-		putchar(ranges[i].start);
+		*bb.dst++ = ranges[i].start;
 	
 	//emit pixels
 	min = 0;
@@ -356,6 +391,8 @@ static void compressImage(const struct Pixel *pixels, uint32_t w, uint32_t h, ui
 	bbFlush(&bb);
 	
 	free(ranges);
+	
+	return bb.dst - dst;
 }
 
 static bool readIn(void *dstP, uint32_t len)
@@ -396,7 +433,7 @@ static void decompressImage(uint_fast16_t w, uint_fast16_t h, uint_fast16_t rowE
 	uint32_t i, r, c;
 	uint16_t min = 0, max = 0xffff, val = 0;
 	uint_fast16_t prevIdx = numColors - 1;
-	struct BitBuffer bb = {};
+	struct BitBufferR bb = {};
 	
 	//init state
 	for (i = 0; i < sizeof(val) * 8; i++)
@@ -516,7 +553,12 @@ int main(int argc, char **argv)
 	
 	if (argv[1][0] == 'c') {	//compress
 		
+		uint32_t compressedSzF, compressedSzNF, compressedSzBest;
 		uint_fast8_t numGreyBits = 0;
+		bool rightSideUp = false;
+		struct Pixel *pixels;
+		int32_t w, h;
+		uint8_t *dst;
 		
 		switch (argv[1][1]) {
 			case 0:
@@ -535,10 +577,6 @@ int main(int argc, char **argv)
 				break;
 		}
 		
-		bool rightSideUp = false;
-		struct Pixel *pixels;
-		int32_t w, h;
-	
 		if (!readIn(&hdrBmp, sizeof(hdrBmp)) ||
 				!readIn(&hdrDib, sizeof(hdrDib)) ||
 				hdrBmp.magic[0] != 'B' ||
@@ -562,6 +600,8 @@ int main(int argc, char **argv)
 	
 		rowBytes = w * 3 + 3 / 4 * 4;
 		rowExtraBytes = rowBytes - w * 3;
+	
+		dst = malloc(w * h * 8);//big enough
 		
 		pixels = malloc(sizeof(struct Pixel) * w * h);
 		for (r = 0; r < (uint32_t)h; r++) {
@@ -605,8 +645,27 @@ int main(int argc, char **argv)
 			}
 		}
 		
-		compressImage(pixels, w, h, numGreyBits);
-		
+		//try with and without border for smaller size
+		compressedSzNF = compressImage(dst, pixels, w, h, numGreyBits, false);
+		LOG(" NF: compressed to %u bytes\n", compressedSzNF);
+		compressedSzF = compressImage(dst, pixels, w, h, numGreyBits, true);
+		LOG(" F:  compressed to %u bytes\n", compressedSzF);
+		if (compressedSzNF < compressedSzF) {
+			
+			LOG(" NF wins\n");
+			compressedSzBest = compressImage(dst, pixels, w, h, numGreyBits, false);
+		}
+		else {
+			
+			LOG(" F wins\n");
+			compressedSzBest = compressedSzF;
+		}
+		if (compressedSzBest != fwrite(dst, 1, compressedSzBest, stdout)) {
+			
+			fprintf(stderr, "write failure\n");
+			abort();
+		}
+		free(dst);
 		free(pixels);
 	}
 	else if (argv[1][1])
@@ -627,6 +686,10 @@ int main(int argc, char **argv)
 			fprintf(stderr, "unknown version\n");
 			exit(-2);
 		}
+		if (flags & FLAGS_RFU) {
+			fprintf(stderr, "unknown features\n");
+			exit(-2);
+		}
 		
 		if (flags & FLAGS_BOUNDED) {
 	
