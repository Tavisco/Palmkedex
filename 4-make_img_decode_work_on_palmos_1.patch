commit 09694dca6f008472ddb73b7c517ed15c319be216
Author: Dmitry Grinberg <dmitrygr@gmail.com>
Date:   Tue Dec 27 22:42:51 2022 -0600

    use storage heap for image decoding when dynamic allocation fails
    
    This is likely on PalmOS 1.0 or 2.0, where dynamic heaps are tiny.
    The gamble is a fun one: allocat eon the storage heap and leave it
    unprotected for the duration of image decoding and repacking. This
    works well

diff --git a/Src/imgDraw.c b/Src/imgDraw.c
index b3669e4..8fcd11e 100644
--- a/Src/imgDraw.c
+++ b/Src/imgDraw.c
@@ -6,6 +6,9 @@
 #include "imgDrawInt.h"
 #include "imgDraw.h"
 
+SysAppInfoPtr SysCurAppInfoPV20(void)	SYS_TRAP(sysTrapSysCurAppInfoPV20);	//not declared anywhere
+
+
 #define PNG_HI_RES_SUPPORTED				1		//sonyHR only supports double
 #define PNG_VARIOUS_DENSITIES_SUPPORTED		2		//palmHR supports various
 
@@ -228,8 +231,26 @@ static unsigned char imgDrawHdrCbk(struct DrawState *ds, uint32_t w, uint32_t h,
 		realStride = ((w * curDepth) + 15) / 16 * 2;
 		virtualStride = realStride * 8 / curDepth;
 		bmp1 = MemPtrNew(sizeof(struct BitmapTypeV1) + virtualStride * h);	//enough space for 8bpp, will shrink later - our decoder emits 8bpp
-		if (!bmp1)
-			return false;
+		if (!bmp1) {
+			
+			MemHandle mh;
+			
+			//we failed to allocate in the dynamic heap
+			//for PalmOS < 5, we can try the storage heap, with protection disabled (scary but effective)
+			
+			if (romVersion >= sysMakeROMVersion(5,0,0,sysROMStageDevelopment,0))
+				return false;
+			
+			//null first param to DmNewHandle() is not supported in PalmOS1.0
+			mh = DmNewHandle((DmOpenRef)(SysCurAppInfoPV20()->dmAccessP), sizeof(struct BitmapTypeV1) + virtualStride * h);
+			if (!mh)
+				return false;
+			
+			bmp1 = MemHandleLock(mh);
+			
+			//disable memory protection. we'll re-enable after we finish decoding and repacking, in imgDecodeCall()
+			MemSemaphoreReserve(true);
+		}
 		MemSet(bmp1, sizeof(*bmp1), 0);
 		bmp1->width = w;
 		bmp1->height = h;
@@ -251,7 +272,7 @@ static unsigned char imgDrawHdrCbk(struct DrawState *ds, uint32_t w, uint32_t h,
 
 static int imgDecodeCall(struct DrawState *ds, const void *data, uint32_t dataSz)
 {
-	UInt32 processorType, result;
+	UInt32 processorType, result, romVersion;
 	int ret;
 	
 	if (errNone == FtrGet(sysFileCSystem, sysFtrNumProcessorID, &processorType)	&& sysFtrNumProcessorIsARM(processorType)) {
@@ -282,6 +303,14 @@ static int imgDecodeCall(struct DrawState *ds, const void *data, uint32_t dataSz
 		MemPtrResize(ds->b, sizeof(struct BitmapTypeV1) + bmp1->height * bmp1->rowBytes);
 	}
 	
+	if (errNone == FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion) && romVersion < sysMakeROMVersion(5,0,0,sysROMStageDevelopment,0)) {
+		
+		//for PalmOS below 5.0 we could have allocated the chunk i nthe storage heap and left it unprotected. If so, now that we're done writing to it,
+		// re-protect the heap. We detect this case by checking if the chunk is in fact in a non-dynamic heap
+		if (ds->b && !MemHeapDynamic(MemPtrHeapID(ds->b)))
+			MemSemaphoreRelease(true);
+	}
+	
 	return ret;
 }
 
