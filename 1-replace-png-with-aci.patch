commit 7ce0162ee7c63c29f2da6f8a6d8a4f0ffd9cb565
Author: Dmitry Grinberg <dmitrygr@gmail.com>
Date:   Mon Dec 26 22:43:36 2022 -0600

    replace PNG with ACI

diff --git a/.gitignore b/.gitignore
index 220e8f8..75d561e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,7 +4,6 @@ Release/*
 .vscode/
 scripts/bin/*
 scripts/img/*
-Rsc/images/interface/*.xcf
 scripts/names.txt
 scripts/to_resource.txt
 scripts/to_img_resource.txt
@@ -13,4 +12,4 @@ Tavisco_Data/*.BIN
 *.bin
 *.bak
 Tavisco_Data
-*.elf
\ No newline at end of file
+*.elf
diff --git a/Makefile b/Makefile
index db59800..6ba5b96 100644
--- a/Makefile
+++ b/Makefile
@@ -8,21 +8,21 @@ OBJCOPY			=	$(TOOLCHAIN)/m68k-none-elf-objcopy
 ARMCC			=	$(ARMTOOLCHAIN)gcc
 ARMLD			=	$(ARMTOOLCHAIN)gcc
 ARMOBJCOPY		=	$(ARMTOOLCHAIN)objcopy
-LTO				=	-flto
+LTO				=	#-flto
 ARMLTO			=	-flto
-ARMTYPE			=	-mthumb
+ARMTYPE			=	-marm		#shoudl be -mthumb or -marm
 COMMON			=	-DPNGLE_NO_GAMMA_CORRECTION -DPNGLE_SKIP_CRC
-M68KCOMMON		=	$(COMMON) -Wno-multichar -funsafe-math-optimizations -Os -m68000 -mno-align-int -mpcrel -fpic -fshort-enums
-ARMCOMMON		=	$(COMMON) -Os -march=armv4t $(ARMTYPE) -mno-unaligned-access -ffixed-r9 -ffixed-r10 -ffixed-r11 -fomit-frame-pointer -D__ARM__ -ffreestanding -fpic -mthumb-interwork
+M68KCOMMON		=	$(COMMON) -Wno-multichar -funsafe-math-optimizations -Os -m68000 -mno-align-int -mpcrel -fpic -fshort-enums -mshort
+ARMCOMMON		=	$(COMMON) -Ofast -march=armv4t $(ARMTYPE) -mno-unaligned-access -ffixed-r9 -ffixed-r10 -ffixed-r11 -fomit-frame-pointer -D__ARM__ -ffreestanding -fpic -mthumb-interwork
 WARN			=	-Wsign-compare -Wextra -Wall -Wno-unused-parameter -Wno-old-style-declaration -Wno-unused-function -Wno-unused-variable -Wno-error=cpp -Wno-error=switch
 LKR				=	Src/68k.lkr
-ARMLKR			=	Src/arm.lkr
+ARMLKR			=	src/arm.lkr
 CCFLAGS			=	$(LTO) $(WARN) $(M68KCOMMON) -I. -ffunction-sections -fdata-sections
 LDFLAGS			=	$(LTO) $(WARN) $(M68KCOMMON) -Wl,--gc-sections -Wl,-T $(LKR)
 ARMCCFLAGS		=	$(ARMLTO) $(WARN) $(ARMCOMMON) -I. -ffunction-sections -fdata-sections
 ARMLDFLAGS		=	$(ARMLTO) $(WARN) $(ARMCOMMON) -Wl,--gc-sections -Wl,-T $(ARMLKR)
-SRCS-68k		=   Src/Palmkedex.c Src/Main.c Src/PkmnMain.c Src/PkmnType.c Src/helpers.c Src/miniz.c Src/pngle.c Src/pngDraw.c Src/pngDraw-68k.c
-SRCS-arm		=	Src/helpers.c Src/miniz.c Src/pngle.c Src/pngDrawArm.c Src/armcalls.c
+SRCS-68k		=   Src/Palmkedex.c Src/Main.c Src/PkmnMain.c Src/PkmnType.c Src/glue.c Src/helpers.c Src/imgDraw.c Src/aciDecode.c Src/aciDecodeAsm68k.S
+SRCS-arm		=	Src/helpers.c Src/imgDrawArmlet.c Src/armcalls.c Src/aciDecode.c Src/aciDecodeARM.S
 RCP				=	Rsc/Palmkedex_Rsc.rcp
 SPRITESRCP		=	Rsc/pkmn_sprites.rcp
 RSC				=	Src/
@@ -34,7 +34,7 @@ SPRITECREATOR	=	PKSP
 SPRITETYPE		=	pSPR
 
 #add PalmOS SDK
-#INCS			+=	-isystem "gccisms"
+INCS			+=	-isystem "gccisms"
 INCS			+=	-isystem "$(SDK)"
 INCS			+=	-isystem "$(SDK)/Core"
 INCS			+=	-isystem "$(SDK)/Core/Hardware"
@@ -73,12 +73,18 @@ $(TARGET).prc: code0001.68k.bin armc0001.arm.bin
 %.68k.o : %.c Makefile
 	$(CC) $(CCFLAGS)  $(INCS) -c $< -o $@
 
+%.68k.o : %.S Makefile
+	$(CC) $(CCFLAGS)  $(INCS) -c $< -o $@
+
 %.arm.o : %.c Makefile
 	$(ARMCC) $(ARMCCFLAGS) $(INCS) -c $< -o $@
 
+%.arm.o : %.S Makefile
+	$(ARMCC) $(ARMCCFLAGS) $(INCS) -c $< -o $@
+
 $(TARGETSPRITES).prc:
 	$(PILRC) -ro -o $(TARGETSPRITES).prc -creator $(SPRITECREATOR) -type $(SPRITETYPE) -name $(TARGETSPRITES) $(SPRITESRCP)
 
 .PHONY: clean
 clean:
-	rm -rf $(OBJS-68k) $(TARGET).prc $(TARGETSPRITES).prc
\ No newline at end of file
+	rm -rf $(OBJS-68k) $(TARGET).prc $(TARGETSPRITES).prc
diff --git a/Src/Main.c b/Src/Main.c
index e49b07e..025154f 100644
--- a/Src/Main.c
+++ b/Src/Main.c
@@ -1,362 +1,362 @@
-#include <PalmOS.h>
-
-#include "Palmkedex.h"
-#include "Rsc/Palmkedex_Rsc.h"
-
-void SetupListNameVars(SharedVariables *sharedVars, Int16 itemNum)
-{
-	UInt32 pstSpeciesInt, pstSharedInt;
-	Char numItoA[4];
-	Err err = errNone;
-	Species *species;
-	Int16 numChars = 3;
-	Char *buffer;
-
-	buffer = (Char *)MemPtrNew(sizeof(Char[5]));
-	ErrFatalDisplayIf ((UInt32)buffer == 0, "Failed to set buffer");
-	MemSet(buffer, sizeof(Char[5]), 0);
-
-	if (sharedVars->sizeAfterFiltering == PKMN_QUANTITY) {
-		err = FtrGet(appFileCreator, ftrPkmnNamesNum, &pstSpeciesInt);
-		ErrFatalDisplayIf (err != errNone, "Failed to load pokemon names");
-		species = (Species*)pstSpeciesInt;
-
-		StrIToA(numItoA, itemNum+1);
-		
-		StrCopy(sharedVars->pkmnLstNameStr, species->nameList[itemNum].name);
-	} else {
-		StrIToA(numItoA, sharedVars->filteredPkmnNumbers[itemNum]);
-		StrCopy(sharedVars->pkmnLstNameStr, sharedVars->filteredList[itemNum].name);
-	}
-
-	StrCat(buffer, "#");
-	// Add leading zeroes
-	Int16 numZeroes = numChars - StrLen(numItoA);
-	for (Int16 i = 0; i < numZeroes; i++) {
-		StrCat(buffer, "0");
-	}
-	StrCat(buffer, numItoA);
-	StrCopy(sharedVars->pkmnLstNumStr, buffer);
-	MemPtrFree(buffer);
-}
-
-static void PokemonListDraw(Int16 itemNum, RectangleType *bounds, Char **unused)
-{
-	UInt32 pstSharedInt;
-	SharedVariables *sharedVars;
-	Err err = errNone;
-
-	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
-	ErrFatalDisplayIf (err != errNone, "Failed to load shared variables");
-	sharedVars = (SharedVariables *)pstSharedInt;
-
-	// This is very wasteful. We should store this in a database
-	// already formatted as we need
-	SetupListNameVars(sharedVars, itemNum);
-
-	FntSetFont(boldFont);
-	WinDrawChars(sharedVars->pkmnLstNumStr, 4, bounds->topLeft.x, bounds->topLeft.y);
-	FntSetFont(stdFont);
-	WinPaintChars(sharedVars->pkmnLstNameStr, MAX_PKMN_NAME_LEN, bounds->topLeft.x + 32, bounds->topLeft.y);
-}
-
-static void ParseSearchString(Char *searchStr, Char charInserted)
-{
-	Char *fieldStr;
-	FieldType *fldSearch = GetObjectPtr(MainSearchField);
-
-	fieldStr = FldGetTextPtr(fldSearch);
-
-	if (fieldStr != NULL)
-	{
-		if (charInserted == BACKSPACE_CHAR)
-		{
-			StrNCat(searchStr, fieldStr, StrLen(fieldStr)); // Copy N-1 char if backspace.
-		} else {
-			StrCat(searchStr, fieldStr);		
-		}
-	}
-	
-	// And, the inputed char, if it's not a backspace
-	if (charInserted != BACKSPACE_CHAR)
-	{
-		searchStr[StrLen(searchStr)] = charInserted;
-	}
-}
-
-static void PrepareMemoryForSearch(SharedVariables *sharedVars)
-{
-	if ((UInt32)sharedVars->filteredList != 0)
-	{
-		MemPtrFree(sharedVars->filteredList);
-	}
-	if ((UInt32)sharedVars->filteredPkmnNumbers != 0)
-	{
-		MemPtrFree(sharedVars->filteredPkmnNumbers);
-	}
-	
-	sharedVars->filteredList = (SpeciesNames *)MemPtrNew(sizeof(SpeciesNames[MAX_SEARCH_RESULT_LEN]));
-	ErrFatalDisplayIf (((UInt32)sharedVars->filteredList == 0), "Out of memory");
-	MemSet(sharedVars->filteredList, sizeof(SpeciesNames[MAX_SEARCH_RESULT_LEN]), 0);
-
-	sharedVars->filteredPkmnNumbers = (UInt16 *)MemPtrNew(sizeof(UInt16[MAX_SEARCH_RESULT_LEN]));
-	ErrFatalDisplayIf (((UInt32)sharedVars->filteredPkmnNumbers == 0), "Out of memory");
-	MemSet(sharedVars->filteredPkmnNumbers, sizeof(UInt16[MAX_SEARCH_RESULT_LEN]), 0);
-}
-
-static Boolean IsNameShorterThanQuery(Char *pkmnName, UInt16 searchLen)
-{
-	return StrLen(pkmnName) < searchLen-1;
-}
-
-static Boolean NameMatchesQuery(Char *pkmnName, Char *searchStr, UInt16 searchLen)
-{
-	UInt16 i;
-
-	for (i = 0; i < searchLen; i++)
-	{			
-		if (searchStr[i] != pkmnName[i])
-		{
-			break;
-		}
-	}
-
-	// If the iterator have the same lenght
-	// as the search string, it means that all 
-	// the chars are equal, and thus, it's a match
-	return i == searchLen-1;
-}
-
-static void FilterDataSet(Char charInserted)
-{
-	UInt16 searchLen, matchCount, i;
-	UInt32 pstSpeciesInt, pstSharedInt;
-	Species *species;
-	SharedVariables *sharedVars;
-	Char searchStr[MAX_PKMN_NAME_LEN+1] = "";
-	Char substringPkmnName[MAX_PKMN_NAME_LEN+1] = "";
-	Err err = errNone;
-
-	err = FtrGet(appFileCreator, ftrPkmnNamesNum, &pstSpeciesInt);
-	ErrFatalDisplayIf (err != errNone, "Failed to load pokemon names");
-	species = (Species*)pstSpeciesInt;
-
-	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
-	ErrFatalDisplayIf (err != errNone, "Failed to load shared variables");
-	sharedVars = (SharedVariables *)pstSharedInt;
-
-	ParseSearchString(searchStr, charInserted);
-
-	if (StrLen(searchStr) == 0)
-	{
-		// If nothing is being searched, no need to filter :)
-		sharedVars->sizeAfterFiltering = PKMN_QUANTITY;
-		return;
-	}
-
-	PrepareMemoryForSearch(sharedVars);
-
-	searchLen = StrLen(searchStr)+1;
-	matchCount = 0;
-
-	for (i = 0; i < PKMN_QUANTITY; i++)
-	{
-		if (IsNameShorterThanQuery(species->nameList[i].name, searchLen))
-		{
-			continue;
-		}
-		
-		if (NameMatchesQuery(species->nameList[i].name, searchStr, searchLen))
-		{
-			StrCopy(sharedVars->filteredList[matchCount].name, species->nameList[i].name);
-			sharedVars->filteredPkmnNumbers[matchCount] = i+1;
-			matchCount++;
-		}
-
-		if (matchCount == MAX_SEARCH_RESULT_LEN)
-		{
-			StrCopy(sharedVars->filteredList[MAX_SEARCH_RESULT_LEN-1].name, MAX_SEARCH_STR);
-			sharedVars->filteredPkmnNumbers[MAX_SEARCH_RESULT_LEN-1] = MAX_SEARCH_PKMN_NUM;
-			break;
-		}
-	}
-
-	sharedVars->sizeAfterFiltering = matchCount;
-}
-
-void OpenAboutDialog()
-{
-	FormType * frmP;
-
-	/* Clear the menu status from the display */
-	MenuEraseStatus(0);
-	
-	/* Display the About Box. */
-	frmP = FrmInitForm (AboutForm);
-	FrmDoDialog (frmP);
-	FrmDeleteForm (frmP);
-}
-
-static void UpdateList(Char charInserted)
-{
-	ListType *list;
-	
-	FilterDataSet(charInserted);
-
-	list = GetObjectPtr(MainSearchList);
-	// Set custom list drawing callback function.
-	LstSetDrawFunction(list, PokemonListDraw);
-	// Set list item number
-	LstSetListChoices(list, NULL, GetCurrentListSize());
-	LstSetSelection(list, -1);
-	LstDrawList(list);
-}
-
-Int16 GetCurrentListSize()
-{
-	UInt32 pstSharedInt;
-	SharedVariables *sharedVars;
-	Err err = errNone;
-
-	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
-	ErrFatalDisplayIf (err != errNone, "Failed to load shared variables");
-	sharedVars = (SharedVariables *)pstSharedInt;
-
-	return sharedVars->sizeAfterFiltering;
-}
-
-static Boolean IsSelectionValid(UInt16 selection)
-{
-	return selection != MAX_SEARCH_PKMN_NUM;
-}
-
-void OpenMainPkmnForm(Int16 selection)
-{
-	UInt32 pstSharedInt;
-	UInt16 selectedPkmn;
-	SharedVariables *sharedVars;
-	Err err = errNone;
-
-	selectedPkmn = GetPkmnId(selection);
-
-	if (IsSelectionValid((UInt16) selectedPkmn))
-	{
-		err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
-		ErrFatalDisplayIf (err != errNone, "Failed to load shared variables");
-		sharedVars = (SharedVariables *)pstSharedInt;
-
-		sharedVars->selectedPkmnId = selectedPkmn;
-
-		FrmGotoForm(PkmnMainForm);
-	} else {
-		FrmAlert (InvalidPokemonAlert);
-		UpdateList(NULL);
-	}
-}
-
-UInt16 GetPkmnId(Int16 selection)
-{
-	UInt32 pstSharedInt;
-	SharedVariables *sharedVars;
-	Err err = errNone;
-
-	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
-	ErrFatalDisplayIf (err != errNone, "Failed to load shared variables");
-	sharedVars = (SharedVariables *)pstSharedInt;
-
-	if (sharedVars->sizeAfterFiltering == PKMN_QUANTITY)
-	{
-		return selection + 1;
-	} else {
-		return sharedVars->filteredPkmnNumbers[selection];
-	}
-}
-
-/*
- * FUNCTION: MainFormDoCommand
- *
- * DESCRIPTION: This routine performs the menu command specified.
- *
- * PARAMETERS:
- *
- * command
- *     menu item id
- */
-
-static Boolean MainFormDoCommand(UInt16 command)
-{
-	Boolean handled = false;
-
-	switch (command)
-	{
-		case OptionsAboutPalmkedex:
-		{
-			OpenAboutDialog();
-			handled = true;
-			break;
-		}
-	}
-
-	return handled;
-}
-
-/*
- * FUNCTION: MainFormHandleEvent
- *
- * DESCRIPTION:
- *
- * This routine is the event handler for the "MainForm" of this 
- * application.
- *
- * PARAMETERS:
- *
- * eventP
- *     a pointer to an EventType structure
- *
- * RETURNED:
- *     true if the event was handled and should not be passed to
- *     FrmHandleEvent
- */
-
-Boolean MainFormHandleEvent(EventType * eventP)
-{
-	Boolean handled = false;
-	FormType * frmP;
-	UInt16 focus;
-
-	switch (eventP->eType) 
-	{
-		case menuEvent:
-			return MainFormDoCommand(eventP->data.menu.itemID);
-		
-		case ctlSelectEvent:
-			return MainFormDoCommand(eventP->data.menu.itemID);
-
-		case frmOpenEvent:
-			frmP = FrmGetActiveForm();
-			FrmDrawForm(frmP);
-			UpdateList(NULL);
-			handled = true;
-			break;
-            
-        case lstSelectEvent:
-			OpenMainPkmnForm(eventP->data.lstSelect.selection);
-			break;
-
-		case keyDownEvent:
-		{
-			focus = FrmGetFocus(FrmGetActiveForm());
-			if (focus != noFocus)
-			{
-				UpdateList(eventP->data.keyDown.chr);
-			}
-			break;
-		}
-
-		default:
-			break;
-	}
-    
-	return handled;
-}
-
+#include <PalmOS.h>
+
+#include "Palmkedex.h"
+#include "Rsc/Palmkedex_Rsc.h"
+
+void SetupListNameVars(SharedVariables *sharedVars, Int16 itemNum)
+{
+	UInt32 pstSpeciesInt, pstSharedInt;
+	Char numItoA[4];
+	Err err = errNone;
+	Species *species;
+	Int16 numChars = 3;
+	Char *buffer;
+
+	buffer = (Char *)MemPtrNew(sizeof(Char[5]));
+	ErrFatalDisplayIf ((UInt32)buffer == 0, "Failed to set buffer");
+	MemSet(buffer, sizeof(Char[5]), 0);
+
+	if (sharedVars->sizeAfterFiltering == PKMN_QUANTITY) {
+		err = FtrGet(appFileCreator, ftrPkmnNamesNum, &pstSpeciesInt);
+		ErrFatalDisplayIf (err != errNone, "Failed to load pokemon names");
+		species = (Species*)pstSpeciesInt;
+
+		StrIToA(numItoA, itemNum+1);
+		
+		StrCopy(sharedVars->pkmnLstNameStr, species->nameList[itemNum].name);
+	} else {
+		StrIToA(numItoA, sharedVars->filteredPkmnNumbers[itemNum]);
+		StrCopy(sharedVars->pkmnLstNameStr, sharedVars->filteredList[itemNum].name);
+	}
+
+	StrCat(buffer, "#");
+	// Add leading zeroes
+	Int16 numZeroes = numChars - StrLen(numItoA);
+	for (Int16 i = 0; i < numZeroes; i++) {
+		StrCat(buffer, "0");
+	}
+	StrCat(buffer, numItoA);
+	StrCopy(sharedVars->pkmnLstNumStr, buffer);
+	MemPtrFree(buffer);
+}
+
+static void PokemonListDraw(Int16 itemNum, RectangleType *bounds, Char **unused)
+{
+	UInt32 pstSharedInt;
+	SharedVariables *sharedVars;
+	Err err = errNone;
+
+	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
+	ErrFatalDisplayIf (err != errNone, "Failed to load shared variables");
+	sharedVars = (SharedVariables *)pstSharedInt;
+
+	// This is very wasteful. We should store this in a database
+	// already formatted as we need
+	SetupListNameVars(sharedVars, itemNum);
+
+	FntSetFont(boldFont);
+	WinDrawChars(sharedVars->pkmnLstNumStr, 4, bounds->topLeft.x, bounds->topLeft.y);
+	FntSetFont(stdFont);
+	WinPaintChars(sharedVars->pkmnLstNameStr, MAX_PKMN_NAME_LEN, bounds->topLeft.x + 32, bounds->topLeft.y);
+}
+
+static void ParseSearchString(Char *searchStr, Char charInserted)
+{
+	Char *fieldStr;
+	FieldType *fldSearch = GetObjectPtr(MainSearchField);
+
+	fieldStr = FldGetTextPtr(fldSearch);
+
+	if (fieldStr != NULL)
+	{
+		if (charInserted == BACKSPACE_CHAR)
+		{
+			StrNCat(searchStr, fieldStr, StrLen(fieldStr)); // Copy N-1 char if backspace.
+		} else {
+			StrCat(searchStr, fieldStr);		
+		}
+	}
+	
+	// And, the inputed char, if it's not a backspace
+	if (charInserted != BACKSPACE_CHAR)
+	{
+		searchStr[StrLen(searchStr)] = charInserted;
+	}
+}
+
+static void PrepareMemoryForSearch(SharedVariables *sharedVars)
+{
+	if ((UInt32)sharedVars->filteredList != 0)
+	{
+		MemPtrFree(sharedVars->filteredList);
+	}
+	if ((UInt32)sharedVars->filteredPkmnNumbers != 0)
+	{
+		MemPtrFree(sharedVars->filteredPkmnNumbers);
+	}
+	
+	sharedVars->filteredList = (SpeciesNames *)MemPtrNew(sizeof(SpeciesNames[MAX_SEARCH_RESULT_LEN]));
+	ErrFatalDisplayIf (((UInt32)sharedVars->filteredList == 0), "Out of memory");
+	MemSet(sharedVars->filteredList, sizeof(SpeciesNames[MAX_SEARCH_RESULT_LEN]), 0);
+
+	sharedVars->filteredPkmnNumbers = (UInt16 *)MemPtrNew(sizeof(UInt16[MAX_SEARCH_RESULT_LEN]));
+	ErrFatalDisplayIf (((UInt32)sharedVars->filteredPkmnNumbers == 0), "Out of memory");
+	MemSet(sharedVars->filteredPkmnNumbers, sizeof(UInt16[MAX_SEARCH_RESULT_LEN]), 0);
+}
+
+static Boolean IsNameShorterThanQuery(Char *pkmnName, UInt16 searchLen)
+{
+	return StrLen(pkmnName) < searchLen-1;
+}
+
+static Boolean NameMatchesQuery(Char *pkmnName, Char *searchStr, UInt16 searchLen)
+{
+	UInt16 i;
+
+	for (i = 0; i < searchLen; i++)
+	{			
+		if (searchStr[i] != pkmnName[i])
+		{
+			break;
+		}
+	}
+
+	// If the iterator have the same lenght
+	// as the search string, it means that all 
+	// the chars are equal, and thus, it's a match
+	return i == searchLen-1;
+}
+
+static void FilterDataSet(Char charInserted)
+{
+	UInt16 searchLen, matchCount, i;
+	UInt32 pstSpeciesInt, pstSharedInt;
+	Species *species;
+	SharedVariables *sharedVars;
+	Char searchStr[MAX_PKMN_NAME_LEN+1] = "";
+	Char substringPkmnName[MAX_PKMN_NAME_LEN+1] = "";
+	Err err = errNone;
+
+	err = FtrGet(appFileCreator, ftrPkmnNamesNum, &pstSpeciesInt);
+	ErrFatalDisplayIf (err != errNone, "Failed to load pokemon names");
+	species = (Species*)pstSpeciesInt;
+
+	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
+	ErrFatalDisplayIf (err != errNone, "Failed to load shared variables");
+	sharedVars = (SharedVariables *)pstSharedInt;
+
+	ParseSearchString(searchStr, charInserted);
+
+	if (StrLen(searchStr) == 0)
+	{
+		// If nothing is being searched, no need to filter :)
+		sharedVars->sizeAfterFiltering = PKMN_QUANTITY;
+		return;
+	}
+
+	PrepareMemoryForSearch(sharedVars);
+
+	searchLen = StrLen(searchStr)+1;
+	matchCount = 0;
+
+	for (i = 0; i < PKMN_QUANTITY; i++)
+	{
+		if (IsNameShorterThanQuery(species->nameList[i].name, searchLen))
+		{
+			continue;
+		}
+		
+		if (NameMatchesQuery(species->nameList[i].name, searchStr, searchLen))
+		{
+			StrCopy(sharedVars->filteredList[matchCount].name, species->nameList[i].name);
+			sharedVars->filteredPkmnNumbers[matchCount] = i+1;
+			matchCount++;
+		}
+
+		if (matchCount == MAX_SEARCH_RESULT_LEN)
+		{
+			StrCopy(sharedVars->filteredList[MAX_SEARCH_RESULT_LEN-1].name, MAX_SEARCH_STR);
+			sharedVars->filteredPkmnNumbers[MAX_SEARCH_RESULT_LEN-1] = MAX_SEARCH_PKMN_NUM;
+			break;
+		}
+	}
+
+	sharedVars->sizeAfterFiltering = matchCount;
+}
+
+void OpenAboutDialog()
+{
+	FormType * frmP;
+
+	/* Clear the menu status from the display */
+	MenuEraseStatus(0);
+	
+	/* Display the About Box. */
+	frmP = FrmInitForm (AboutForm);
+	FrmDoDialog (frmP);
+	FrmDeleteForm (frmP);
+}
+
+static void UpdateList(Char charInserted)
+{
+	ListType *list;
+	
+	FilterDataSet(charInserted);
+
+	list = GetObjectPtr(MainSearchList);
+	// Set custom list drawing callback function.
+	LstSetDrawFunction(list, PokemonListDraw);
+	// Set list item number
+	LstSetListChoices(list, NULL, GetCurrentListSize());
+	LstSetSelection(list, -1);
+	LstDrawList(list);
+}
+
+Int16 GetCurrentListSize()
+{
+	UInt32 pstSharedInt;
+	SharedVariables *sharedVars;
+	Err err = errNone;
+
+	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
+	ErrFatalDisplayIf (err != errNone, "Failed to load shared variables");
+	sharedVars = (SharedVariables *)pstSharedInt;
+
+	return sharedVars->sizeAfterFiltering;
+}
+
+static Boolean IsSelectionValid(UInt16 selection)
+{
+	return selection != MAX_SEARCH_PKMN_NUM;
+}
+
+void OpenMainPkmnForm(Int16 selection)
+{
+	UInt32 pstSharedInt;
+	UInt16 selectedPkmn;
+	SharedVariables *sharedVars;
+	Err err = errNone;
+
+	selectedPkmn = GetPkmnId(selection);
+
+	if (IsSelectionValid((UInt16) selectedPkmn))
+	{
+		err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
+		ErrFatalDisplayIf (err != errNone, "Failed to load shared variables");
+		sharedVars = (SharedVariables *)pstSharedInt;
+
+		sharedVars->selectedPkmnId = selectedPkmn;
+
+		FrmGotoForm(PkmnMainForm);
+	} else {
+		FrmAlert (InvalidPokemonAlert);
+		UpdateList(NULL);
+	}
+}
+
+UInt16 GetPkmnId(Int16 selection)
+{
+	UInt32 pstSharedInt;
+	SharedVariables *sharedVars;
+	Err err = errNone;
+
+	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
+	ErrFatalDisplayIf (err != errNone, "Failed to load shared variables");
+	sharedVars = (SharedVariables *)pstSharedInt;
+
+	if (sharedVars->sizeAfterFiltering == PKMN_QUANTITY)
+	{
+		return selection + 1;
+	} else {
+		return sharedVars->filteredPkmnNumbers[selection];
+	}
+}
+
+/*
+ * FUNCTION: MainFormDoCommand
+ *
+ * DESCRIPTION: This routine performs the menu command specified.
+ *
+ * PARAMETERS:
+ *
+ * command
+ *     menu item id
+ */
+
+static Boolean MainFormDoCommand(UInt16 command)
+{
+	Boolean handled = false;
+
+	switch (command)
+	{
+		case OptionsAboutPalmkedex:
+		{
+			OpenAboutDialog();
+			handled = true;
+			break;
+		}
+	}
+
+	return handled;
+}
+
+/*
+ * FUNCTION: MainFormHandleEvent
+ *
+ * DESCRIPTION:
+ *
+ * This routine is the event handler for the "MainForm" of this 
+ * application.
+ *
+ * PARAMETERS:
+ *
+ * eventP
+ *     a pointer to an EventType structure
+ *
+ * RETURNED:
+ *     true if the event was handled and should not be passed to
+ *     FrmHandleEvent
+ */
+
+Boolean MainFormHandleEvent(EventType * eventP)
+{
+	Boolean handled = false;
+	FormType * frmP;
+	UInt16 focus;
+
+	switch (eventP->eType) 
+	{
+		case menuEvent:
+			return MainFormDoCommand(eventP->data.menu.itemID);
+		
+		case ctlSelectEvent:
+			return MainFormDoCommand(eventP->data.menu.itemID);
+
+		case frmOpenEvent:
+			frmP = FrmGetActiveForm();
+			FrmDrawForm(frmP);
+			UpdateList(NULL);
+			handled = true;
+			break;
+            
+        case lstSelectEvent:
+			OpenMainPkmnForm(eventP->data.lstSelect.selection);
+			break;
+
+		case keyDownEvent:
+		{
+			focus = FrmGetFocus(FrmGetActiveForm());
+			if (focus != noFocus)
+			{
+				UpdateList(eventP->data.keyDown.chr);
+			}
+			break;
+		}
+
+		default:
+			break;
+	}
+    
+	return handled;
+}
+
diff --git a/Src/Palmkedex.c b/Src/Palmkedex.c
index f07870a..ceb024a 100644
--- a/Src/Palmkedex.c
+++ b/Src/Palmkedex.c
@@ -1,395 +1,404 @@
-/*
- * Palmkedex.c
- *
- * main file for Palmkedex
- *
- * This wizard-generated code is based on code adapted from the
- * stationery files distributed as part of the Palm OS SDK 4.0.
- *
- * Copyright (c) 1999-2000 Palm, Inc. or its subsidiaries.
- * All rights reserved.
- */
- 
-#include <PalmOS.h>
-#include <PalmOSGlue.h>
-#include <SonyCLIE.h>
-
-#include "Palmkedex.h"
-#include "Rsc/Palmkedex_Rsc.h"
-#include "Rsc/pkmn_names.h"
-
-/*********************************************************************
- * Entry Points
- *********************************************************************/
-
-/*********************************************************************
- * Global variables
- *********************************************************************/
-
-
-
-/*********************************************************************
- * Internal Constants
- *********************************************************************/
-
-/* Define the minimum OS version we support */
-#define ourMinVersion    sysMakeROMVersion(3,5,0,sysROMStageDevelopment,0)
-#define kPalmOS20Version sysMakeROMVersion(2,0,0,sysROMStageDevelopment,0)
-
-/*********************************************************************
- * Internal Functions
- *********************************************************************/
-
-/*
- * FUNCTION: GetObjectPtr
- *
- * DESCRIPTION:
- *
- * This routine returns a pointer to an object in the current form.
- *
- * PARAMETERS:
- *
- * formId
- *     id of the form to display
- *
- * RETURNED:
- *     address of object as a void pointer
- */
-
-void * GetObjectPtr(UInt16 objectID)
-{
-	FormType * frmP;
-
-	frmP = FrmGetActiveForm();
-	return FrmGetObjectPtr(frmP, FrmGetObjectIndex(frmP, objectID));
-}
-
-
-/*
- * FUNCTION: AppHandleEvent
- *
- * DESCRIPTION: 
- *
- * This routine loads form resources and set the event handler for
- * the form loaded.
- *
- * PARAMETERS:
- *
- * event
- *     a pointer to an EventType structure
- *
- * RETURNED:
- *     true if the event was handled and should not be passed
- *     to a higher level handler.
- */
-
-static Boolean AppHandleEvent(EventType * eventP)
-{
-	UInt16 formId;
-	FormType * frmP;
-
-	if (eventP->eType == frmLoadEvent)
-	{
-		/* Load the form resource. */
-		formId = eventP->data.frmLoad.formID;
-		frmP = FrmInitForm(formId);
-		FrmSetActiveForm(frmP);
-
-		/* 
-		 * Set the event handler for the form.  The handler of the
-		 * currently active form is called by FrmHandleEvent each
-		 * time is receives an event. 
-		 */
-		switch (formId)
-		{
-			case MainForm:
-				FrmSetEventHandler(frmP, MainFormHandleEvent);
-				break;
-			case PkmnMainForm:
-				FrmSetEventHandler(frmP, PkmnMainFormHandleEvent);
-				break;
-			case PkmnTypeForm:
-				FrmSetEventHandler(frmP, PkmnTypeFormHandleEvent);
-				break;
-		}
-		return true;
-	}
-
-	return false;
-}
-
-/*
- * FUNCTION: AppEventLoop
- *
- * DESCRIPTION: This routine is the event loop for the application.
- */
-
-static void AppEventLoop(void)
-{
-	UInt16 error;
-	EventType event;
-
-	do 
-	{
-		/* change timeout if you need periodic nilEvents */
-		EvtGetEvent(&event, evtWaitForever);
-
-		if (! SysHandleEvent(&event))
-		{
-			if (! MenuHandleEvent(0, &event, &error))
-			{
-				if (! AppHandleEvent(&event))
-				{
-					FrmDispatchEvent(&event);
-				}
-			}
-		}
-	} while (event.eType != appStopEvent);
-}
-
-
-static void MakeSharedVariables()
-{
-	SharedVariables *sharedVars;
-	Err err = errNone;
-
-	sharedVars = (SharedVariables *)MemPtrNew(sizeof(SharedVariables));
-	ErrFatalDisplayIf ((!sharedVars), "Out of memory");
-	MemSet(sharedVars, sizeof(SharedVariables), 0);
-
-	sharedVars->sizeAfterFiltering = PKMN_QUANTITY;
-
-	err = FtrSet(appFileCreator, ftrShrdVarsNum, (UInt32)sharedVars);
-	ErrFatalDisplayIf (err != errNone, "Failed to set feature memory");
-}
-
-static void LoadSpecies()
-{
-	Species *species;
-	UInt16 i;
-	Err err = errNone;
-
-	species = (Species *)MemPtrNew(sizeof(Species));
-	ErrFatalDisplayIf ((!species), "Out of memory");
-	MemSet(species, sizeof(Species), 0);
-
-	for (i = 0; i < PKMN_QUANTITY; i++)
-	{
-		StrCopy(species->nameList[i].name, pkmnsNames[i].name);
-	}
-	
-	err = FtrSet(appFileCreator, ftrPkmnNamesNum, (UInt32)species);
-	ErrFatalDisplayIf (err != errNone, "Failed to set feature memory");
-}
-
-static void SetColorDepth()
-{
-	UInt32 depth;
-	UInt8 colorMode = 0;
-	Err error = WinScreenMode(winScreenModeGet, NULL, NULL, &depth, NULL);
-
-	ErrFatalDisplayIf(error != errNone, "WinScreenMode get error");
-
-	if(depth <= 4)
-	{
-		depth = 4;
-		error = WinScreenMode(winScreenModeSet, NULL, NULL, &depth, NULL);
-		ErrFatalDisplayIf(error != errNone, "As of now, Palmkedex does not support this device's screen.");
-	}
-}
-
-/*
- * FUNCTION: AppStart
- *
- * DESCRIPTION:  Get the current application's preferences.
- *
- * RETURNED:
- *     errNone - if nothing went wrong
- */
-
-static Err AppStart(void)
-{
-	LoadSpecies();
-	MakeSharedVariables();
-	SetColorDepth();
-
-	return errNone;
-}
-
-static void UnloadSpecies()
-{
-	FtrPtrFree(appFileCreator, ftrPkmnNamesNum);
-}
-
-static void FreeSharedVariables()
-{
-	UInt32 pstSharedInt;
-	SharedVariables *sharedVars;
-	Err err = errNone;
-
-	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
-	ErrFatalDisplayIf (err != errNone, "Failed to load feature memory");
-	sharedVars = (SharedVariables *)pstSharedInt;
-
-	if ((UInt32)sharedVars->filteredList != 0)
-	{
-		MemPtrFree(sharedVars->filteredList);
-	}
-
-	if ((UInt32)sharedVars->filteredPkmnNumbers != 0)
-	{
-		MemPtrFree(sharedVars->filteredPkmnNumbers);
-	}
-
-	if ((UInt32)sharedVars->pkmnFormTitle != 0)
-	{
-		MemPtrFree(sharedVars->pkmnFormTitle);
-	}
-	
-	FtrPtrFree(appFileCreator, ftrShrdVarsNum);
-}
-
-/*
- * FUNCTION: AppStop
- *
- * DESCRIPTION: Save the current state of the application.
- */
-
-static void AppStop(void)
-{
-    UnloadSpecies();
-	FreeSharedVariables();
-	/* Close all the open forms. */
-	FrmCloseAllForms();
-
-}
-
-/*
- * FUNCTION: RomVersionCompatible
- *
- * DESCRIPTION: 
- *
- * This routine checks that a ROM version is meet your minimum 
- * requirement.
- *
- * PARAMETERS:
- *
- * requiredVersion
- *     minimum rom version required
- *     (see sysFtrNumROMVersion in SystemMgr.h for format)
- *
- * launchFlags
- *     flags that indicate if the application UI is initialized
- *     These flags are one of the parameters to your app's PilotMain
- *
- * RETURNED:
- *     error code or zero if ROM version is compatible
- */
-
-static Err RomVersionCompatible(UInt32 requiredVersion, UInt16 launchFlags)
-{
-	UInt32 romVersion;
-
-	/* See if we're on in minimum required version of the ROM or later. */
-	FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion);
-	if (romVersion < requiredVersion)
-	{
-		if ((launchFlags & 
-			(sysAppLaunchFlagNewGlobals | sysAppLaunchFlagUIApp)) ==
-			(sysAppLaunchFlagNewGlobals | sysAppLaunchFlagUIApp))
-		{
-			FrmAlert (RomIncompatibleAlert);
-
-			/* Palm OS versions before 2.0 will continuously relaunch this
-			 * app unless we switch to another safe one. */
-			if (romVersion < kPalmOS20Version)
-			{
-				AppLaunchWithCommand(
-					sysFileCDefaultApp, 
-					sysAppLaunchCmdNormalLaunch, NULL);
-			}
-		}
-
-		return sysErrRomIncompatible;
-	}
-
-	return errNone;
-}
-
-static Err loadSonyHrLib(UInt16 *hrLibRefP)
-{
-	UInt32 val320 = 320;
-	UInt16 hrLibRef;
-	Err e;
-
-	e = SysLibFind(sonySysLibNameHR, &hrLibRef);
-	if (e == sysErrLibNotFound)
-		e = SysLibLoad(sysFileTLibrary, sonySysFileCHRLib, &hrLibRef);
-
-	if (e == errNone)
-		e = HROpen(hrLibRef);
-
-	if (e == errNone) {
-
-		e = HRWinScreenMode(hrLibRef, winScreenModeSet, &val320, &val320, NULL, NULL);
-		if (e != errNone) {
-
-			if (errNone == HRClose(hrLibRef))
-				SysLibRemove(hrLibRef);
-		}
-	}
-
-	*hrLibRefP = hrLibRef;
-
-	return e;
-}
-
-UInt32 PilotMain(UInt16 cmd, MemPtr cmdPBP, UInt16 launchFlags)
-{
-	Err error;
-
-	error = RomVersionCompatible (ourMinVersion, launchFlags);
-	if (error) return (error);
-
-	if (cmd == sysAppLaunchCmdNormalLaunch) {
-
-		UInt16 sonyHrLibRef;
-
-		error = AppStart();
-		if (error)
-			return error;
-
-		error = loadSonyHrLib(&sonyHrLibRef);
-		if (error)
-			sonyHrLibRef = 0xffff;
-
-		/*
-		 * start application by opening the main form
-		 * and then entering the main event loop
-		 */
-		FrmGotoForm(MainForm);
-		AppEventLoop();
-
-		if (sonyHrLibRef != 0xffff && errNone == HRClose(sonyHrLibRef))
-			SysLibRemove(sonyHrLibRef);
-
-		AppStop();
-	}
-
-	return errNone;
-}
-
-UInt32 __attribute__((section(".vectors"))) __Startup__(void)
-{
-	SysAppInfoPtr appInfoP;
-	void *prevGlobalsP;
-	void *globalsP;
-	UInt32 ret;
-
-	SysAppStartup(&appInfoP, &prevGlobalsP, &globalsP);
-	ret = PilotMain(appInfoP->cmd, appInfoP->cmdPBP, appInfoP->launchFlags);
-	SysAppExit(appInfoP, prevGlobalsP, globalsP);
-
-	return ret;
-}
-
+/*
+ * Palmkedex.c
+ *
+ * main file for Palmkedex
+ *
+ * This wizard-generated code is based on code adapted from the
+ * stationery files distributed as part of the Palm OS SDK 4.0.
+ *
+ * Copyright (c) 1999-2000 Palm, Inc. or its subsidiaries.
+ * All rights reserved.
+ */
+ 
+#include <PalmOS.h>
+#include <PalmOSGlue.h>
+#include <SonyCLIE.h>
+
+#include "Palmkedex.h"
+#include "Rsc/Palmkedex_Rsc.h"
+#include "Rsc/pkmn_names.h"
+
+/*********************************************************************
+ * Entry Points
+ *********************************************************************/
+
+/*********************************************************************
+ * Global variables
+ *********************************************************************/
+
+
+
+/*********************************************************************
+ * Internal Constants
+ *********************************************************************/
+
+/* Define the minimum OS version we support */
+#define ourMinVersion    sysMakeROMVersion(3,5,0,sysROMStageDevelopment,0)
+#define kPalmOS20Version sysMakeROMVersion(2,0,0,sysROMStageDevelopment,0)
+
+/*********************************************************************
+ * Internal Functions
+ *********************************************************************/
+
+/*
+ * FUNCTION: GetObjectPtr
+ *
+ * DESCRIPTION:
+ *
+ * This routine returns a pointer to an object in the current form.
+ *
+ * PARAMETERS:
+ *
+ * formId
+ *     id of the form to display
+ *
+ * RETURNED:
+ *     address of object as a void pointer
+ */
+
+void * GetObjectPtr(UInt16 objectID)
+{
+	FormType * frmP;
+
+	frmP = FrmGetActiveForm();
+	return FrmGetObjectPtr(frmP, FrmGetObjectIndex(frmP, objectID));
+}
+
+
+/*
+ * FUNCTION: AppHandleEvent
+ *
+ * DESCRIPTION: 
+ *
+ * This routine loads form resources and set the event handler for
+ * the form loaded.
+ *
+ * PARAMETERS:
+ *
+ * event
+ *     a pointer to an EventType structure
+ *
+ * RETURNED:
+ *     true if the event was handled and should not be passed
+ *     to a higher level handler.
+ */
+
+static Boolean AppHandleEvent(EventType * eventP)
+{
+	UInt16 formId;
+	FormType * frmP;
+
+	if (eventP->eType == frmLoadEvent)
+	{
+		/* Load the form resource. */
+		formId = eventP->data.frmLoad.formID;
+		frmP = FrmInitForm(formId);
+		FrmSetActiveForm(frmP);
+
+		/* 
+		 * Set the event handler for the form.  The handler of the
+		 * currently active form is called by FrmHandleEvent each
+		 * time is receives an event. 
+		 */
+		switch (formId)
+		{
+			case MainForm:
+				FrmSetEventHandler(frmP, MainFormHandleEvent);
+				break;
+			case PkmnMainForm:
+				FrmSetEventHandler(frmP, PkmnMainFormHandleEvent);
+				break;
+			case PkmnTypeForm:
+				FrmSetEventHandler(frmP, PkmnTypeFormHandleEvent);
+				break;
+		}
+		return true;
+	}
+
+	return false;
+}
+
+/*
+ * FUNCTION: AppEventLoop
+ *
+ * DESCRIPTION: This routine is the event loop for the application.
+ */
+
+static void AppEventLoop(void)
+{
+	UInt16 error;
+	EventType event;
+
+	do 
+	{
+		/* change timeout if you need periodic nilEvents */
+		EvtGetEvent(&event, evtWaitForever);
+
+		if (! SysHandleEvent(&event))
+		{
+			if (! MenuHandleEvent(0, &event, &error))
+			{
+				if (! AppHandleEvent(&event))
+				{
+					FrmDispatchEvent(&event);
+				}
+			}
+		}
+	} while (event.eType != appStopEvent);
+}
+
+
+static void MakeSharedVariables()
+{
+	SharedVariables *sharedVars;
+	Err err = errNone;
+
+	sharedVars = (SharedVariables *)MemPtrNew(sizeof(SharedVariables));
+	ErrFatalDisplayIf ((!sharedVars), "Out of memory");
+	MemSet(sharedVars, sizeof(SharedVariables), 0);
+
+	sharedVars->sizeAfterFiltering = PKMN_QUANTITY;
+
+	err = FtrSet(appFileCreator, ftrShrdVarsNum, (UInt32)sharedVars);
+	ErrFatalDisplayIf (err != errNone, "Failed to set feature memory");
+}
+
+static void LoadSpecies()
+{
+	Species *species;
+	UInt16 i;
+	Err err = errNone;
+
+	species = (Species *)MemPtrNew(sizeof(Species));
+	ErrFatalDisplayIf ((!species), "Out of memory");
+	MemSet(species, sizeof(Species), 0);
+
+	for (i = 0; i < PKMN_QUANTITY; i++)
+	{
+		StrCopy(species->nameList[i].name, pkmnsNames[i].name);
+	}
+	
+	err = FtrSet(appFileCreator, ftrPkmnNamesNum, (UInt32)species);
+	ErrFatalDisplayIf (err != errNone, "Failed to set feature memory");
+}
+
+static Err SetColorDepth(void)
+{
+	UInt32 supportedDepths, desiredDepth = 8;
+	Err err;
+	
+	err = WinScreenMode(winScreenModeGetSupportedDepths, NULL, NULL, &supportedDepths, NULL);
+	if (err)
+		return err;
+	
+	//set highest available color depth, but not more than 8
+	while (desiredDepth) {
+		
+		UInt32 desiredDepthMask = (1UL << (desiredDepth - 1));
+		
+		if (supportedDepths & desiredDepthMask)
+			return WinScreenMode(winScreenModeSet, NULL, NULL, &desiredDepth, NULL);
+		
+		desiredDepth >>= 1;
+	}
+	
+	SysFatalAlert("As of now, Palmkedex does not support this device's screen.");
+	
+	return errNone;
+}
+
+/*
+ * FUNCTION: AppStart
+ *
+ * DESCRIPTION:  Get the current application's preferences.
+ *
+ * RETURNED:
+ *     errNone - if nothing went wrong
+ */
+
+static Err AppStart(void)
+{
+	LoadSpecies();
+	MakeSharedVariables();
+	SetColorDepth();
+
+	return errNone;
+}
+
+static void UnloadSpecies()
+{
+	FtrPtrFree(appFileCreator, ftrPkmnNamesNum);
+}
+
+static void FreeSharedVariables()
+{
+	UInt32 pstSharedInt;
+	SharedVariables *sharedVars;
+	Err err = errNone;
+
+	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
+	ErrFatalDisplayIf (err != errNone, "Failed to load feature memory");
+	sharedVars = (SharedVariables *)pstSharedInt;
+
+	if ((UInt32)sharedVars->filteredList != 0)
+	{
+		MemPtrFree(sharedVars->filteredList);
+	}
+
+	if ((UInt32)sharedVars->filteredPkmnNumbers != 0)
+	{
+		MemPtrFree(sharedVars->filteredPkmnNumbers);
+	}
+
+	if ((UInt32)sharedVars->pkmnFormTitle != 0)
+	{
+		MemPtrFree(sharedVars->pkmnFormTitle);
+	}
+	
+	FtrPtrFree(appFileCreator, ftrShrdVarsNum);
+}
+
+/*
+ * FUNCTION: AppStop
+ *
+ * DESCRIPTION: Save the current state of the application.
+ */
+
+static void AppStop(void)
+{
+    UnloadSpecies();
+	FreeSharedVariables();
+	/* Close all the open forms. */
+	FrmCloseAllForms();
+
+}
+
+/*
+ * FUNCTION: RomVersionCompatible
+ *
+ * DESCRIPTION: 
+ *
+ * This routine checks that a ROM version is meet your minimum 
+ * requirement.
+ *
+ * PARAMETERS:
+ *
+ * requiredVersion
+ *     minimum rom version required
+ *     (see sysFtrNumROMVersion in SystemMgr.h for format)
+ *
+ * launchFlags
+ *     flags that indicate if the application UI is initialized
+ *     These flags are one of the parameters to your app's PilotMain
+ *
+ * RETURNED:
+ *     error code or zero if ROM version is compatible
+ */
+
+static Err RomVersionCompatible(UInt32 requiredVersion, UInt16 launchFlags)
+{
+	UInt32 romVersion;
+
+	/* See if we're on in minimum required version of the ROM or later. */
+	FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion);
+	if (romVersion < requiredVersion)
+	{
+		if ((launchFlags & 
+			(sysAppLaunchFlagNewGlobals | sysAppLaunchFlagUIApp)) ==
+			(sysAppLaunchFlagNewGlobals | sysAppLaunchFlagUIApp))
+		{
+			FrmAlert (RomIncompatibleAlert);
+
+			/* Palm OS versions before 2.0 will continuously relaunch this
+			 * app unless we switch to another safe one. */
+			if (romVersion < kPalmOS20Version)
+			{
+				AppLaunchWithCommand(
+					sysFileCDefaultApp, 
+					sysAppLaunchCmdNormalLaunch, NULL);
+			}
+		}
+
+		return sysErrRomIncompatible;
+	}
+
+	return errNone;
+}
+
+static Err loadSonyHrLib(UInt16 *hrLibRefP)
+{
+	UInt32 val320 = 320;
+	UInt16 hrLibRef;
+	Err e;
+			
+	e = SysLibFind(sonySysLibNameHR, &hrLibRef);
+	if (e == sysErrLibNotFound)
+		e = SysLibLoad(sysFileTLibrary, sonySysFileCHRLib, &hrLibRef);
+	
+	if (e == errNone)
+		e = HROpen(hrLibRef);
+	
+	if (e == errNone) {
+		
+		e = HRWinScreenMode(hrLibRef, winScreenModeSet, &val320, &val320, NULL, NULL);
+		if (e != errNone) {
+			
+			if (errNone == HRClose(hrLibRef))
+				SysLibRemove(hrLibRef);
+		}
+	}
+	
+	*hrLibRefP = hrLibRef;
+	
+	return e;
+}
+
+UInt32 PilotMain(UInt16 cmd, MemPtr cmdPBP, UInt16 launchFlags)
+{
+	Err error;
+
+	error = RomVersionCompatible (ourMinVersion, launchFlags);
+	if (error) return (error);
+
+	if (cmd == sysAppLaunchCmdNormalLaunch) {
+		
+		UInt16 sonyHrLibRef;
+		
+		error = AppStart();
+		if (error) 
+			return error;
+
+		error = loadSonyHrLib(&sonyHrLibRef);
+		if (error)
+			sonyHrLibRef = 0xffff;
+
+		/* 
+		 * start application by opening the main form
+		 * and then entering the main event loop 
+		 */
+		FrmGotoForm(MainForm);
+		AppEventLoop();
+
+		if (sonyHrLibRef != 0xffff && errNone == HRClose(sonyHrLibRef))
+			SysLibRemove(sonyHrLibRef);
+
+		AppStop();
+	}
+
+	return errNone;
+}
+
+UInt32 __attribute__((section(".vectors"))) __Startup__(void)
+{
+	SysAppInfoPtr appInfoP;
+	void *prevGlobalsP;
+	void *globalsP;
+	UInt32 ret;
+
+	SysAppStartup(&appInfoP, &prevGlobalsP, &globalsP);
+	ret = PilotMain(appInfoP->cmd, appInfoP->cmdPBP, appInfoP->launchFlags);
+	SysAppExit(appInfoP, prevGlobalsP, globalsP);
+
+	return ret;
+}
+
diff --git a/Src/Palmkedex.h b/Src/Palmkedex.h
index 99cf40a..c2c47eb 100644
--- a/Src/Palmkedex.h
+++ b/Src/Palmkedex.h
@@ -1,85 +1,85 @@
-/*
- * Palmkedex.h
- *
- * header file for Palmkedex
- *
- */
-
-#ifndef PALMKEDEX_H_
-#define PALMKEDEX_H_
-
-/*********************************************************************
- * Internal Constants
- *********************************************************************/
-
-#define appFileCreator 'PKDX'
-#define appName "Pokedex"
-#define appVersionNum 0x01
-#define appPrefID 0x00
-#define appPrefVersionNum 0x01
-
-#define ftrPkmnNamesNum (UInt16)1
-#define ftrShrdVarsNum (UInt16)2
-
-#define PKMN_QUANTITY    905
-#define UNKNOWN_TYPE     21
-
-#define QUADRUPLE_DAMAGE 400
-#define DOUBLE_DAMAGE    200
-#define HALF_DAMAGE      50
-#define QUARTER_DAMAGE   25
-#define NO_DAMAGE        0
-
-#define BACKSPACE_CHAR 8
-#define MAX_PKMN_NAME_LEN 11
-#define MAX_SEARCH_RESULT_LEN 14
-#define MAX_SEARCH_STR "...        "
-#define MAX_SEARCH_PKMN_NUM 0
-
-
-typedef struct SpeciesNames
-{
-    Char name[12];
-} SpeciesNames;
-
-typedef struct Species
-{
-    SpeciesNames nameList[PKMN_QUANTITY];
-} Species;
-
-typedef struct SharedVariables
-{
-    UInt16 selectedPkmnId;
-    Char nameFilter[12];   // The current filter
-    Int16 sizeAfterFiltering;
-    SpeciesNames *filteredList;
-    UInt16 *filteredPkmnNumbers;
-    Char *pkmnFormTitle;
-    Char pkmnLstNumStr[5];
-    Char pkmnLstNameStr[12];
-} SharedVariables;
-
-// Palmkedex.c
-void *GetObjectPtr(UInt16 objectID);
-
-// Main.c
-Boolean MainFormHandleEvent(EventType *eventP);
-Boolean PkmnMainFormHandleEvent(EventType *eventP);
-void OpenAboutDialog();
-void OpenMainPkmnForm(Int16 selection);
-void subString(const Char *input, int offset, int len, Char *dest);
-Int16 GetCurrentListSize();
-UInt16 GetPkmnId(Int16 selection);
-
-// PkmnMain.c
-Boolean PkmnMainFormHandleEvent(EventType *eventP);
-void LoadPkmnStats();
-void SetFormTitle(SharedVariables *sharedVars);
-void SetLabelInfo(UInt16 labelId, UInt8 stat, FormType *frm);
-void DrawTypes(UInt8 *pkmnBytes);
-void SetDescriptionField(UInt16 selectedPkmnId);
-
-// PkmnType.c
-Boolean PkmnTypeFormHandleEvent(EventType *eventP);
-
+/*
+ * Palmkedex.h
+ *
+ * header file for Palmkedex
+ *
+ */
+
+#ifndef PALMKEDEX_H_
+#define PALMKEDEX_H_
+
+/*********************************************************************
+ * Internal Constants
+ *********************************************************************/
+
+#define appFileCreator 'PKDX'
+#define appName "Pokedex"
+#define appVersionNum 0x01
+#define appPrefID 0x00
+#define appPrefVersionNum 0x01
+
+#define ftrPkmnNamesNum (UInt16)1
+#define ftrShrdVarsNum (UInt16)2
+
+#define PKMN_QUANTITY    905
+#define UNKNOWN_TYPE     21
+
+#define QUADRUPLE_DAMAGE 400
+#define DOUBLE_DAMAGE    200
+#define HALF_DAMAGE      50
+#define QUARTER_DAMAGE   25
+#define NO_DAMAGE        0
+
+#define BACKSPACE_CHAR 8
+#define MAX_PKMN_NAME_LEN 11
+#define MAX_SEARCH_RESULT_LEN 14
+#define MAX_SEARCH_STR "...        "
+#define MAX_SEARCH_PKMN_NUM 0
+
+
+typedef struct SpeciesNames
+{
+    Char name[12];
+} SpeciesNames;
+
+typedef struct Species
+{
+    SpeciesNames nameList[PKMN_QUANTITY];
+} Species;
+
+typedef struct SharedVariables
+{
+    UInt16 selectedPkmnId;
+    Char nameFilter[12];   // The current filter
+    Int16 sizeAfterFiltering;
+    SpeciesNames *filteredList;
+    UInt16 *filteredPkmnNumbers;
+    Char *pkmnFormTitle;
+    Char pkmnLstNumStr[5];
+    Char pkmnLstNameStr[12];
+} SharedVariables;
+
+// Palmkedex.c
+void *GetObjectPtr(UInt16 objectID);
+
+// Main.c
+Boolean MainFormHandleEvent(EventType *eventP);
+Boolean PkmnMainFormHandleEvent(EventType *eventP);
+void OpenAboutDialog();
+void OpenMainPkmnForm(Int16 selection);
+void subString(const Char *input, int offset, int len, Char *dest);
+Int16 GetCurrentListSize();
+UInt16 GetPkmnId(Int16 selection);
+
+// PkmnMain.c
+Boolean PkmnMainFormHandleEvent(EventType *eventP);
+void LoadPkmnStats();
+void SetFormTitle(SharedVariables *sharedVars);
+void SetLabelInfo(UInt16 labelId, UInt8 stat, FormType *frm);
+void DrawTypes(UInt8 *pkmnBytes);
+void SetDescriptionField(UInt16 selectedPkmnId);
+
+// PkmnType.c
+Boolean PkmnTypeFormHandleEvent(EventType *eventP);
+
 #endif /* PALMKEDEX_H_ */
\ No newline at end of file
diff --git a/Src/PkmnMain.c b/Src/PkmnMain.c
index a530c2c..a7059be 100644
--- a/Src/PkmnMain.c
+++ b/Src/PkmnMain.c
@@ -1,371 +1,371 @@
-#include <PalmOS.h>
-
-#include "Palmkedex.h"
-#include "Rsc/Palmkedex_Rsc.h"
-#include "Src/pngDraw.h"
-
-void DrawPkmnPlaceholder()
-{
-	MemHandle h;
-	BitmapPtr bitmapP;
-	h = DmGetResource('pSPN', 0);
-
-	bitmapP = (BitmapPtr)MemHandleLock(h);
-	ErrFatalDisplayIf(!bitmapP, "Failed to lock placeholder bmp");
-
-	WinDrawBitmap(bitmapP, 1, 16);
-	MemPtrUnlock(bitmapP);
-	DmReleaseResource(h);
-}
-
-void DrawPkmnSprite(UInt16 selectedPkmnId)
-{
-	MemHandle pngMemHandle;
-	DmOpenRef dbRef;
-	MemPtr pngData;
-	UInt32 size;
-	int ret;
-	BitmapType *bmpP;
-	WinHandle win;
-	Err error;
-	struct DrawState *ds;
-
-	// Check if the PNG for the current pkmn
-	// is already decoded in memory
-	error = FtrGet(appFileCreator, 0, (UInt32*)&ds);
-	if (error == errNone)
-	{
-		// If it is, draw it and return
-		pngDrawRedraw(ds, 1, 16);
-		return;
-	}
-
-	// Check if there is any PNG for current pkmn
-	dbRef = DmOpenDatabaseByTypeCreator('pSPR', 'PKSP', dmModeReadOnly);
-	pngMemHandle = DmGet1Resource('pSPT', selectedPkmnId);
-	if (!pngMemHandle)
-	{
-		// If there isnt, draw the placeholder and return
-		DrawPkmnPlaceholder();
-		if (dbRef)
-		{
-			DmCloseDatabase(dbRef);
-		}
-		return;
-	}
-
-	pngDrawAt(&ds, MemHandleLock(pngMemHandle), MemHandleSize(pngMemHandle), 1, 16, 64, 64);
-
-	DmReleaseResource(pngMemHandle);
-	if (dbRef)
-	{
-		DmCloseDatabase(dbRef);
-	}
-	// And store its pointer to quickly redraw it
-	FtrSet(appFileCreator, 0, (UInt32)ds);
-}
-
-void LoadPkmnStats()
-{
-	UInt32 pstSharedInt;
-	SharedVariables *sharedVars;
-	UInt8 *pkmnBytes;
-	MemHandle hndl;
-	FormType *frm;
-	ListType *list;
-	Err err = errNone;
-
-	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
-	ErrFatalDisplayIf(err != errNone, "Failed to load feature memory");
-	sharedVars = (SharedVariables *)pstSharedInt;
-
-	hndl = DmGetResource('pINF', sharedVars->selectedPkmnId);
-	pkmnBytes = MemHandleLock(hndl);
-	frm = FrmGetActiveForm();
-
-	SetLabelInfo(PkmnMainHPValueLabel, pkmnBytes[0], frm);
-	SetLabelInfo(PkmnMainAtkValueLabel, pkmnBytes[1], frm);
-	SetLabelInfo(PkmnMainDefValueLabel, pkmnBytes[2], frm);
-	SetLabelInfo(PkmnMainSPAtkValueLabel, pkmnBytes[3], frm);
-	SetLabelInfo(PkmnMainSPDefValueLabel, pkmnBytes[4], frm);
-	SetLabelInfo(PkmnMainSpeedValueLabel, pkmnBytes[5], frm);
-	DrawTypes(pkmnBytes);
-
-	MemHandleUnlock(hndl);
-
-	list = GetObjectPtr(PkmnMainPopUpList);
-	LstSetSelection(list, 0);
-
-	SetDescriptionField(sharedVars->selectedPkmnId);
-	DrawPkmnSprite(sharedVars->selectedPkmnId);
-
-	SetFormTitle(sharedVars);
-}
-
-void SetDescriptionField(UInt16 selectedPkmnId)
-{
-	UInt16 scrollPos;
-	UInt16 textHeight;
-	UInt16 fieldHeight;
-	Int16 maxValue;
-	ScrollBarPtr bar;
-	MemHandle hndl = DmGet1Resource('pDSC', selectedPkmnId);
-	Char *pkmnDesc = MemHandleLock(hndl);
-	FieldType *fld = GetObjectPtr(PkmnMainDescField);
-
-	FldSetTextPtr(fld, pkmnDesc);
-	FldRecalculateField(fld, true);
-
-	MemHandleUnlock(hndl);
-
-	bar = GetObjectPtr(PkmnMainDescScroll);
-
-	FldGetScrollValues(fld, &scrollPos, &textHeight, &fieldHeight);
-
-	if (textHeight > fieldHeight)
-		maxValue = textHeight - fieldHeight;
-	else if (scrollPos)
-		maxValue = scrollPos;
-	else
-		maxValue = 0;
-
-	SclSetScrollBar(bar, scrollPos, 0, maxValue, fieldHeight - 1);
-}
-
-void DrawTypes(UInt8 *pkmnBytes)
-{
-	MemHandle h;
-	BitmapPtr bitmapP;
-
-	h = DmGetResource('pTYP', pkmnBytes[6]);
-	ErrFatalDisplayIf(!h, "Failed to load type bmp");
-
-	bitmapP = (BitmapPtr)MemHandleLock(h);
-	ErrFatalDisplayIf(!bitmapP, "Failed to lock type bmp");
-
-	WinDrawBitmap(bitmapP, 1, 82);
-	MemPtrUnlock(bitmapP);
-	DmReleaseResource(h);
-
-	if (pkmnBytes[7] != 21)
-	{
-		h = DmGetResource('pTYP', pkmnBytes[7]);
-		ErrFatalDisplayIf(!h, "Failed to load type bmp");
-
-		bitmapP = (BitmapPtr)MemHandleLock(h);
-		ErrFatalDisplayIf(!bitmapP, "Failed to lock type bmp");
-
-		WinDrawBitmap(bitmapP, 34, 82);
-		MemPtrUnlock(bitmapP);
-		DmReleaseResource(h);
-	}
-}
-
-void SetLabelInfo(UInt16 labelId, UInt8 stat, FormType *frm)
-{
-	Char *str;
-
-	str = (Char *)MemPtrNew(sizeof(Char[4]));
-	if ((UInt32)str == 0)
-		return;
-	MemSet(str, sizeof(Char[4]), 0);
-
-	StrIToA(str, stat);
-	FrmCopyLabel(frm, labelId, str);
-
-	MemPtrFree(str);
-}
-
-void SetFormTitle(SharedVariables *sharedVars)
-{
-	UInt32 pstSpeciesInt;
-	Species *species;
-	Char *numStr;
-	Err err = errNone;
-
-	err = FtrGet(appFileCreator, ftrPkmnNamesNum, &pstSpeciesInt);
-	ErrFatalDisplayIf(err != errNone, "Failed to load feature memory");
-	species = (Species *)pstSpeciesInt;
-
-	if ((UInt32)sharedVars->pkmnFormTitle != 0)
-	{
-		MemPtrFree(sharedVars->pkmnFormTitle);
-	}
-
-	sharedVars->pkmnFormTitle = (Char *)MemPtrNew(sizeof(Char[18]));
-	if ((UInt32)sharedVars->pkmnFormTitle == 0)
-		return;
-	MemSet(sharedVars->pkmnFormTitle, sizeof(Char[18]), 0);
-
-	numStr = (Char *)MemPtrNew(sizeof(Char[5]));
-	if ((UInt32)numStr == 0)
-		return;
-	MemSet(numStr, sizeof(Char[5]), 0);
-
-	StrCopy(sharedVars->pkmnFormTitle, species->nameList[sharedVars->selectedPkmnId - 1].name);
-	StrCat(sharedVars->pkmnFormTitle, " #");
-	StrIToA(numStr, sharedVars->selectedPkmnId);
-	StrCat(sharedVars->pkmnFormTitle, numStr);
-
-	FrmSetTitle(FrmGetActiveForm(), sharedVars->pkmnFormTitle);
-
-	MemPtrFree(numStr);
-}
-
-static void PkmnDescriptionScroll(WinDirectionType direction)
-{
-	Int16 value;
-	Int16 min;
-	Int16 max;
-	Int16 pageSize;
-	UInt16 linesToScroll;
-	FieldPtr fld;
-	ScrollBarPtr bar;
-
-	fld = GetObjectPtr(PkmnMainDescField);
-
-	if (FldScrollable(fld, direction))
-	{
-		linesToScroll = FldGetVisibleLines(fld) - 1;
-		FldScrollField(fld, linesToScroll, direction);
-
-		// Update the scroll bar.
-		bar = GetObjectPtr(PkmnMainDescScroll);
-		SclGetScrollBar(bar, &value, &min, &max, &pageSize);
-
-		if (direction == winUp)
-			value -= linesToScroll;
-		else
-			value += linesToScroll;
-
-		SclSetScrollBar(bar, value, min, max, pageSize);
-	}
-}
-
-static void PkmnDescriptionSimpleScroll(Int16 linesToScroll)
-{
-	FieldPtr fld;
-
-	fld = GetObjectPtr(PkmnMainDescField);
-
-	if (linesToScroll < 0)
-		FldScrollField(fld, -linesToScroll, winUp);
-
-	else if (linesToScroll > 0)
-		FldScrollField(fld, linesToScroll, winDown);
-}
-
-static void unregisterCurrentPng()
-{
-	struct DrawState *ds;
-
-	FtrGet(appFileCreator, 0, (UInt32*)&ds);
-	if (ds)
-	{
-		pngDrawStateFree(ds);
-		FtrUnregister(appFileCreator, 0);
-	}
-}
-
-/*
- * FUNCTION: PkmnMainFormDoCommand
- *
- * DESCRIPTION: This routine performs the menu command specified.
- *
- * PARAMETERS:
- *
- * command
- *     menu item id
- */
-
-static Boolean PkmnMainFormDoCommand(UInt16 command)
-{
-	Boolean handled = false;
-
-	switch (command)
-	{
-	case PkmnMainBackButton:
-	{
-		FrmGotoForm(MainForm);
-		handled = true;
-		break;
-	}
-
-	default:
-		break;
-	}
-
-	return handled;
-}
-
-/*
- * FUNCTION: PkmnMainFormHandleEvent
- *
- * DESCRIPTION:
- *
- * This routine is the event handler for the "PkmnMainForm" of this
- * application.
- *
- * PARAMETERS:
- *
- * eventP
- *     a pointer to an EventType structure
- *
- * RETURNED:
- *     true if the event was handled and should not be passed to
- *     FrmHandleEvent
- */
-
-Boolean PkmnMainFormHandleEvent(EventType *eventP)
-{
-	Boolean handled = false;
-	FormType *frmP;
-
-	switch (eventP->eType)
-	{
-	case ctlSelectEvent:
-		return PkmnMainFormDoCommand(eventP->data.menu.itemID);
-
-	case frmOpenEvent:
-		frmP = FrmGetActiveForm();
-		FrmDrawForm(frmP);
-		LoadPkmnStats();
-		handled = true;
-		break;
-
-	case keyDownEvent:
-		if (eventP->data.keyDown.chr == vchrPageUp)
-		{
-			PkmnDescriptionScroll(winUp);
-			handled = true;
-		}
-		else if (eventP->data.keyDown.chr == vchrPageDown)
-		{
-			PkmnDescriptionScroll(winDown);
-			handled = true;
-		}
-		break;
-
-	case sclRepeatEvent:
-		PkmnDescriptionSimpleScroll(eventP->data.sclRepeat.newValue -
-									eventP->data.sclRepeat.value);
-		break;
-
-	case popSelectEvent:
-		if (eventP->data.popSelect.selection == 1)
-		{
-			FrmGotoForm(PkmnTypeForm);
-		}
-		break;
-
-	case frmCloseEvent:
-		//no matter why we're closing, free the bitmap
-		unregisterCurrentPng();
-		break;
-
-	default:
-		break;
-	}
-
-	return handled;
-}
+#include <PalmOS.h>
+
+#include "Palmkedex.h"
+#include "Rsc/Palmkedex_Rsc.h"
+#include "Src/imgDraw.h"
+
+void DrawPkmnPlaceholder()
+{
+	MemHandle h;
+	BitmapPtr bitmapP;
+	h = DmGetResource('pSPN', 0);
+
+	bitmapP = (BitmapPtr)MemHandleLock(h);
+	ErrFatalDisplayIf(!bitmapP, "Failed to lock placeholder bmp");
+
+	WinDrawBitmap(bitmapP, 1, 16);
+	MemPtrUnlock(bitmapP);
+	DmReleaseResource(h);
+}
+
+void DrawPkmnSprite(UInt16 selectedPkmnId)
+{
+	MemHandle imgMemHandle;
+	DmOpenRef dbRef;
+	MemPtr pngData;
+	UInt32 size;
+	int ret;
+	BitmapType *bmpP;
+	WinHandle win;
+	Err error;
+	struct DrawState *ds;
+
+	// Check if the PNG for the current pkmn
+	// is already decoded in memory
+	error = FtrGet(appFileCreator, 0, (UInt32*)&ds);
+	if (error == errNone)
+	{
+		// If it is, draw it and return
+		imgDrawRedraw(ds, 1, 16);
+		return;
+	}
+
+	// Check if there is any PNG for current pkmn
+	dbRef = DmOpenDatabaseByTypeCreator('pSPR', 'PKSP', dmModeReadOnly);
+	imgMemHandle = DmGet1Resource('pSPT', selectedPkmnId);
+	if (!imgMemHandle)
+	{
+		// If there isnt, draw the placeholder and return
+		DrawPkmnPlaceholder();
+		if (dbRef)
+		{
+			DmCloseDatabase(dbRef);
+		}
+		return;
+	}
+	
+	imgDrawAt(&ds, MemHandleLock(imgMemHandle), MemHandleSize(imgMemHandle), 1, 16, 64, 64); 
+	MemHandleUnlock(imgMemHandle);
+	DmReleaseResource(imgMemHandle);
+	if (dbRef)
+	{
+		DmCloseDatabase(dbRef);
+	}
+	// And store its pointer to quickly redraw it
+	FtrSet(appFileCreator, 0, (UInt32)ds);
+}
+
+void LoadPkmnStats()
+{
+	UInt32 pstSharedInt;
+	SharedVariables *sharedVars;
+	UInt8 *pkmnBytes;
+	MemHandle hndl;
+	FormType *frm;
+	ListType *list;
+	Err err = errNone;
+
+	err = FtrGet(appFileCreator, ftrShrdVarsNum, &pstSharedInt);
+	ErrFatalDisplayIf(err != errNone, "Failed to load feature memory");
+	sharedVars = (SharedVariables *)pstSharedInt;
+
+	hndl = DmGetResource('pINF', sharedVars->selectedPkmnId);
+	pkmnBytes = MemHandleLock(hndl);
+	frm = FrmGetActiveForm();
+
+	SetLabelInfo(PkmnMainHPValueLabel, pkmnBytes[0], frm);
+	SetLabelInfo(PkmnMainAtkValueLabel, pkmnBytes[1], frm);
+	SetLabelInfo(PkmnMainDefValueLabel, pkmnBytes[2], frm);
+	SetLabelInfo(PkmnMainSPAtkValueLabel, pkmnBytes[3], frm);
+	SetLabelInfo(PkmnMainSPDefValueLabel, pkmnBytes[4], frm);
+	SetLabelInfo(PkmnMainSpeedValueLabel, pkmnBytes[5], frm);
+	DrawTypes(pkmnBytes);
+
+	MemHandleUnlock(hndl);
+
+	list = GetObjectPtr(PkmnMainPopUpList);
+	LstSetSelection(list, 0);
+
+	SetDescriptionField(sharedVars->selectedPkmnId);
+	DrawPkmnSprite(sharedVars->selectedPkmnId);
+
+	SetFormTitle(sharedVars);
+}
+
+void SetDescriptionField(UInt16 selectedPkmnId)
+{
+	UInt16 scrollPos;
+	UInt16 textHeight;
+	UInt16 fieldHeight;
+	Int16 maxValue;
+	ScrollBarPtr bar;
+	MemHandle hndl = DmGet1Resource('pDSC', selectedPkmnId);
+	Char *pkmnDesc = MemHandleLock(hndl);
+	FieldType *fld = GetObjectPtr(PkmnMainDescField);
+
+	FldSetTextPtr(fld, pkmnDesc);
+	FldRecalculateField(fld, true);
+
+	MemHandleUnlock(hndl);
+
+	bar = GetObjectPtr(PkmnMainDescScroll);
+
+	FldGetScrollValues(fld, &scrollPos, &textHeight, &fieldHeight);
+
+	if (textHeight > fieldHeight)
+		maxValue = textHeight - fieldHeight;
+	else if (scrollPos)
+		maxValue = scrollPos;
+	else
+		maxValue = 0;
+
+	SclSetScrollBar(bar, scrollPos, 0, maxValue, fieldHeight - 1);
+}
+
+void DrawTypes(UInt8 *pkmnBytes)
+{
+	MemHandle h;
+	BitmapPtr bitmapP;
+
+	h = DmGetResource('pTYP', pkmnBytes[6]);
+	ErrFatalDisplayIf(!h, "Failed to load type bmp");
+
+	bitmapP = (BitmapPtr)MemHandleLock(h);
+	ErrFatalDisplayIf(!bitmapP, "Failed to lock type bmp");
+
+	WinDrawBitmap(bitmapP, 1, 82);
+	MemPtrUnlock(bitmapP);
+	DmReleaseResource(h);
+
+	if (pkmnBytes[7] != 21)
+	{
+		h = DmGetResource('pTYP', pkmnBytes[7]);
+		ErrFatalDisplayIf(!h, "Failed to load type bmp");
+
+		bitmapP = (BitmapPtr)MemHandleLock(h);
+		ErrFatalDisplayIf(!bitmapP, "Failed to lock type bmp");
+
+		WinDrawBitmap(bitmapP, 34, 82);
+		MemPtrUnlock(bitmapP);
+		DmReleaseResource(h);
+	}
+}
+
+void SetLabelInfo(UInt16 labelId, UInt8 stat, FormType *frm)
+{
+	Char *str;
+
+	str = (Char *)MemPtrNew(sizeof(Char[4]));
+	if ((UInt32)str == 0)
+		return;
+	MemSet(str, sizeof(Char[4]), 0);
+
+	StrIToA(str, stat);
+	FrmCopyLabel(frm, labelId, str);
+
+	MemPtrFree(str);
+}
+
+void SetFormTitle(SharedVariables *sharedVars)
+{
+	UInt32 pstSpeciesInt;
+	Species *species;
+	Char *numStr;
+	Err err = errNone;
+
+	err = FtrGet(appFileCreator, ftrPkmnNamesNum, &pstSpeciesInt);
+	ErrFatalDisplayIf(err != errNone, "Failed to load feature memory");
+	species = (Species *)pstSpeciesInt;
+
+	if ((UInt32)sharedVars->pkmnFormTitle != 0)
+	{
+		MemPtrFree(sharedVars->pkmnFormTitle);
+	}
+
+	sharedVars->pkmnFormTitle = (Char *)MemPtrNew(sizeof(Char[18]));
+	if ((UInt32)sharedVars->pkmnFormTitle == 0)
+		return;
+	MemSet(sharedVars->pkmnFormTitle, sizeof(Char[18]), 0);
+
+	numStr = (Char *)MemPtrNew(sizeof(Char[5]));
+	if ((UInt32)numStr == 0)
+		return;
+	MemSet(numStr, sizeof(Char[5]), 0);
+
+	StrCopy(sharedVars->pkmnFormTitle, species->nameList[sharedVars->selectedPkmnId - 1].name);
+	StrCat(sharedVars->pkmnFormTitle, " #");
+	StrIToA(numStr, sharedVars->selectedPkmnId);
+	StrCat(sharedVars->pkmnFormTitle, numStr);
+
+	FrmSetTitle(FrmGetActiveForm(), sharedVars->pkmnFormTitle);
+
+	MemPtrFree(numStr);
+}
+
+static void PkmnDescriptionScroll(WinDirectionType direction)
+{
+	Int16 value;
+	Int16 min;
+	Int16 max;
+	Int16 pageSize;
+	UInt16 linesToScroll;
+	FieldPtr fld;
+	ScrollBarPtr bar;
+
+	fld = GetObjectPtr(PkmnMainDescField);
+
+	if (FldScrollable(fld, direction))
+	{
+		linesToScroll = FldGetVisibleLines(fld) - 1;
+		FldScrollField(fld, linesToScroll, direction);
+
+		// Update the scroll bar.
+		bar = GetObjectPtr(PkmnMainDescScroll);
+		SclGetScrollBar(bar, &value, &min, &max, &pageSize);
+
+		if (direction == winUp)
+			value -= linesToScroll;
+		else
+			value += linesToScroll;
+
+		SclSetScrollBar(bar, value, min, max, pageSize);
+	}
+}
+
+static void PkmnDescriptionSimpleScroll(Int16 linesToScroll)
+{
+	FieldPtr fld;
+
+	fld = GetObjectPtr(PkmnMainDescField);
+
+	if (linesToScroll < 0)
+		FldScrollField(fld, -linesToScroll, winUp);
+
+	else if (linesToScroll > 0)
+		FldScrollField(fld, linesToScroll, winDown);
+}
+
+static void unregisterCurrentPng()
+{
+	struct DrawState *ds;
+	
+	FtrGet(appFileCreator, 0, (UInt32*)&ds);
+	if (ds)
+	{
+		imgDrawStateFree(ds);
+		FtrUnregister(appFileCreator, 0);
+	}
+}
+
+/*
+ * FUNCTION: PkmnMainFormDoCommand
+ *
+ * DESCRIPTION: This routine performs the menu command specified.
+ *
+ * PARAMETERS:
+ *
+ * command
+ *     menu item id
+ */
+
+static Boolean PkmnMainFormDoCommand(UInt16 command)
+{
+	Boolean handled = false;
+
+	switch (command)
+	{
+	case PkmnMainBackButton:
+	{
+		FrmGotoForm(MainForm);
+		handled = true;
+		break;
+	}
+
+	default:
+		break;
+	}
+
+	return handled;
+}
+
+/*
+ * FUNCTION: PkmnMainFormHandleEvent
+ *
+ * DESCRIPTION:
+ *
+ * This routine is the event handler for the "PkmnMainForm" of this
+ * application.
+ *
+ * PARAMETERS:
+ *
+ * eventP
+ *     a pointer to an EventType structure
+ *
+ * RETURNED:
+ *     true if the event was handled and should not be passed to
+ *     FrmHandleEvent
+ */
+
+Boolean PkmnMainFormHandleEvent(EventType *eventP)
+{
+	Boolean handled = false;
+	FormType *frmP;
+
+	switch (eventP->eType)
+	{
+	case ctlSelectEvent:
+		return PkmnMainFormDoCommand(eventP->data.menu.itemID);
+
+	case frmOpenEvent:
+		frmP = FrmGetActiveForm();
+		FrmDrawForm(frmP);
+		LoadPkmnStats();
+		handled = true;
+		break;
+
+	case keyDownEvent:
+		if (eventP->data.keyDown.chr == vchrPageUp)
+		{
+			PkmnDescriptionScroll(winUp);
+			handled = true;
+		}
+		else if (eventP->data.keyDown.chr == vchrPageDown)
+		{
+			PkmnDescriptionScroll(winDown);
+			handled = true;
+		}
+		break;
+
+	case sclRepeatEvent:
+		PkmnDescriptionSimpleScroll(eventP->data.sclRepeat.newValue -
+									eventP->data.sclRepeat.value);
+		break;
+
+	case popSelectEvent:
+		if (eventP->data.popSelect.selection == 1)
+		{
+			FrmGotoForm(PkmnTypeForm);
+		}
+		break;
+
+	case frmCloseEvent:
+		//no matter why we're closing, free the bitmap
+		unregisterCurrentPng();
+		break;
+
+	default:
+		break;
+	}
+
+	return handled;
+}
diff --git a/Src/aciDecode.c b/Src/aciDecode.c
new file mode 100644
index 0000000..eb78049
--- /dev/null
+++ b/Src/aciDecode.c
@@ -0,0 +1,98 @@
+#include <stdlib.h>
+#include "imgDrawInt.h"
+#include "aciDecode.h"
+
+
+#define FLAGS_V1			0x01		//must be set for this v1 format, if clear, format differs
+#define FLAGS_HAS_CLUT		0x02		//if no, assume greyscale of given depth and no actual CLUT
+
+#define LOG(...)
+
+struct ACIhdr {		//BE for ease
+	uint16_t w;
+	uint16_t h;
+	uint8_t flags;
+	uint8_t numColorsM2;
+	uint8_t clut[];//[numColorsM2 + 1][3]
+	//uint8_t startVals[numColorsM2 + 1]
+	//uint8_t data
+} __attribute__((packed));
+
+
+int aciDecode(struct DrawState *ds, const void *data, uint32_t dataSz, ImgHdrDecodedCbkF hdrCbk)
+{
+	const struct ACIhdr *hdr = (const struct ACIhdr*)data; 
+	const uint8_t *src = (const uint8_t*)(hdr + 1);
+	const uint8_t *srcEnd = src + dataSz;
+	uint_fast16_t i, numColors, w, h;
+	struct PixelRange *colors;
+	bool success;
+	
+	if (dataSz < sizeof(struct ACIhdr))
+		return -1;
+	
+	//verify we understadn the version
+	if (!(hdr->flags & FLAGS_V1))
+		return -1;
+	
+	numColors = 2 + hdr->numColorsM2;
+	
+	//at least one byte of data is mandatory, thus LE and not LT
+	if (dataSz <= sizeof(struct ACIhdr) + (2 + 1) * numColors)
+		return -1;
+	
+	//ask if the size is ok, get allocated a destination buffer
+#ifdef __ARM__
+	h = __builtin_bswap16(hdr->h);
+	w = __builtin_bswap16(hdr->w);
+#else
+	h = hdr->h;
+	w = hdr->w;
+#endif
+	
+	colors = malloc(sizeof(struct PixelRange) * numColors);
+	if (!colors)
+		return -1;
+	
+	//read in the CLUT, if it exists
+	if (hdr->flags & FLAGS_HAS_CLUT) {
+		for (i = 0; i < numColors - 1; i++) {
+			
+			colors[i].index = i;
+			colors[i].r = *src++;
+			colors[i].g = *src++;
+			colors[i].b = *src++;
+		}
+	}
+	else {
+		
+		for (i = 0; i < numColors - 1; i++) {
+			
+			uint16_t bri = (i * 255 + (numColors - 2) / 2) / (numColors - 2);
+			
+			colors[i].index = i;
+			
+			colors[i].r = bri;
+			colors[i].g = bri;
+			colors[i].b = bri;
+		}
+	}
+	
+	if (!hdrCbk(ds, w, h, (struct ColortableEntry*)colors, numColors - 1, !(hdr->flags & FLAGS_HAS_CLUT))) {
+		free(colors);
+		return -1;
+	}
+
+	//read in ranges
+	colors[0].start = 0;
+	for (i = 0; i < numColors - 1; i++)
+		colors[i].end = colors[i + 1].start = *src++;
+	colors[i].end = 256;
+	
+	//we are ready to process image data
+	success = aciDecodeBits(ds->bits, ds->rowBytes - w, w, h, colors, numColors, src, srcEnd);
+	
+	free(colors);
+	
+	return success ? 0 : -1;
+}
\ No newline at end of file
diff --git a/Src/aciDecode.h b/Src/aciDecode.h
new file mode 100644
index 0000000..a560669
--- /dev/null
+++ b/Src/aciDecode.h
@@ -0,0 +1,20 @@
+#ifndef _ACI_DECODE_H_
+#define _ACI_DECODE_H_
+
+#include <stdbool.h>
+#include <stdint.h>
+
+
+struct PixelRange {					//assembly assumes this is 8 bytes big
+	uint8_t index, r, g, b;			//assembly assumes "index" is at offset 0
+	uint16_t start;					//assembly assumes this is at offset 4
+	uint16_t end;					//assembly assumes this is at offset 6
+};	//iface code assumes this struct is same size and coincides with "struct ColortableEntry"
+
+//low-level bits decoder
+bool aciDecodeBits(uint8_t *dst, uint16_t dstExtraStride, uint16_t w, uint16_t h, const struct PixelRange *ranges, uint16_t numColors, const uint8_t *src, const uint8_t *srcEnd);
+
+
+
+
+#endif
diff --git a/Src/aciDecodeARM.c b/Src/aciDecodeARM.c
new file mode 100644
index 0000000..674a4ad
--- /dev/null
+++ b/Src/aciDecodeARM.c
@@ -0,0 +1,132 @@
+#include "aciDecode.h"
+
+
+#define LOG(...)
+
+struct BitBuffer {
+	uint8_t bitBuf;
+	uint8_t numBitsHere;
+	const uint8_t *src;
+	const uint8_t *srcEnd;
+};
+
+static void bbInit(struct BitBuffer *bb, const uint8_t *src, const uint8_t *srcEnd)
+{
+	bb->numBitsHere = 0;
+	bb->bitBuf = 0;
+	bb->src = src;
+	bb->srcEnd = srcEnd;
+}
+
+static uint_fast8_t __attribute__((always_inline)) bbRead(struct BitBuffer *bb)	//read a bit
+{
+	uint_fast8_t ret;
+	
+	if (!bb->numBitsHere) {
+		
+		bb->numBitsHere = 8;
+		if (bb->src < bb->srcEnd)
+			bb->bitBuf = *bb->src++;
+		//will already be zero so no need to set it in the "else" case
+	}
+	
+	bb->numBitsHere--;
+	ret = bb->bitBuf & 1;
+	bb->bitBuf >>= 1;
+
+	return ret;
+}
+
+bool aciDecodeBits(uint8_t *dst, uint16_t dstExtraStride, uint16_t w, uint16_t h, const struct PixelRange *ranges, uint16_t numColors, const uint8_t *src, const uint8_t *srcEnd)
+{
+	uint_fast16_t prevIdx = numColors - 1, i, r, c;
+	uint16_t min = 0, max = 0xffff, val = 0;
+	struct BitBuffer bb;
+	
+	bbInit(&bb, src, srcEnd);
+	
+	//init state
+	for (i = 0; i < 16; i++)
+		val = val * 2 + bbRead(&bb);
+	
+	for (r = 0; r < h; r++, dst += dstExtraStride) {
+		
+		for (c = 0; c < w; c++) {
+			
+			uint32_t width = (uint32_t)max - min + 1, above = val - min, now = (above * 256 + 255) / width;
+			uint_fast8_t idxNow;
+			
+			//find matching symbol for "now". binary search
+			uint_fast16_t end = numColors, start = 0, center = 0;
+			
+			LOG(">> val 0x%08xh, above 0x%08xh, looking for %08xh\n", val, above, now);
+			
+			while (end > start) {
+				
+				center = (end + start) / 2;
+				
+				if (ranges[center].end <= now)
+					start = center;
+				else if (ranges[center].start > now)
+					end = center;
+				else
+					break;
+			}
+			
+			idxNow = (center == (unsigned)(numColors - 1)) ? prevIdx : center;
+			prevIdx = idxNow;
+			
+			//emit the pixel
+			*dst++ = ranges[idxNow].index;
+			
+			//adjust state
+			LOG("[%4u/%4u] idx %2u applying range %02xh...%02xh to %08xh...%08xh", (unsigned)(r * w + c), (unsigned)(w * h), center, 
+				ranges[center].start, ranges[center].end, (unsigned)(uint32_t)min, (unsigned)(uint32_t)max);
+			
+			//calc new range (once again, gcc sucks)
+			//max = min + width * ranges[center].end / 256 - 1;
+			//min = min + width * ranges[center].start / 256;
+			//width can only take one 17-bit value - 0x10000, and it cannot take on the value of 0x0000
+			//this test doe si tbetter than gcc could
+			max = min + width * ranges[center].end / 256 - 1;
+			min = min + width * ranges[center].start / 256;
+			
+			LOG(" produces a range of %08xh...%08xh\n", (unsigned)(uint32_t)min, (unsigned)(uint32_t)max);
+			
+			while ((min >> 15) == (max >> 15)) {
+				
+				min = min * 2;
+				max = max * 2 + 1;
+				
+				val = val * 2 + bbRead(&bb);
+				LOG(" reading %u -> %08xh\n", val & 1, (unsigned)val);
+				LOG("  %08xh...%08xh\n", (unsigned)(uint32_t)min, (unsigned)(uint32_t)max);
+			}
+			
+			while ((min >> 14) == 1 && (max >> 14) == 2) {
+				
+				min = (min << 1) ^ 0x8000;
+				max = (max << 1) ^ 0x8001;
+				
+				val = (val & 0x8000) + (val & 0x3fff) * 2 + bbRead(&bb);
+				LOG(" truncate-reading %u-> %08xh\n", val & 1, (unsigned)val);
+				LOG("  %08xh...%08xh\n", (unsigned)(uint32_t)min, (unsigned)(uint32_t)max);
+			}
+
+			if (min > max) {
+				
+				//range crossed
+				return false;
+			}
+			if (val < min || val > max) {
+				
+				//val is oob
+				return false;
+			}
+		}
+	}
+	
+	return true;
+}
+
+
diff --git a/Src/aciDecodeAsm68k.S b/Src/aciDecodeAsm68k.S
new file mode 100644
index 0000000..c5e87a6
--- /dev/null
+++ b/Src/aciDecodeAsm68k.S
@@ -0,0 +1,339 @@
+//palmos allows d0-d2, a0-a1 to be clobbered
+//bool aciDecodeBits(uint8_t *dst, uint16_t dstExtraStride, uint16_t w, uint16_t h, const struct PixelRange *ranges, uint16_t numColors, const uint8_t *src, const uint8_t *srcEnd);
+//before push:        4(sp)            8(sp)             10(sp)     12(sp)         14(sp)                         18(sp)                 20(sp)            24(sp)
+//after push:        arg(val_above)(sp)
+//by compressor spec, at least one byte of input is guaranteed
+
+#define arg(_x)		(44 + _x)
+
+.macro get_bit				//into carry and extend flag
+	subq.w		#1, %d5
+	bpl.b		9f
+	cmpa.l		%a0, %a1
+	beq.b		8f
+	move.b		(%a0)+, %d3
+8:
+	moveq		#7, %d5
+9:
+	lsr			#1, %d3
+.endm
+
+.globl aciDecodeBits
+aciDecodeBits:
+
+	movem.l		%d2-%d7/%a2-%a6,-(%sp)	//d2 stored to make space on stack
+	
+	movea.l		arg(20)(%sp), %a0		//a0 = "src"
+	movea.l		arg(24)(%sp), %a1		//a1 = "srcEnd"
+	movea.l		arg(14)(%sp), %a2		//a2 = "ranges"
+	movea.w		arg(18)(%sp), %a3		//a3 = "numColors"
+	subq.l		#1, %a3
+	adda.l		%a3, %a3
+	adda.l		%a3, %a3
+	adda.l		%a3, %a3
+	adda.l		%a2, %a3				//a3 = "&ranges[numColors - 1]"
+	movea.l		arg(4)(%sp), %a5		//a5 = "dst"
+	
+	moveq		#0, %d6					//d6.w = min
+	move.w		#0xffff, %d7			//d7.w = max
+	moveq		#0, %d5					//d5.b = "bitsAvail"
+	moveq		#0, %d4					//d4 = "val"
+	moveq		#0, %d3					//d3 = bit reservoir for reading
+
+//read initial "val"
+	moveq		#15, %d0
+1:
+	get_bit
+	addx.w		%d4, %d4
+	dbra.w		%d0, 1b
+	
+	move.w		arg(12)(%sp), %a6		//a6 = "h" for loop
+	
+row_loop:
+		
+	move.w		arg(10)(%sp), %d1		//d1.w = inverse of "w" for dbra
+	subq.w		#1, %d1
+	
+col_loop:
+
+	move.l		%d4, %d2				//d2.l = "above" = val - min
+	sub.w		%d6, %d2
+	addq.l		#1, %d2
+	lsl.l		#8, %d2
+	subq.l		#1, %d2					//d2.l = (above * 256 + 255)
+
+	move.w		%d7, %d0
+	sub.w		%d6, %d0
+	addq.w		#1, %d0					//d0 = width.lo16
+	beq.b		1f
+	divu.w		%d0, %d2
+	bra			2f
+1:
+	swap		%d2
+2:										//%d2.w = "now" = (above * 256 + 255) / width
+	
+	//we'll try linear search from end for ease of assembly
+	
+	movea.l		%a3, %a4				//a4 = &ranges[numColors - 1]
+
+2:
+	cmp.w		4(%a4), %d2				//set flags on now - a4->start
+	blt.b		1f
+	cmp.w		6(%a4), %d2				//set flags on now - a4->end
+	blt.b		2f						//match
+1:
+	subq.l		#8, %a4
+	cmpa.l		%a2, %a4				//set flags on a4 - a2
+	bpl.b		2b
+2:										//match
+
+	cmpa.l		%a4, %a3				//d2 = "idxNow" = (center == (uint16_t)(numColors - 1)) ? prevIdx : center;
+										//0(sp) = "prevIdx" = idxNo		//realy prevIdx and idxNow store: &ranges[$_SOMETHING_$]
+	beq.b		1f
+	move.b		(%a4), %d2
+	move.b		%d2, 0(%sp)
+	bra.b		2f
+1:
+	move.b		0(%sp), %d2
+2:
+	
+	move.b		%d2, (%a5)+				//*dst++ = ranges[idxNow].color
+		
+	tst.w		%d0
+	beq.b		1f
+	move.w		6(%a4), %d7				//max = min + mul16x16_32(width, ranges[center].end) / 256 - 1;
+	mulu.w		%d0, %d7
+	lsr.l		#8, %d7					//guaranteed to produce max 16 bits
+	subq.w		#1, %d7
+	add.w		%d6, %d7
+	move.w		4(%a4), %d2				//min += mul16x16_32(width, ranges[center].start) / 256;
+	mulu.w		%d0, %d2
+	lsr.l		#8, %d2					//guaranteed to produce max 16 bits
+	add.w		%d2, %d6
+	
+	bra.b		2f
+1:
+	move.b		7(%a4), %d7				//same as: "move.w 6(%a4), %d7 ; lsl.w #8, %d7"
+	lsl.w		#8, %d7					//max = min + ranges[center].end * 256 - 1;
+	subq.w		#1, %d7
+	add.w		%d6, %d7
+	
+	move.b		5(%a4), %d2				//same as: "move.w 4(%a4), %d2 ; lsl.w #8, %d2"
+	lsl.w		#8, %d2					//min = min + ranges[center].start * 256;
+	add.w		%d2, %d6
+2:
+	
+handle_equal_top_bits:
+	move.w		%d6, %d2				//while ((min >> 15) == (max >> 15)) {
+	eor.w		%d7, %d2
+	bmi.b		equal_top_bits_handled
+//top bits match
+	
+	add.w		%d6, %d6				//	min = min * 2;
+	add.w		%d7, %d7				//	max = max * 2 + 1;
+	addq.w		#1, %d7
+	
+	get_bit
+	addx.w		%d4, %d4				//	val = val * 2 + bbRead(&bb);
+	
+	bra.b		handle_equal_top_bits	//}
+equal_top_bits_handled:
+	
+handle_indeterminate:
+	//we need to check if top bits of "min" are 01 and of "max "are 10
+	//we know their current top bits DIFFER, adn we know min < max
+	//thus we know the top bits ARE correct, just check bits #14
+	btst		#14, %d6				//while ((min >> 14) == 1 && (max >> 14) == 2) {
+	beq.b		indeterminate_handled
+	btst		#14, %d7
+	bne.b		indeterminate_handled
+//top bits as expected
+	
+	move.w		#0x8000, %d2
+	
+	add.w		%d6, %d6				//	min = (min << 1) ^ 0x8000;
+	eor.w		%d2, %d6
+	add.w		%d7, %d7				//	max = (max << 1) ^ 0x8001;
+	eori.w		#0x8001, %d7
+	
+	and.w		%d4, %d2				//	val = (val & 0x8000) + (val & 0x3fff) * 2 + bbRead(&bb);
+	andi.w		#0x3fff, %d4
+	get_bit
+	addx.w		%d4, %d4
+	add.w		%d2, %d4	
+	
+	bra.b		handle_indeterminate	//}
+indeterminate_handled:
+
+	dbra		%d1, col_loop
+	
+	adda.w		arg(8)(%sp), %a5		//dst += dstExtraStride
+	
+	subq.l		#1, %a6
+	move.l		%a6, %d2				//just to set flags since "subq" should but doesnt
+	bne			row_loop
+	
+	moveq.l		#1, %d0
+	movem.l		(%sp)+, %d2-%d7/%a2-%a6
+	rts
+
+/*
+{
+	uint16_t i, r, c;
+	uint16_t min = 0, max = 0xffff, val = 0;
+	uint_fast16_t prevIdx = numColors - 1;
+	struct BitBuffer bb;
+	
+	bbInit(&bb, src, srcEnd);
+	
+	//init state
+	for (i = 0; i < sizeof(val) * 8; i++)
+		val = val * 2 + bbRead(&bb);
+	
+	for (r = 0; r < h; r++, dst += dstExtraStride) {
+		
+		for (c = 0; c < w; c++) {
+			
+			uint32_t width = (uint32_t)max - min + 1;
+			uint16_t above = val - min;
+			uint16_t now;
+			uint_fast8_t idxNow;
+			
+			//this is faster than long multiplication and long division
+			//now = (above * 256 + 255) / width
+			//result will always be a byte, but gcc sucks at compiling this
+			//width will never be zero, so comparnig with zero is as good as comparing with 0x10000
+			now = ((uint32_t)above * 256 + 255) / width;
+			
+			//find matching symbol for "now". binary search
+			uint_fast16_t end = numColors, start = 0, center;
+						
+			while (end > start) {
+				
+				center = (end + start) / 2;
+				
+				if (ranges[center].end <= now)
+					start = center;
+				else if (ranges[center].start > now)
+					end = center;
+				else
+					break;
+			}
+			
+			idxNow = (center == (uint16_t)(numColors - 1)) ? prevIdx : center;
+			prevIdx = idxNow;
+			
+			//emit the pixel
+			*dst++ = ranges[idxNow].color;
+			
+			//calc new range (once again, gcc sucks)
+			max = min + width * ranges[center].end / 256 - 1;
+			min = min + width * ranges[center].start / 256;
+						
+			while ((min >> 15) == (max >> 15)) {
+				
+				min = min * 2;
+				max = max * 2 + 1;
+				
+				val = val * 2 + bbRead(&bb);
+			}
+			
+			while ((min >> 14) == 1 && (max >> 14) == 2) {
+				
+				min = (min << 1) ^ 0x8000;
+				max = (max << 1) ^ 0x8001;
+				
+				val = (val & 0x8000) + (val & 0x3fff) * 2 + bbRead(&bb);
+			}
+
+			if (min > max) {
+				
+				ErrAlertCustom(0, "range crossed", 0, 0);
+				return false;
+			}
+			if (val < min || val > max) {
+				
+				ErrAlertCustom(0, "val OOB", 0, 0);
+				return false;
+			}
+		}
+	}
+	
+	return true;
+}
+
+*/
+
+
+
+//void aciRepack(UInt8* buffer, UInt32 npixels, UInt8 depth)
+//                      4(sp)     8(sp)           12(sp)
+//we are guaranteed thta we'll produce an integer number of 16-bit words as output!
+//do not pass-in zero width or height
+#undef arg
+#define arg(_x)		(0 + _x)
+.globl aciRepack
+aciRepack:
+	move.l		arg(4)(%sp), %a0			//a0 = dst
+	move.l		%a0, %a1					//a1 = src
+	move.l		arg(8)(%sp), %d0
+	cmpi.b  	#2, arg(12)(%sp)
+	beq.b		aciRepack_2bpp
+	blt.b		aciRepack_1bpp
+	
+aciRepack_4bpp:
+	move.l		(%a0)+, %d2
+	move.l		%d2, %d1
+	lsr.l		#4, %d1
+	add.l		%d1, %d2
+	swap		%d2
+	move.b		%d2, (%a1)+
+	swap		%d2
+	move.b		%d2, (%a1)+
+	subq.w		#4, %d0
+	bne.b		aciRepack_4bpp
+	rts
+
+aciRepack_2bpp:
+//we know DESTINATION has integer multiples of words (thus integer multiple of 8 pixels) so we can untoll this loop 2x
+.rept 2
+	move.l		(%a0)+, %d2
+	move.l		%d2, %d1
+	lsr.l		#6, %d1
+	add.l		%d1, %d2
+	move.l		%d2, %d1
+	swap		%d1
+	lsl.w		#4, %d1
+	add.w		%d1, %d2
+	move.b		%d2, (%a1)+
+.endr
+	subq.w		#8, %d0
+	bne.b		aciRepack_2bpp
+	rts
+
+aciRepack_1bpp:
+//we know DESTINATION has integer multiples of words (thus integer multiple of 16 pixels) so we can untoll this loop 4x, but we only do 2x, as a compromise of code size
+.rept 2
+	move.l		(%a0)+, %d2
+	move.l		%d2, %d1
+	lsr.l		#7, %d1
+	add.l		%d1, %d2
+	move.l		%d2, %d1
+	swap		%d1
+	lsl.w		#2, %d1
+	add.w		%d1, %d2
+	lsl.w		#4, %d2
+	move.b		%d2, (%a1)
+	move.l		(%a0)+, %d2
+	move.l		%d2, %d1
+	lsr.l		#7, %d1
+	add.l		%d1, %d2
+	move.l		%d2, %d1
+	swap		%d1
+	lsl.w		#2, %d1
+	add.w		%d1, %d2
+	add.b		%d2, (%a1)+
+.endr
+	subi.w		#16, %d0
+	bne.b		aciRepack_1bpp
+	rts
\ No newline at end of file
diff --git a/Src/arm.lkr b/Src/arm.lkr
index c1efe7b..3b24682 100644
--- a/Src/arm.lkr
+++ b/Src/arm.lkr
@@ -3,30 +3,33 @@ MEMORY
 {
 	rom : ORIGIN = 0x10000000, LENGTH = 256K
 	ram : ORIGIN = 0x20000000, LENGTH = 512K
-
+	
 	trash : ORIGIN = 0xffff0000, LENGTH = 65535
 }
 
 SECTIONS
 {
 	.text : {
-
+	
 		KEEP( *(.vector) ) ;
 		*(.vector);
-
-		*(.text) *(.text.*) ;
-
-		. = ALIGN(4);
+		
+		*(.text) *(.text.*) ; 
+		
+	 	. = ALIGN(4); 
 		KEEP ( *( SORT ( .patches ) ) ) ;
 		KEEP ( *( SORT ( .patches.* ) ) ) ;
-
+		
 	}  > rom
 	.rodata : { *(.rodata) *(.rodata.*) ; . = ALIGN(4); __data_data = ABSOLUTE(.) ; }  > rom
 
 	.data : AT ( ADDR ( .rodata ) + SIZEOF ( .rodata ) ) { . = ALIGN(4); __data_start = ADDR ( .data ) + . ; *(.data) ; *(.data.*) ; . = ALIGN(4); __data_end = ADDR ( .data ) + . ; } > ram
-
+	
 	.bss  :  { . = ALIGN(4); __bss_start = ABSOLUTE(.) ; *(.bss) *(.bss.*) *(COMMON) ; . = ALIGN(4); __bss_end  = ABSOLUTE(.) ; } > ram
-
+	
 	.trash1 : { *(.ARM.exidx) *(.ARM.exidx.*) ; }  > trash
 	.trash2 : { *(.init) *(.init.*) ; *(.fini) *(.fini.*) ; }  > trash
 }
+
+
+
diff --git a/Src/armcalls.c b/Src/armcalls.c
index 0c2bc01..9ebf478 100644
--- a/Src/armcalls.c
+++ b/Src/armcalls.c
@@ -14,22 +14,22 @@ void armCallsInit(void *set_emulStateP, void *set_call68KFuncP)
 	call68KFuncP = set_call68KFuncP;
 }
 
-unsigned long armCallDo(unsigned long m68kFunc, const void *stackParams, unsigned long paramLen)
-{
-	return call68KFuncP(emulStateP, m68kFunc, stackParams, paramLen);
-}
-
+unsigned long armCallDo(unsigned long m68kFunc, const void *stackParams, unsigned long paramLen)
+{
+	return call68KFuncP(emulStateP, m68kFunc, stackParams, paramLen);
+}
+
 void* MemPtrNew(uint32_t size)
 {
 	uint32_t stackParam = __builtin_bswap32(size);
-
+	
 	return (void*)call68KFuncP(emulStateP, PceNativeTrapNo(sysTrapMemPtrNew), &stackParam, sizeof(stackParam) | kPceNativeWantA0);
 }
 
 void MemChunkFree(void *ptr)
 {
 	uint32_t stackParam = __builtin_bswap32((uintptr_t)ptr);
-
+	
 	call68KFuncP(emulStateP, PceNativeTrapNo(sysTrapMemChunkFree), &stackParam, sizeof(stackParam));
 }
 
@@ -44,7 +44,7 @@ Err MemSet(void *dst, uint32_t len, uint8_t val)
 		.len = __builtin_bswap32(len),
 		.val = val,
 	};
-
+	
 	return call68KFuncP(emulStateP, PceNativeTrapNo(sysTrapMemSet), &stackParams, sizeof(stackParams));
 }
 
@@ -59,7 +59,7 @@ Err MemMove(void *dst, void *src, uint32_t len)
 		.src = __builtin_bswap32((uintptr_t)src),
 		.len = __builtin_bswap32(len),
 	};
-
+	
 	return call68KFuncP(emulStateP, PceNativeTrapNo(sysTrapMemMove), &stackParams, sizeof(stackParams));
 }
 
@@ -72,14 +72,14 @@ uint16_t MemPtrResize(void *ptr, uint32_t len)
 		.ptr = __builtin_bswap32((uintptr_t)ptr),
 		.len = __builtin_bswap32(len),
 	};
-
+	
 	return call68KFuncP(emulStateP, PceNativeTrapNo(sysTrapMemPtrResize), &stackParams, sizeof(stackParams));
 }
 
 uint32_t MemPtrSize(void *ptr)
 {
 	uint32_t stackParam = __builtin_bswap32((uintptr_t)ptr);
-
+	
 	return call68KFuncP(emulStateP, PceNativeTrapNo(sysTrapMemPtrSize), &stackParam, sizeof(stackParam));
 }
 
@@ -94,6 +94,6 @@ uint16_t FrmCustomAlert(uint16_t id, char *s1, char *s2, char *s3)
 		.s2 = __builtin_bswap32((uintptr_t)s2),
 		.s3 = __builtin_bswap32((uintptr_t)s3),
 	};
-
+	
 	return call68KFuncP(emulStateP, PceNativeTrapNo(sysTrapFrmCustomAlert), &stackParams, sizeof(stackParams));
 }
\ No newline at end of file
diff --git a/Src/glue.c b/Src/glue.c
new file mode 100644
index 0000000..9f2af67
--- /dev/null
+++ b/Src/glue.c
@@ -0,0 +1,22 @@
+#define ALLOW_ACCESS_TO_INTERNALS_OF_BITMAPS
+#include <PalmOSGlue.h>
+#include <PalmOS.h>
+
+
+void BmpGlueGetDimensions(const BitmapType *bitmapP, Coord *widthP, Coord *heightP, UInt16 *rowBytesP)
+{
+	UInt32 romVersion;
+	
+	if (errNone == FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion) && romVersion >= sysMakeROMVersion(4,0,0,sysROMStageRelease,0)) {
+		
+		BmpGetDimensions(bitmapP, widthP, heightP, rowBytesP);
+	}
+	else {
+		if (widthP)
+			*widthP = bitmapP->width;
+		if (heightP)
+			*heightP = bitmapP->height;
+		if (rowBytesP)
+			*rowBytesP = bitmapP->rowBytes;
+	}
+}
\ No newline at end of file
diff --git a/Src/helpers.c b/Src/helpers.c
index 59b7135..65fc0e0 100644
--- a/Src/helpers.c
+++ b/Src/helpers.c
@@ -6,11 +6,11 @@
 	    UInt32 ftrValue;
 	    char buffer[256];
 	    va_list args;
-
+	
 	    if (FtrGet('cldp', 0, &ftrValue) || ftrValue != 0x20150103) return;
-
+	
 	    va_start(args, fmt);
-
+	
 	    if (StrVPrintF(buffer, fmt, (_Palm_va_list)args) > 255)
 	        DbgMessage("DebugLog: buffer overflowed, memory corruption ahead");
 	    else
diff --git a/Src/imgDraw.c b/Src/imgDraw.c
new file mode 100644
index 0000000..40b925e
--- /dev/null
+++ b/Src/imgDraw.c
@@ -0,0 +1,305 @@
+#define ALLOW_ACCESS_TO_INTERNALS_OF_BITMAPS
+#include <PalmOSGlue.h>
+#include <PalmOS.h>
+#include <PceNativeCall.h>
+#include <SonyCLIE.h>
+#include "imgDrawInt.h"
+#include "imgDraw.h"
+
+#define PNG_HI_RES_SUPPORTED				1		//sonyHR only supports double
+#define PNG_VARIOUS_DENSITIES_SUPPORTED		2		//palmHR supports various
+
+
+static int pngDrawDecodeCallNEW(struct DrawState *ds, const void *data, uint32_t dataSz);
+
+
+static Boolean isHighDensitySupported(void)
+{
+	UInt32 version;
+	
+	return errNone == FtrGet(sysFtrCreator, sysFtrNumWinVersion, &version) && version >= 4;
+}
+
+static Boolean isSonyHiResSupported(void)
+{
+	UInt16 hrLibRef;
+	
+	return errNone == SysLibFind(sonySysLibNameHR, &hrLibRef) && hrLibRef != 0xffff;
+}
+
+void imgDrawStateFree(struct DrawState *ds)
+{
+	if (ds->depth < 8)
+		MemPtrFree(ds->b);	//we allocated it manually - free it so too
+	else
+		BmpDelete(ds->b);
+	MemPtrFree(ds);
+}
+
+void imgDrawRedraw(struct DrawState *ds, int16_t x, int16_t y)
+{
+	if (ds->density == kDensityLow) {
+		
+		WinDrawBitmap(ds->b, x, y);
+	}
+	else if (ds->densitySupportFlags & PNG_VARIOUS_DENSITIES_SUPPORTED) {	//high density feature set is easier to deal with  - use that
+		
+		BitmapPtr b3 = (BitmapPtr)BmpCreateBitmapV3(ds->b, ds->density, ds->bits, NULL);
+		if (b3) {
+			
+			WinDrawBitmap(b3, x, y);
+			BmpDelete(b3);
+		}
+	}
+	else if (ds->density == kDensityDouble && (ds->densitySupportFlags & PNG_HI_RES_SUPPORTED)) {
+		
+		UInt16 hrLibRef;
+		
+		if (errNone == SysLibFind(sonySysLibNameHR, &hrLibRef) && hrLibRef != 0xffff) {
+			
+			/*
+				Some Sony CLIE devices with PalmOS 4 have a bug when drawing a high-res image with
+				its own palette unto the screen. They will swap every two columns with each other,
+				creating a horizontal blinds-like effect. This is indeed a bug in the OS. To verify,
+				simply try drawing the image in non-high-res-mode or not having a colortable
+				attached to the image. The workaround is to not use such an image. TBD
+			*/
+			
+			HRWinDrawBitmap(hrLibRef, ds->b, x * 2, y * 2);
+		}
+	}
+}
+
+static unsigned char imgDrawHdrCbk(struct DrawState *ds, uint32_t w, uint32_t h, struct ColortableEntry *colors, uint16_t numColors, unsigned char isGreyscale)
+{
+	Boolean colorSupport;
+	UInt32 curDepth;
+	Err err;
+
+	if (errNone != WinScreenMode(winScreenModeGet, NULL, NULL, &curDepth, &colorSupport))
+		colorSupport = false;
+
+	//check for nonzero exact integer or 1/2 multiple of size, same for W & H
+	if (!w || !h || w * 2 % ds->expectedW || h * 2 % ds->expectedW || w * 2 / ds->expectedW != h * 2 / ds->expectedW)
+		return false;
+	
+	//see WHICH multiple it is, along the way, verify we support & expect that density
+	switch (w * 2 / ds->expectedW) {
+		case 2:	//expected size
+			ds->density = kDensityLow;
+			break;
+		
+		case 3:	//1.5 the size
+			ds->density = kDensityOneAndAHalf;
+			if (!(ds->densitySupportFlags & PNG_VARIOUS_DENSITIES_SUPPORTED))
+				return false;
+			break;
+		
+		case 4:	//2x the size
+			ds->density = kDensityDouble;
+			if (!(ds->densitySupportFlags & (PNG_VARIOUS_DENSITIES_SUPPORTED | PNG_HI_RES_SUPPORTED)))
+				return false;
+			break;
+		
+		case 6:	//3x the density
+			ds->density = kDensityTriple;
+			if (!(ds->densitySupportFlags & PNG_VARIOUS_DENSITIES_SUPPORTED))
+				return false;
+			break;
+		
+		case 8:	//4x the density
+			ds->density = kDensityQuadruple;
+			if (!(ds->densitySupportFlags & PNG_VARIOUS_DENSITIES_SUPPORTED))
+				return false;
+			break;
+		
+		default:
+			return false;
+	}
+	
+	/*
+		We need to handle the incoming color table info we do so by setting the system palette as needed
+		and adjusting the indices as well. They come in already sorted from most to least common. 
+		
+		Palm OS Programmers Companion, Volume I, "Color and Grayscale Support" quoth:
+			216 color Web-safe palette, which includes all
+			combinations of red, green, and blue at these levels: 0x00,
+			0x33, 0x66, 0x99, 0xCC, and 0xFF. Also, it includes all 16 gray
+			shades at these levels: 0x00, 0x11, 0x22, ... 0xFF. Finally, it
+			includes these extra named HTML colors: 0xC0C0C0 (silver),
+			0x808080 (gray), 0x800000 (maroon), 0x800080 (purple),
+			0x008000 (green), and 0x008080 (teal). The remaining 24
+			entries (indexes 0xE7 through 0xFE) are unspecified and
+			filled with black. These entries may be defined by an
+			application.
+		
+		On greyscale devices we do not bother with screen colortables at all, we convert all color entries
+		to proper grey, and then later re-pack the image pixels to proper depth
+	*/
+	if (colorSupport) {
+	
+		UInt16 i, j, palSize = 256, nextFreeColor = 0xE7, lastFreeColor = 0xFE;
+		struct RGBColorType *clut;
+	
+		if (curDepth != 8) {
+			
+			ErrAlertCustom(0, "Current screen depth is not a supported one", NULL, NULL);
+			return false;
+		}
+	
+		clut = MemPtrNew(sizeof(RGBColorType) * palSize);
+		if (!clut) {
+			ErrAlertCustom(0, "alloc fail", 0, 0);
+			return false;
+		}
+		//set to default and get it
+		if (errNone != WinPalette(winPaletteSetToDefault, 0, palSize, NULL) || errNone != WinPalette(winPaletteGet, 0, palSize, clut)) {
+			ErrAlertCustom(0, "palette fail", 0, 0);
+			MemPtrFree(clut);
+			return false;
+		}
+		
+		//use user clut entries (0xE7..0xFE) and then pass 0 for the rest, do not bother finding best possible match
+		for (i = 0; i < numColors; i++) {
+			if (nextFreeColor <= lastFreeColor) { 		//else if there is space, add it
+				
+				clut[nextFreeColor].r = colors[i].r;
+				clut[nextFreeColor].g = colors[i].g;
+				clut[nextFreeColor].b = colors[i].b;
+				colors[i].index = nextFreeColor++;
+			}
+			else
+				colors[i].index = 0;
+		}
+		err = WinPalette(winPaletteSet, 0, palSize, clut);
+		MemPtrFree(clut);
+		if (err != errNone) {
+			ErrAlertCustom(0, "palette set fail", 0, 0);
+			return false;
+		}
+		ds->b = BmpCreate(w, h, 8, NULL, &err);
+		if (!ds->b) {
+			ErrAlertCustom(err, "Cannot create bitmap", NULL, NULL);
+			return false;
+		}
+		BmpGlueGetDimensions(ds->b, NULL, NULL, &ds->rowBytes);
+		ds->bits = BmpGetBits(ds->b);
+		ds->depth = 8;
+	}
+	else {		//our device does not support color and is thus in greyscale mode
+		
+		UInt16 i, nScreenColorsM1 = (1 << curDepth) - 1, realStride, virtualStride;
+		struct BitmapTypeV1 *bmp1;
+		
+		switch (curDepth) {
+			
+			case 1:
+			case 2:
+			case 4:
+				break;
+			
+			default:
+				ErrAlertCustom(0, "Current screen depth is not a supported one", NULL, NULL);
+				return false;
+		}
+		
+		//convert each clut entry to proper shade of grey, save that as the desired index, that way we can then easily pack them
+		for (i = 0; i < numColors; i++) {
+			
+			UInt16 grey;
+			
+			grey = 76 * colors[i].r + 151 * colors[i].g + 29 * colors[i].b;
+			grey = (grey + 128) >> 8;
+			grey = (grey << curDepth) - grey;		// grey *= (1 << curDepth) - 1
+			colors[i].index = nScreenColorsM1 - ((grey + 128) >> 8);
+		}
+		
+		//for 1bpp, we'll create a V0 bitmap, for all others - a V1. The headers are the same size, and fields overlap (by design)
+		//we make a bitmap with enough space for a byte per pixel because our decodedr produces that. We then repack the data and
+		//shrink the allocation. To mak erepacking easier, we prefer the stride *in pixels* of both arrays to be the same. This
+		//allows the repacking process to process data in convenient chunks
+		realStride = ((w * curDepth) + 15) / 16 * 2;
+		virtualStride = realStride * 8 / curDepth;
+		bmp1 = MemPtrNew(sizeof(struct BitmapTypeV1) + virtualStride * h);	//enough space for 8bpp, will shrink later - our decoder emits 8bpp
+		MemSet(bmp1, sizeof(*bmp1), 0);
+		bmp1->width = w;
+		bmp1->height = h;
+		bmp1->rowBytes = ((w * curDepth) + 15) / 16 * 2;
+		
+		if (curDepth != 1) {
+			
+			bmp1->pixelSize = curDepth;
+			bmp1->version = 1;
+		}
+		ds->b = (BitmapPtr)bmp1;
+		ds->bits = (UInt8*)(bmp1 + 1);
+		ds->rowBytes = virtualStride;
+		ds->depth = curDepth;
+	}
+	
+	return true;
+}
+
+static int imgDecodeCall(struct DrawState *ds, const void *data, uint32_t dataSz)
+{
+	UInt32 processorType, result;
+	int ret;
+	
+	if (errNone == FtrGet(sysFileCSystem, sysFtrNumProcessorID, &processorType)	&& sysFtrNumProcessorIsARM(processorType)) {
+		
+		MemHandle armH;
+	
+		struct ArmParams p = {
+			.ds = ds,
+			.data = data,
+			.dataSz = dataSz,
+			.hdrDecodedF = imgDrawHdrCbk,
+		};
+				
+		ret = PceNativeCall((NativeFuncType*)MemHandleLock(armH = DmGetResource('armc', 1)), &p);
+		MemHandleUnlock(armH);
+		DmReleaseResource(armH);
+	}
+	else {
+		
+		ret = aciDecode(ds, data, dataSz, imgDrawHdrCbk);
+	}
+	
+	//repack
+	if (ds->depth < 8) {
+		
+		struct BitmapTypeV1 *bmp1 = (struct BitmapTypeV1*)ds->b;
+		aciRepack(ds->bits, bmp1->height * (bmp1->rowBytes * 8 / ds->depth), ds->depth);
+		MemPtrResize(ds->b, sizeof(struct BitmapTypeV1) + bmp1->height * bmp1->rowBytes);
+	}
+	
+	return ret;
+}
+
+void imgDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_t x, int16_t y, uint32_t expectedW, uint32_t expectedH)
+{
+	uint8_t densitySupportFlags = 0;
+	struct DrawState *ds;
+	int ret;
+	
+	if (isHighDensitySupported())
+		densitySupportFlags |= PNG_VARIOUS_DENSITIES_SUPPORTED;
+	if (isSonyHiResSupported())
+		densitySupportFlags |= PNG_HI_RES_SUPPORTED;
+	
+	ds = (struct DrawState *)MemPtrNew(sizeof(struct DrawState));
+	if (!ds)
+		return;
+	MemSet(ds, sizeof(*ds), 0);
+	ds->expectedW = expectedW;
+	ds->expectedH = expectedH;
+	ds->densitySupportFlags = densitySupportFlags;
+
+	ret = imgDecodeCall(ds, data, dataSz);
+	ErrFatalDisplayIf(ret < 0, "Error decoding image");
+	
+	imgDrawRedraw(ds, x, y);
+	
+	*dsP = ds;
+}
+
diff --git a/Src/pngDraw.h b/Src/imgDraw.h
similarity index 56%
rename from Src/pngDraw.h
rename to Src/imgDraw.h
index 251a880..377b9e1 100644
--- a/Src/pngDraw.h
+++ b/Src/imgDraw.h
@@ -1,5 +1,5 @@
-#ifndef _PNG_DRAW_H_
-#define _PNG_DRAW_H_
+#ifndef _IMG_DRAW_H_
+#define _IMG_DRAW_H_
 
 #include <stdbool.h>
 #include <stdint.h>		//avoid PalmOS includes in ARM code
@@ -8,14 +8,14 @@ struct BitmapType;
 struct DrawState;
 
 //decodes and stores state in "dsP"
-void pngDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_t x, int16_t y, uint32_t expectedW, uint32_t expectedH);
+void imgDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_t x, int16_t y, uint32_t expectedW, uint32_t expectedH); 
 
 //delete am already-decoded state
-void pngDrawStateFree(struct DrawState *ds);
+void imgDrawStateFree(struct DrawState *ds);
 
 //redraw an already-decoded state
-void pngDrawRedraw(struct DrawState *ds, int16_t x, int16_t y);
+void imgDrawRedraw(struct DrawState *ds, int16_t x, int16_t y);
+
+
 
-
-
 #endif
diff --git a/Src/pngDrawArm.c b/Src/imgDrawArmlet.c
similarity index 74%
rename from Src/pngDrawArm.c
rename to Src/imgDrawArmlet.c
index e414541..0784906 100644
--- a/Src/pngDrawArm.c
+++ b/Src/imgDrawArmlet.c
@@ -1,144 +1,130 @@
-#include "Src/pngle.h"
-#include "pngDrawInt.h"
-#include "armcalls.h"
-
-
-struct DrawStateWrapper {
-	struct DrawState ds;	//must be first
-	uint32_t m68kCallback;
-};
-
-void on_draw(pngle_t *pngle, uint_fast16_t x, uint_fast16_t y, uint_fast16_t vR, uint_fast16_t vG, uint_fast16_t vB, uint_fast16_t vA, struct DrawState *ds)
-{
-	uint_fast16_t r = vR & 0xf8;
-	uint_fast16_t g = vG & 0xfc;
-	uint_fast16_t b = vB & 0xf8;
-	uint_fast16_t color = (r << 8) + (g << 3) + (b >> 3);
-
-	uint16_t *dst = ds->bits + y * ds->rowHalfwords + x;
-
-	*dst = __builtin_bswap16(color);
-}
-
-static uint32_t read32(const void *fromP)			//read unaligned 32 bit in BE
-{
-	const uint8_t *from = fromP;
-	uint32_t ret = 0;
-
-	ret = (ret << 8) + from[0];
-	ret = (ret << 8) + from[1];
-	ret = (ret << 8) + from[2];
-	ret = (ret << 8) + from[3];
-
-	return ret;
-}
-
-static uint16_t read16(const void *fromP)			//read unaligned 16 bit in BE
-{
-	const uint8_t *from = fromP;
-	uint16_t ret = 0;
-	
-	ret = (ret << 8) + from[0];
-	ret = (ret << 8) + from[1];
-	
-	return ret;
-}
-
-static void write32(void *dstP, uint32_t val)		//write unaligned 32 bit in LE
-{
-	uint8_t *dst = dstP;
-	
-	dst[0] = val;
-	dst[1] = val >> 8;
-	dst[2] = val >> 16;
-	dst[3] = val >> 24;
-}
-
-static void write16(void *dstP, uint16_t val)		//write unaligned 16 bit in LE
-{
-	uint8_t *dst = dstP;
-	
-	dst[0] = val;
-	dst[1] = val >> 8;
-}
-
-static void prvSwapDs(struct DrawState *dst, const struct DrawState *src)
-{
-	write32(&dst->b, read32(&src->b));
-	write32(&dst->bits, read32(&src->bits));
-	write32(&dst->expectedW, read32(&src->expectedW));
-	write32(&dst->expectedH, read32(&src->expectedH));
-	write16(&dst->rowHalfwords, read16(&src->rowHalfwords));
-	write16(&dst->density, read16(&src->density));
-	dst->densitySupportFlags = src->densitySupportFlags;
-}
-
-static unsigned char pngDrawHdrCbk(struct DrawState *ds, uint32_t w, uint32_t h)
-{
-	struct DrawStateWrapper *dsw = (struct DrawStateWrapper*)ds;
-	struct DrawState ds68k;
-	unsigned char ret;
-	struct {
-		struct DrawState *ds;
-		uint32_t w;
-		uint32_t h;
-	} params = {
-		.ds = (void*)__builtin_bswap32((uintptr_t)&ds68k),
-		.w = __builtin_bswap32(w),
-		.h = __builtin_bswap32(h),
-	};
-	
-	prvSwapDs(&ds68k, ds);
-	ret = armCallDo(dsw->m68kCallback, &params, sizeof(params));
-	prvSwapDs(ds, &ds68k);
-	
-	return ret;
-}
-
-int __attribute__((used)) ArmletMain(void *emulStateP, struct ArmParams *pp, void *call68KFuncP)
-{
-	struct DrawStateWrapper dsw;
-	struct DrawState *ds68k;
-	pngle_t *pngle;
-	int ret;
-
-	armCallsInit(emulStateP, call68KFuncP);
-
-	ds68k = (struct DrawState*)read32(&pp->ds);
-	prvSwapDs(&dsw.ds, ds68k);
-	dsw.m68kCallback = read32(&pp->hdrDecodedF);
-	
-	pngle = pngle_new();
-	if (!pngle)
-		return -1;
-
-	pngle_set_draw_callback(pngle, &dsw.ds);
-	pngle_set_init_callback(pngle, pngDrawHdrCbk);
-
-	ret = pngle_feed(pngle, (const void*)read32(&pp->data), read32(&pp->dataSz));
-	
-	pngle_destroy(pngle);
-	prvSwapDs(ds68k, &dsw.ds);
-
-	return ret;
-}
-
-void __attribute((naked, used, section(".vector"), target("arm"))) __entry(void)
-{
-	//gcc will refuse to call a thumb functionj from this arm entry point no matter what we do
-	//so we are forced to do it ourselves if we want to compile for thumb (we do for space)
-
-	asm volatile(
-		"1:									\n"
-		"	stmfd	sp!, {r10, r11, lr}		\n"
-		"	ldr		r10, =1b				\n"
-		"	adr		r11, 1b					\n"
-		"	ldr		r12, =ArmletMain		\n"
-		"	sub		r12, r10				\n"
-		"	add		r12, r11				\n"
-		"	mov		lr, pc					\n"
-		"	bx		r12						\n"
-		"	ldmfd	sp!, {r10, r11, lr}		\n"
-		"	bx		lr						\n"
-	);
-}
+#include "imgDrawInt.h"
+#include "armcalls.h"
+
+
+struct DrawStateWrapper {
+	struct DrawState ds;	//must be first
+	uint32_t m68kCallback;
+};
+
+static uint32_t read32(const void *fromP)			//read unaligned 32 bit in BE
+{
+	const uint8_t *from = fromP;
+	uint32_t ret = 0;
+	
+	ret = (ret << 8) + from[0];
+	ret = (ret << 8) + from[1];
+	ret = (ret << 8) + from[2];
+	ret = (ret << 8) + from[3];
+	
+	return ret;
+}
+
+static uint16_t read16(const void *fromP)			//read unaligned 16 bit in BE
+{
+	const uint8_t *from = fromP;
+	uint16_t ret = 0;
+	
+	ret = (ret << 8) + from[0];
+	ret = (ret << 8) + from[1];
+	
+	return ret;
+}
+
+static void write32(void *dstP, uint32_t val)		//write unaligned 32 bit in LE
+{
+	uint8_t *dst = dstP;
+	
+	dst[0] = val;
+	dst[1] = val >> 8;
+	dst[2] = val >> 16;
+	dst[3] = val >> 24;
+}
+
+static void write16(void *dstP, uint16_t val)		//write unaligned 16 bit in LE
+{
+	uint8_t *dst = dstP;
+	
+	dst[0] = val;
+	dst[1] = val >> 8;
+}
+
+static void prvSwapDs(struct DrawState *dst, const struct DrawState *src)
+{
+	write32(&dst->b, read32(&src->b));
+	write32(&dst->bits, read32(&src->bits));
+	write32(&dst->expectedW, read32(&src->expectedW));
+	write32(&dst->expectedH, read32(&src->expectedH));
+	write16(&dst->rowBytes, read16(&src->rowBytes));
+	write16(&dst->density, read16(&src->density));
+	dst->densitySupportFlags = src->densitySupportFlags;
+	dst->depth = src->depth;
+}
+
+static unsigned char pngDrawHdrCbk(struct DrawState *ds, uint32_t w, uint32_t h, struct ColortableEntry *colors, uint16_t numColors, unsigned char isGreyscale)
+{
+	struct DrawStateWrapper *dsw = (struct DrawStateWrapper*)ds;
+	struct DrawState ds68k;
+	unsigned char ret;
+	struct {
+		struct DrawState *ds;
+		uint32_t w;
+		uint32_t h;
+		const struct ColortableEntry *colors;
+		uint16_t numColors;
+		unsigned char isGreyscale, padding;
+	} __attribute__((packed)) params = {
+		.ds = (void*)__builtin_bswap32((uintptr_t)&ds68k),
+		.w = __builtin_bswap32(w),
+		.h = __builtin_bswap32(h),
+		.colors = (struct ColortableEntry*)__builtin_bswap32((uintptr_t)colors),
+		.numColors = __builtin_bswap16(numColors),
+		.isGreyscale = isGreyscale,
+	};
+	
+	prvSwapDs(&ds68k, ds);
+	ret = armCallDo(dsw->m68kCallback, &params, sizeof(params));
+	prvSwapDs(ds, &ds68k);
+	
+	return ret;
+}
+
+int __attribute__((used)) ArmletMain(void *emulStateP, struct ArmParams *pp, void *call68KFuncP)
+{
+	struct DrawStateWrapper dsw;
+	struct DrawState *ds68k;
+	int ret;
+
+	armCallsInit(emulStateP, call68KFuncP);
+
+	ds68k = (struct DrawState*)read32(&pp->ds);
+	prvSwapDs(&dsw.ds, ds68k);
+	dsw.m68kCallback = read32(&pp->hdrDecodedF);
+	
+	ret = aciDecode(&dsw.ds, (const void*)read32(&pp->data), read32(&pp->dataSz), pngDrawHdrCbk);
+
+	prvSwapDs(ds68k, &dsw.ds);
+
+	return ret;
+}
+
+void __attribute((naked, used, section(".vector"), target("arm"))) __entry(void)
+{
+	//gcc will refuse to call a thumb functionj from this arm entry point no matter what we do
+	//so we are forced to do it ourselves if we want to compile for thumb (we do for space)
+	
+	asm volatile(
+		"1:									\n"
+		"	stmfd	sp!, {r10, r11, lr}		\n"
+		"	ldr		r10, =1b				\n"
+		"	adr		r11, 1b					\n"
+		"	ldr		r12, =ArmletMain		\n"
+		"	sub		r12, r10				\n"
+		"	add		r12, r11				\n"
+		"	mov		lr, pc					\n"
+		"	bx		r12						\n"
+		"	ldmfd	sp!, {r10, r11, lr}		\n"
+		"	bx		lr						\n"
+	);
+}
+
diff --git a/Src/imgDrawInt.h b/Src/imgDrawInt.h
new file mode 100644
index 0000000..44f8a83
--- /dev/null
+++ b/Src/imgDrawInt.h
@@ -0,0 +1,43 @@
+#ifndef _IMG_DRAW_INT_H_
+#define _IMG_DRAW_INT_H_
+
+#include <stdbool.h>
+#include <stdint.h>		//avoid PalmOS includes in ARM code
+
+struct BitmapType;
+
+struct DrawState {
+	struct BitmapType *b;
+	uint8_t *bits;
+	
+	uint32_t expectedW;
+	uint32_t expectedH;
+	
+	uint16_t rowBytes;
+	uint16_t density;
+	
+	uint8_t densitySupportFlags;
+	uint8_t depth;
+};
+
+struct ColortableEntry {
+	uint8_t index, r, g, b;		//set "index" as you please got given colors
+	uint32_t rfu;
+};
+
+//callback on size
+typedef unsigned char (*ImgHdrDecodedCbkF)(struct DrawState *ds, uint32_t width, uint32_t height, struct ColortableEntry *colors, uint16_t numColors, unsigned char isGreyscale);
+
+//68k entries
+int aciDecode(struct DrawState *ds, const void *data, uint32_t dataSz, ImgHdrDecodedCbkF hdrCbk);
+void aciRepack(uint8_t* buffer, uint32_t npixels, uint8_t depth);
+
+struct ArmParams {
+	struct DrawState *ds;
+	const void *data;
+	uint32_t dataSz;
+	
+	ImgHdrDecodedCbkF hdrDecodedF;
+};
+
+#endif
diff --git a/Src/miniz.c b/Src/miniz.c
deleted file mode 100644
index 0435c9f..0000000
--- a/Src/miniz.c
+++ /dev/null
@@ -1,4939 +0,0 @@
-/* miniz.c v1.15 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing
-   See "unlicense" statement at the end of this file.
-   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
-   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt
-
-   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define
-   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).
-
-   * Change History
-     10/13/13 v1.15 r4 - Interim bugfix release while I work on the next major release with Zip64 support (almost there!):
-       - Critical fix for the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY bug (thanks kahmyong.moon@hp.com) which could cause locate files to not find files. This bug
-        would only have occured in earlier versions if you explicitly used this flag, OR if you used mz_zip_extract_archive_file_to_heap() or mz_zip_add_mem_to_archive_file_in_place()
-        (which used this flag). If you can't switch to v1.15 but want to fix this bug, just remove the uses of this flag from both helper funcs (and of course don't use the flag).
-       - Bugfix in mz_zip_reader_extract_to_mem_no_alloc() from kymoon when pUser_read_buf is not NULL and compressed size is > uncompressed size
-       - Fixing mz_zip_reader_extract_*() funcs so they don't try to extract compressed data from directory entries, to account for weird zipfiles which contain zero-size compressed data on dir entries.
-         Hopefully this fix won't cause any issues on weird zip archives, because it assumes the low 16-bits of zip external attributes are DOS attributes (which I believe they always are in practice).
-       - Fixing mz_zip_reader_is_file_a_directory() so it doesn't check the internal attributes, just the filename and external attributes
-       - mz_zip_reader_init_file() - missing MZ_FCLOSE() call if the seek failed
-       - Added cmake support for Linux builds which builds all the examples, tested with clang v3.3 and gcc v4.6.
-       - Clang fix for tdefl_write_image_to_png_file_in_memory() from toffaletti
-       - Merged MZ_FORCEINLINE fix from hdeanclark
-       - Fix <time.h> include before config #ifdef, thanks emil.brink
-       - Added tdefl_write_image_to_png_file_in_memory_ex(): supports Y flipping (super useful for OpenGL apps), and explicit control over the compression level (so you can
-        set it to 1 for real-time compression).
-       - Merged in some compiler fixes from paulharris's github repro.
-       - Retested this build under Windows (VS 2010, including static analysis), tcc  0.9.26, gcc v4.6 and clang v3.3.
-       - Added example6.c, which dumps an image of the mandelbrot set to a PNG file.
-       - Modified example2 to help test the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY flag more.
-       - In r3: Bugfix to mz_zip_writer_add_file() found during merge: Fix possible src file fclose() leak if alignment bytes+local header file write faiiled
-		 - In r4: Minor bugfix to mz_zip_writer_add_from_zip_reader(): Was pushing the wrong central dir header offset, appears harmless in this release, but it became a problem in the zip64 branch
-     5/20/12 v1.14 - MinGW32/64 GCC 4.6.1 compiler fixes: added MZ_FORCEINLINE, #include <time.h> (thanks fermtect).
-     5/19/12 v1.13 - From jason@cornsyrup.org and kelwert@mtu.edu - Fix mz_crc32() so it doesn't compute the wrong CRC-32's when mz_ulong is 64-bit.
-       - Temporarily/locally slammed in "typedef unsigned long mz_ulong" and re-ran a randomized regression test on ~500k files.
-       - Eliminated a bunch of warnings when compiling with GCC 32-bit/64.
-       - Ran all examples, miniz.c, and tinfl.c through MSVC 2008's /analyze (static analysis) option and fixed all warnings (except for the silly
-        "Use of the comma-operator in a tested expression.." analysis warning, which I purposely use to work around a MSVC compiler warning).
-       - Created 32-bit and 64-bit Codeblocks projects/workspace. Built and tested Linux executables. The codeblocks workspace is compatible with Linux+Win32/x64.
-       - Added miniz_tester solution/project, which is a useful little app derived from LZHAM's tester app that I use as part of the regression test.
-       - Ran miniz.c and tinfl.c through another series of regression testing on ~500,000 files and archives.
-       - Modified example5.c so it purposely disables a bunch of high-level functionality (MINIZ_NO_STDIO, etc.). (Thanks to corysama for the MINIZ_NO_STDIO bug report.)
-       - Fix ftell() usage in examples so they exit with an error on files which are too large (a limitation of the examples, not miniz itself).
-     4/12/12 v1.12 - More comments, added low-level example5.c, fixed a couple minor level_and_flags issues in the archive API's.
-      level_and_flags can now be set to MZ_DEFAULT_COMPRESSION. Thanks to Bruce Dawson <bruced@valvesoftware.com> for the feedback/bug report.
-     5/28/11 v1.11 - Added statement from unlicense.org
-     5/27/11 v1.10 - Substantial compressor optimizations:
-      - Level 1 is now ~4x faster than before. The L1 compressor's throughput now varies between 70-110MB/sec. on a
-      - Core i7 (actual throughput varies depending on the type of data, and x64 vs. x86).
-      - Improved baseline L2-L9 compression perf. Also, greatly improved compression perf. issues on some file types.
-      - Refactored the compression code for better readability and maintainability.
-      - Added level 10 compression level (L10 has slightly better ratio than level 9, but could have a potentially large
-       drop in throughput on some files).
-     5/15/11 v1.09 - Initial stable release.
-
-   * Low-level Deflate/Inflate implementation notes:
-
-     Compression: Use the "tdefl" API's. The compressor supports raw, static, and dynamic blocks, lazy or
-     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses
-     approximately as well as zlib.
-
-     Decompression: Use the "tinfl" API's. The entire decompressor is implemented as a single function
-     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory
-     block large enough to hold the entire file.
-
-     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.
-
-   * zlib-style API notes:
-
-     miniz.c implements a fairly large subset of zlib. There's enough functionality present for it to be a drop-in
-     zlib replacement in many apps:
-        The z_stream struct, optional memory allocation callbacks
-        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
-        inflateInit/inflateInit2/inflate/inflateEnd
-        compress, compress2, compressBound, uncompress
-        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.
-        Supports raw deflate streams or standard zlib streams with adler-32 checking.
-
-     Limitations:
-      The callback API's are not implemented yet. No support for gzip headers or zlib static dictionaries.
-      I've tried to closely emulate zlib's various flavors of stream flushing and return status codes, but
-      there are no guarantees that miniz.c pulls this off perfectly.
-
-   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by
-     Alex Evans. Supports 1-4 bytes/pixel images.
-
-   * ZIP archive API notes:
-
-     The ZIP archive API's where designed with simplicity and efficiency in mind, with just enough abstraction to
-     get the job done with minimal fuss. There are simple API's to retrieve file information, read files from
-     existing archives, create new archives, append new files to existing archives, or clone archive data from
-     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),
-     or you can specify custom file read/write callbacks.
-
-     - Archive reading: Just call this function to read a single file from a disk archive:
-
-      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,
-        size_t *pSize, mz_uint zip_flags);
-
-     For more complex cases, use the "mz_zip_reader" functions. Upon opening an archive, the entire central
-     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.
-
-     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:
-
-     UInt32 mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
-
-     The locate operation can optionally check file comments too, which (as one example) can be used to identify
-     multiple versions of the same file in an archive. This function uses a simple linear search through the central
-     directory, so it's not very fast.
-
-     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and
-     retrieve detailed info on each file by calling mz_zip_reader_file_stat().
-
-     - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer immediately writes compressed file data
-     to disk and builds an exact image of the central directory in memory. The central directory image is written
-     all at once at the end of the archive file when the archive is finalized.
-
-     The archive writer can optionally align each file's local header and file data to any power of 2 alignment,
-     which can be useful when the archive will be read from optical media. Also, the writer supports placing
-     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still
-     readable by any ZIP tool.
-
-     - Archive appending: The simple way to add a single file to an archive is to call this function:
-
-      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,
-        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
-
-     The archive will be created if it doesn't already exist, otherwise it'll be appended to.
-     Note the appending is done in-place and is not an atomic operation, so if something goes wrong
-     during the operation it's possible the archive could be left without a central directory (although the local
-     file headers and file data will be fine, so the archive will be recoverable).
-
-     For more complex archive modification scenarios:
-     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to
-     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the
-     compressed file data as-is). When you're done, delete the old archive and rename the newly written archive, and
-     you're done. This is safe but requires a bunch of temporary disk space or heap memory.
-
-     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),
-     append new files as needed, then finalize the archive which will write an updated central directory to the
-     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There's a
-     possibility that the archive's central directory could be lost with this method if anything goes wrong, though.
-
-     - ZIP archive support limitations:
-     No zip64 or spanning support. Extraction functions can only handle unencrypted, stored or deflated files.
-     Requires streams capable of seeking.
-
-   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the
-     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.
-
-   * Important: For best perf. be sure to customize the below macros for your target platform:
-     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
-     #define MINIZ_LITTLE_ENDIAN 1
-     #define MINIZ_HAS_64BIT_REGISTERS 1
-
-   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before including miniz.c to ensure miniz
-     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be able to process large files
-     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
-*/
-
-#pragma GCC optimize ("O3")
-
-
-#ifndef MINIZ_HEADER_INCLUDED
-#define MINIZ_HEADER_INCLUDED
-
-#include <stdlib.h>
-
-// Defines to completely disable specific portions of miniz.c:
-// If all macros here are defined the only functionality remaining will be CRC-32, adler-32, tinfl, and tdefl.
-
-// Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O.
-#define MINIZ_NO_STDIO
-
-// If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or
-// get/set file times, and the C run-time funcs that get/set times won't be called.
-// The current downside is the times written to your archives will be from 1979.
-#define MINIZ_NO_TIME
-
-// Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's.
-#define MINIZ_NO_ARCHIVE_APIS
-
-// Define MINIZ_NO_ARCHIVE_APIS to disable all writing related ZIP archive API's.
-#define MINIZ_NO_ARCHIVE_WRITING_APIS
-
-// Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API's.
-#define MINIZ_NO_ZLIB_APIS
-
-// Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib.
-//#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES
-
-// Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.
-// Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc
-// callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user
-// functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work.
-//#define MINIZ_NO_MALLOC
-
-// 
-#define MINIZ_NO_COMPRESSION
-
-
-#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
-  // TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc on Linux
-  #define MINIZ_NO_TIME
-#endif
-
-#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
-  #include <time.h>
-#endif
-
-#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)
-// MINIZ_X86_OR_X64_CPU is only used to help set the below macros.
-#define MINIZ_X86_OR_X64_CPU 0
-#endif
-
-#if (__BYTE_ORDER__==__ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU
-// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.
-#define MINIZ_LITTLE_ENDIAN 0
-#endif
-
-#if MINIZ_X86_OR_X64_CPU
-// Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses.
-#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
-#endif
-
-#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)
-// Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions).
-#define MINIZ_HAS_64BIT_REGISTERS 0
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// ------------------- zlib-style API Definitions.
-
-// For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!
-typedef unsigned long mz_ulong;
-
-// mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap.
-void mz_free(void *p);
-
-#define MZ_ADLER32_INIT (1)
-// mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL.
-mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);
-
-#define MZ_CRC32_INIT (0)
-// mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL.
-mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);
-
-// Compression strategies.
-enum { MZ_DEFAULT_STRATEGY = 0, MZ_FILTERED = 1, MZ_HUFFMAN_ONLY = 2, MZ_RLE = 3, MZ_FIXED = 4 };
-
-// Method
-#define MZ_DEFLATED 8
-
-#ifndef MINIZ_NO_ZLIB_APIS
-
-// Heap allocation callbacks.
-// Note that mz_alloc_func parameter types purpsosely differ from zlib's: items/size is size_t, not unsigned long.
-typedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);
-typedef void (*mz_free_func)(void *opaque, void *address);
-typedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items, size_t size);
-
-#define MZ_VERSION          "9.1.15"
-#define MZ_VERNUM           0x91F0
-#define MZ_VER_MAJOR        9
-#define MZ_VER_MINOR        1
-#define MZ_VER_REVISION     15
-#define MZ_VER_SUBREVISION  0
-
-// Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs).
-enum { MZ_NO_FLUSH = 0, MZ_PARTIAL_FLUSH = 1, MZ_SYNC_FLUSH = 2, MZ_FULL_FLUSH = 3, MZ_FINISH = 4, MZ_BLOCK = 5 };
-
-// Return status codes. MZ_PARAM_ERROR is non-standard.
-enum { MZ_OK = 0, MZ_STREAM_END = 1, MZ_NEED_DICT = 2, MZ_ERRNO = -1, MZ_STREAM_ERROR = -2, MZ_DATA_ERROR = -3, MZ_MEM_ERROR = -4, MZ_BUF_ERROR = -5, MZ_VERSION_ERROR = -6, MZ_PARAM_ERROR = -10000 };
-
-// Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.
-enum { MZ_NO_COMPRESSION = 0, MZ_BEST_SPEED = 1, MZ_BEST_COMPRESSION = 9, MZ_UBER_COMPRESSION = 10, MZ_DEFAULT_LEVEL = 6, MZ_DEFAULT_COMPRESSION = -1 };
-
-// Window bits
-#define MZ_DEFAULT_WINDOW_BITS 15
-
-struct mz_internal_state;
-
-// Compression/decompression stream struct.
-typedef struct mz_stream_s
-{
-  const unsigned char *next_in;     // pointer to next byte to read
-  unsigned UInt32 avail_in;            // number of bytes available at next_in
-  mz_ulong total_in;                // total number of bytes consumed so far
-
-  unsigned char *next_out;          // pointer to next byte to write
-  unsigned UInt32 avail_out;           // number of bytes that can be written to next_out
-  mz_ulong total_out;               // total number of bytes produced so far
-
-  char *msg;                        // error msg (unused)
-  struct mz_internal_state *state;  // internal state, allocated by zalloc/zfree
-
-  mz_alloc_func zalloc;             // optional heap allocation function (defaults to malloc)
-  mz_free_func zfree;               // optional heap free function (defaults to free)
-  void *opaque;                     // heap alloc function user pointer
-
-  UInt32 data_type;                    // data_type (unused)
-  mz_ulong adler;                   // adler32 of the source or uncompressed data
-  mz_ulong reserved;                // not used
-} mz_stream;
-
-typedef mz_stream *mz_streamp;
-
-// Returns the version string of miniz.c.
-const char *mz_version(void);
-
-// mz_deflateInit() initializes a compressor with default options:
-// Parameters:
-//  pStream must point to an initialized mz_stream struct.
-//  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION].
-//  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio.
-//  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.)
-// Return values:
-//  MZ_OK on success.
-//  MZ_STREAM_ERROR if the stream is bogus.
-//  MZ_PARAM_ERROR if the input parameters are bogus.
-//  MZ_MEM_ERROR on out of memory.
-UInt32 mz_deflateInit(mz_streamp pStream, UInt32 level);
-
-// mz_deflateInit2() is like mz_deflate(), except with more control:
-// Additional parameters:
-//   method must be MZ_DEFLATED
-//   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer)
-//   mem_level must be between [1, 9] (it's checked but ignored by miniz.c)
-UInt32 mz_deflateInit2(mz_streamp pStream, UInt32 level, UInt32 method, UInt32 window_bits, UInt32 mem_level, UInt32 strategy);
-
-// Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2().
-UInt32 mz_deflateReset(mz_streamp pStream);
-
-// mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible.
-// Parameters:
-//   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
-//   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH.
-// Return values:
-//   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full).
-//   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore.
-//   MZ_STREAM_ERROR if the stream is bogus.
-//   MZ_PARAM_ERROR if one of the parameters is invalid.
-//   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.)
-UInt32 mz_deflate(mz_streamp pStream, UInt32 flush);
-
-// mz_deflateEnd() deinitializes a compressor:
-// Return values:
-//  MZ_OK on success.
-//  MZ_STREAM_ERROR if the stream is bogus.
-UInt32 mz_deflateEnd(mz_streamp pStream);
-
-// mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH.
-mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);
-
-// Single-call compression functions mz_compress() and mz_compress2():
-// Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure.
-UInt32 mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
-UInt32 mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, UInt32 level);
-
-// mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress().
-mz_ulong mz_compressBound(mz_ulong source_len);
-
-// Initializes a decompressor.
-UInt32 mz_inflateInit(mz_streamp pStream);
-
-// mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer:
-// window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate).
-UInt32 mz_inflateInit2(mz_streamp pStream, UInt32 window_bits);
-
-// Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible.
-// Parameters:
-//   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
-//   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH.
-//   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster).
-//   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data.
-// Return values:
-//   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full.
-//   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified.
-//   MZ_STREAM_ERROR if the stream is bogus.
-//   MZ_DATA_ERROR if the deflate stream is invalid.
-//   MZ_PARAM_ERROR if one of the parameters is invalid.
-//   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again
-//   with more input data, or with more room in the output buffer (except when using single call decompression, described above).
-UInt32 mz_inflate(mz_streamp pStream, UInt32 flush);
-
-// Deinitializes a decompressor.
-UInt32 mz_inflateEnd(mz_streamp pStream);
-
-// Single-call decompression.
-// Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure.
-UInt32 mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
-
-// Returns a string description of the specified error code, or NULL if the error code is invalid.
-const char *mz_error(UInt32 err);
-
-// Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports.
-// Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project.
-#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
-  typedef unsigned char Byte;
-  typedef unsigned long uInt;
-  typedef mz_ulong uLong;
-  typedef Byte Bytef;
-  typedef uInt uIntf;
-  typedef char charf;
-  typedef UInt32 intf;
-  typedef void *voidpf;
-  typedef uLong uLongf;
-  typedef void *voidp;
-  typedef void *const voidpc;
-  #define Z_NULL                0
-  #define Z_NO_FLUSH            MZ_NO_FLUSH
-  #define Z_PARTIAL_FLUSH       MZ_PARTIAL_FLUSH
-  #define Z_SYNC_FLUSH          MZ_SYNC_FLUSH
-  #define Z_FULL_FLUSH          MZ_FULL_FLUSH
-  #define Z_FINISH              MZ_FINISH
-  #define Z_BLOCK               MZ_BLOCK
-  #define Z_OK                  MZ_OK
-  #define Z_STREAM_END          MZ_STREAM_END
-  #define Z_NEED_DICT           MZ_NEED_DICT
-  #define Z_ERRNO               MZ_ERRNO
-  #define Z_STREAM_ERROR        MZ_STREAM_ERROR
-  #define Z_DATA_ERROR          MZ_DATA_ERROR
-  #define Z_MEM_ERROR           MZ_MEM_ERROR
-  #define Z_BUF_ERROR           MZ_BUF_ERROR
-  #define Z_VERSION_ERROR       MZ_VERSION_ERROR
-  #define Z_PARAM_ERROR         MZ_PARAM_ERROR
-  #define Z_NO_COMPRESSION      MZ_NO_COMPRESSION
-  #define Z_BEST_SPEED          MZ_BEST_SPEED
-  #define Z_BEST_COMPRESSION    MZ_BEST_COMPRESSION
-  #define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
-  #define Z_DEFAULT_STRATEGY    MZ_DEFAULT_STRATEGY
-  #define Z_FILTERED            MZ_FILTERED
-  #define Z_HUFFMAN_ONLY        MZ_HUFFMAN_ONLY
-  #define Z_RLE                 MZ_RLE
-  #define Z_FIXED               MZ_FIXED
-  #define Z_DEFLATED            MZ_DEFLATED
-  #define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
-  #define alloc_func            mz_alloc_func
-  #define free_func             mz_free_func
-  #define internal_state        mz_internal_state
-  #define z_stream              mz_stream
-  #define deflateInit           mz_deflateInit
-  #define deflateInit2          mz_deflateInit2
-  #define deflateReset          mz_deflateReset
-  #define deflate               mz_deflate
-  #define deflateEnd            mz_deflateEnd
-  #define deflateBound          mz_deflateBound
-  #define compress              mz_compress
-  #define compress2             mz_compress2
-  #define compressBound         mz_compressBound
-  #define inflateInit           mz_inflateInit
-  #define inflateInit2          mz_inflateInit2
-  #define inflate               mz_inflate
-  #define inflateEnd            mz_inflateEnd
-  #define uncompress            mz_uncompress
-  #define crc32                 mz_crc32
-  #define adler32               mz_adler32
-  #define MAX_WBITS             15
-  #define MAX_MEM_LEVEL         9
-  #define zError                mz_error
-  #define ZLIB_VERSION          MZ_VERSION
-  #define ZLIB_VERNUM           MZ_VERNUM
-  #define ZLIB_VER_MAJOR        MZ_VER_MAJOR
-  #define ZLIB_VER_MINOR        MZ_VER_MINOR
-  #define ZLIB_VER_REVISION     MZ_VER_REVISION
-  #define ZLIB_VER_SUBREVISION  MZ_VER_SUBREVISION
-  #define zlibVersion           mz_version
-  #define zlib_version          mz_version()
-#endif // #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
-
-#endif // MINIZ_NO_ZLIB_APIS
-
-// ------------------- Types and macros
-#include <PalmTypes.h>
-#include <stdarg.h>
-
-typedef unsigned char mz_uint8;
-typedef signed short mz_int16;
-typedef unsigned short mz_uint16;
-typedef unsigned long mz_uint32;
-typedef unsigned long mz_uint;
-typedef long long mz_int64;
-typedef unsigned long long mz_uint64;
-typedef int mz_bool;
-
-#define MZ_FALSE (0)
-#define MZ_TRUE (1)
-
-// An attempt to work around MSVC's spammy "warning C4127: conditional expression is constant" message.
-#ifdef _MSC_VER
-   #define MZ_MACRO_END while (0, 0)
-#else
-   #define MZ_MACRO_END while (0)
-#endif
-
-// ------------------- ZIP archive reading/writing
-
-#ifndef MINIZ_NO_ARCHIVE_APIS
-
-enum
-{
-  MZ_ZIP_MAX_IO_BUF_SIZE = 64*1024,
-  MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 260,
-  MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 256
-};
-
-typedef struct
-{
-  mz_uint32 m_file_index;
-  mz_uint32 m_central_dir_ofs;
-  mz_uint16 m_version_made_by;
-  mz_uint16 m_version_needed;
-  mz_uint16 m_bit_flag;
-  mz_uint16 m_method;
-#ifndef MINIZ_NO_TIME
-  time_t m_time;
-#endif
-  mz_uint32 m_crc32;
-  mz_uint64 m_comp_size;
-  mz_uint64 m_uncomp_size;
-  mz_uint16 m_internal_attr;
-  mz_uint32 m_external_attr;
-  mz_uint64 m_local_header_ofs;
-  mz_uint32 m_comment_size;
-  char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];
-  char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];
-} mz_zip_archive_file_stat;
-
-typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n);
-typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n);
-
-struct mz_zip_internal_state_tag;
-typedef struct mz_zip_internal_state_tag mz_zip_internal_state;
-
-typedef enum
-{
-  MZ_ZIP_MODE_INVALID = 0,
-  MZ_ZIP_MODE_READING = 1,
-  MZ_ZIP_MODE_WRITING = 2,
-  MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
-} mz_zip_mode;
-
-typedef struct mz_zip_archive_tag
-{
-  mz_uint64 m_archive_size;
-  mz_uint64 m_central_directory_file_ofs;
-  mz_uint m_total_files;
-  mz_zip_mode m_zip_mode;
-
-  mz_uint m_file_offset_alignment;
-
-  mz_alloc_func m_pAlloc;
-  mz_free_func m_pFree;
-  mz_realloc_func m_pRealloc;
-  void *m_pAlloc_opaque;
-
-  mz_file_read_func m_pRead;
-  mz_file_write_func m_pWrite;
-  void *m_pIO_opaque;
-
-  mz_zip_internal_state *m_pState;
-
-} mz_zip_archive;
-
-typedef enum
-{
-  MZ_ZIP_FLAG_CASE_SENSITIVE                = 0x0100,
-  MZ_ZIP_FLAG_IGNORE_PATH                   = 0x0200,
-  MZ_ZIP_FLAG_COMPRESSED_DATA               = 0x0400,
-  MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800
-} mz_zip_flags;
-
-// ZIP archive reading
-
-// Inits a ZIP archive reader.
-// These functions read and validate the archive's central directory.
-mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint32 flags);
-mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint32 flags);
-
-#ifndef MINIZ_NO_STDIO
-mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags);
-#endif
-
-// Returns the total number of files in the archive.
-mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);
-
-// Returns detailed information about an archive file entry.
-mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);
-
-// Determines if an archive file entry is a directory entry.
-mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index);
-mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index);
-
-// Retrieves the filename of an archive file entry.
-// Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename.
-mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size);
-
-// Attempts to locates a file in the archive's central directory.
-// Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH
-// Returns -1 if the file cannot be found.
-UInt32 mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
-
-// Extracts a archive file to a memory buffer using no memory allocation.
-mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
-mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
-
-// Extracts a archive file to a memory buffer.
-mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags);
-mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags);
-
-// Extracts a archive file to a dynamically allocated heap buffer.
-void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);
-void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags);
-
-// Extracts a archive file using a callback function to output the file's data.
-mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
-mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
-
-#ifndef MINIZ_NO_STDIO
-// Extracts a archive file to a disk file and sets its last accessed and modified times.
-// This function only extracts files, not archive directory records.
-mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags);
-mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags);
-#endif
-
-// Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used.
-mz_bool mz_zip_reader_end(mz_zip_archive *pZip);
-
-// ZIP archive writing
-
-#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-
-// Inits a ZIP archive writer.
-mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
-mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);
-
-#ifndef MINIZ_NO_STDIO
-mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);
-#endif
-
-// Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive.
-// For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called.
-// For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you've overridden it).
-// Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL.
-// Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before
-// the archive is finalized the file's central directory will be hosed.
-mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename);
-
-// Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive.
-// To add a directory entry, call this method with an archive name ending in a forwardslash with empty buffer.
-// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
-mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags);
-mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);
-
-#ifndef MINIZ_NO_STDIO
-// Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive.
-// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
-mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
-#endif
-
-// Adds a file to an archive by fully cloning the data from another archive.
-// This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data, and comment fields.
-mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint file_index);
-
-// Finalizes the archive by writing the central directory records followed by the end of central directory record.
-// After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end().
-// An archive must be manually finalized by calling this function for it to be valid.
-mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);
-mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf, size_t *pSize);
-
-// Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used.
-// Note for the archive to be valid, it must have been finalized before ending.
-mz_bool mz_zip_writer_end(mz_zip_archive *pZip);
-
-// Misc. high-level helper functions:
-
-// mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive.
-// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
-mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
-
-// Reads a single file from an archive into a heap block.
-// Returns NULL on failure.
-void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint zip_flags);
-
-#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-
-#endif // #ifndef MINIZ_NO_ARCHIVE_APIS
-
-// ------------------- Low-level Decompression API Definitions
-
-// Decompression flags used by tinfl_decompress().
-// TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream.
-// TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input.
-// TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB).
-// TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes.
-enum
-{
-  TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
-  TINFL_FLAG_HAS_MORE_INPUT = 2,
-  TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
-  TINFL_FLAG_COMPUTE_ADLER32 = 8
-};
-
-// High level decompression functions:
-// tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc().
-// On entry:
-//  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress.
-// On return:
-//  Function returns a pointer to the decompressed data, or NULL on failure.
-//  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data.
-//  The caller must call mz_free() on the returned block when it's no longer needed.
-void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, UInt32 flags);
-
-// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory.
-// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success.
-#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
-size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, UInt32 flags);
-
-// tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer.
-// Returns 1 on success or 0 on failure.
-typedef UInt32 (*tinfl_put_buf_func_ptr)(const void* pBuf, UInt32 len, void *pUser);
-UInt32 tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, UInt32 flags);
-
-struct tinfl_decompressor_tag; typedef struct tinfl_decompressor_tag tinfl_decompressor;
-
-// Max size of LZ dictionary.
-#define TINFL_LZ_DICT_SIZE 32768
-
-// Return status.
-typedef enum
-{
-  TINFL_STATUS_BAD_PARAM = -3,
-  TINFL_STATUS_ADLER32_MISMATCH = -2,
-  TINFL_STATUS_FAILED = -1,
-  TINFL_STATUS_DONE = 0,
-  TINFL_STATUS_NEEDS_MORE_INPUT = 1,
-  TINFL_STATUS_HAS_MORE_OUTPUT = 2
-} tinfl_status;
-
-// Initializes the decompressor to its initial state.
-#define tinfl_init(r) do { (r)->m_state = 0; } MZ_MACRO_END
-#define tinfl_get_adler32(r) (r)->m_check_adler32
-
-// Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability.
-// This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output.
-tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags);
-
-// Internal/private bits follow.
-enum
-{
-  TINFL_MAX_HUFF_TABLES = 3, TINFL_MAX_HUFF_SYMBOLS_0 = 288, TINFL_MAX_HUFF_SYMBOLS_1 = 32, TINFL_MAX_HUFF_SYMBOLS_2 = 19,
-  TINFL_FAST_LOOKUP_BITS = 10, TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
-};
-
-typedef struct
-{
-  mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];
-  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE], m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
-} tinfl_huff_table;
-
-#if MINIZ_HAS_64BIT_REGISTERS
-  #define TINFL_USE_64BIT_BITBUF 1
-#endif
-
-#if TINFL_USE_64BIT_BITBUF
-  typedef mz_uint64 tinfl_bit_buf_t;
-  #define TINFL_BITBUF_SIZE (64)
-#else
-  typedef mz_uint32 tinfl_bit_buf_t;
-  #define TINFL_BITBUF_SIZE (32)
-#endif
-
-struct tinfl_decompressor_tag
-{
-  mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];
-  tinfl_bit_buf_t m_bit_buf;
-  size_t m_dist_from_out_buf_start;
-  tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];
-  mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
-};
-
-
-#ifndef MINIZ_NO_COMPRESSION
-// ------------------- Low-level Compression API Definitions
-
-// Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently).
-#define TDEFL_LESS_MEMORY 0
-
-// tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search):
-// TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression).
-enum
-{
-  TDEFL_HUFFMAN_ONLY = 0, TDEFL_DEFAULT_MAX_PROBES = 128, TDEFL_MAX_PROBES_MASK = 0xFFF
-};
-
-// TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data.
-// TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers).
-// TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing.
-// TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory).
-// TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)
-// TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled.
-// TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.
-// TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.
-// The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK).
-enum
-{
-  TDEFL_WRITE_ZLIB_HEADER             = 0x01000,
-  TDEFL_COMPUTE_ADLER32               = 0x02000,
-  TDEFL_GREEDY_PARSING_FLAG           = 0x04000,
-  TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
-  TDEFL_RLE_MATCHES                   = 0x10000,
-  TDEFL_FILTER_MATCHES                = 0x20000,
-  TDEFL_FORCE_ALL_STATIC_BLOCKS       = 0x40000,
-  TDEFL_FORCE_ALL_RAW_BLOCKS          = 0x80000
-};
-
-// High level compression functions:
-// tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc().
-// On entry:
-//  pSrc_buf, src_buf_len: Pointer and size of source block to compress.
-//  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression.
-// On return:
-//  Function returns a pointer to the compressed data, or NULL on failure.
-//  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data.
-//  The caller must free() the returned block when it's no longer needed.
-void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, UInt32 flags);
-
-// tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory.
-// Returns 0 on failure.
-size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, UInt32 flags);
-
-// Compresses an image to a compressed PNG file in memory.
-// On entry:
-//  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. 
-//  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory.
-//  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL
-//  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps).
-// On return:
-//  Function returns a pointer to the compressed data, or NULL on failure.
-//  *pLen_out will be set to the size of the PNG image file.
-//  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed.
-void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, UInt32 w, UInt32 h, UInt32 num_chans, size_t *pLen_out, mz_uint level, mz_bool flip);
-void *tdefl_write_image_to_png_file_in_memory(const void *pImage, UInt32 w, UInt32 h, UInt32 num_chans, size_t *pLen_out);
-
-// Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time.
-typedef mz_bool (*tdefl_put_buf_func_ptr)(const void* pBuf, UInt32 len, void *pUser);
-
-// tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally.
-mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, UInt32 flags);
-
-enum { TDEFL_MAX_HUFF_TABLES = 3, TDEFL_MAX_HUFF_SYMBOLS_0 = 288, TDEFL_MAX_HUFF_SYMBOLS_1 = 32, TDEFL_MAX_HUFF_SYMBOLS_2 = 19, TDEFL_LZ_DICT_SIZE = 32768, TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1, TDEFL_MIN_MATCH_LEN = 3, TDEFL_MAX_MATCH_LEN = 258 };
-
-// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes).
-#if TDEFL_LESS_MEMORY
-enum { TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024, TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13 ) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 12, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3, TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS };
-#else
-enum { TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024, TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13 ) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 15, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3, TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS };
-#endif
-
-// The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions.
-typedef enum
-{
-  TDEFL_STATUS_BAD_PARAM = -2,
-  TDEFL_STATUS_PUT_BUF_FAILED = -1,
-  TDEFL_STATUS_OKAY = 0,
-  TDEFL_STATUS_DONE = 1,
-} tdefl_status;
-
-// Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums
-typedef enum
-{
-  TDEFL_NO_FLUSH = 0,
-  TDEFL_SYNC_FLUSH = 2,
-  TDEFL_FULL_FLUSH = 3,
-  TDEFL_FINISH = 4
-} tdefl_flush;
-
-// tdefl's compression state structure.
-typedef struct
-{
-  tdefl_put_buf_func_ptr m_pPut_buf_func;
-  void *m_pPut_buf_user;
-  mz_uint m_flags, m_max_probes[2];
-  UInt32 m_greedy_parsing;
-  mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
-  mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
-  mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;
-  mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;
-  tdefl_status m_prev_return_status;
-  const void *m_pIn_buf;
-  void *m_pOut_buf;
-  size_t *m_pIn_buf_size, *m_pOut_buf_size;
-  tdefl_flush m_flush;
-  const mz_uint8 *m_pSrc;
-  size_t m_src_buf_left, m_out_buf_ofs;
-  mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
-  mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
-  mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
-  mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
-  mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
-  mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
-  mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
-  mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
-} tdefl_compressor;
-
-// Initializes the compressor.
-// There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory.
-// pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression.
-// If pBut_buf_func is NULL the user should always call the tdefl_compress() API.
-// flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.)
-tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, UInt32 flags);
-
-// Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible.
-tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);
-
-// tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr.
-// tdefl_compress_buffer() always consumes the entire input buffer.
-tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);
-
-tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
-mz_uint32 tdefl_get_adler32(tdefl_compressor *d);
-
-// Can't use tdefl_create_comp_flags_from_zip_params if MINIZ_NO_ZLIB_APIS isn't defined, because it uses some of its macros.
-#ifndef MINIZ_NO_ZLIB_APIS
-// Create tdefl_compress() flags given zlib-style compression parameters.
-// level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files)
-// window_bits may be -15 (raw deflate) or 15 (zlib)
-// strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED
-mz_uint tdefl_create_comp_flags_from_zip_params(UInt32 level, UInt32 window_bits, UInt32 strategy);
-#endif // #ifndef MINIZ_NO_ZLIB_APIS
-
-#endif // MINIZ_NO_COMPRESSION
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // MINIZ_HEADER_INCLUDED
-
-// ------------------- End of Header: Implementation follows. (If you only want the header, define MINIZ_HEADER_FILE_ONLY.)
-
-#ifndef MINIZ_HEADER_FILE_ONLY
-
-typedef unsigned char mz_validate_uint16[sizeof(mz_uint16)==2 ? 1 : -1];
-typedef unsigned char mz_validate_uint32[sizeof(mz_uint32)==4 ? 1 : -1];
-typedef unsigned char mz_validate_uint64[sizeof(mz_uint64)==8 ? 1 : -1];
-
-#include <string.h>
-#include <assert.h>
-
-#define MZ_ASSERT(x) assert(x)
-
-#ifdef MINIZ_NO_MALLOC
-  #define MZ_MALLOC(x) NULL
-  #define MZ_FREE(x) (void)x, ((void)0)
-  #define MZ_REALLOC(p, x) NULL
-#else
-  #define MZ_MALLOC(x) malloc(x)
-  #define MZ_FREE(x) free(x)
-  #define MZ_REALLOC(p, x) realloc(p, x)
-#endif
-
-#define MZ_MAX(a,b) (((a)>(b))?(a):(b))
-#define MZ_MIN(a,b) (((a)<(b))?(a):(b))
-#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))
-
-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-  #define MZ_READ_LE16(p) *((const mz_uint16 *)(p))
-  #define MZ_READ_LE32(p) *((const mz_uint32 *)(p))
-#else
-  #define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))
-  #define MZ_READ_LE32(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) | ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))
-#endif
-
-#ifdef _MSC_VER
-  #define MZ_FORCEINLINE __forceinline
-#elif defined(__GNUC__)
-  #define MZ_FORCEINLINE inline __attribute__((__always_inline__))
-#else
-  #define MZ_FORCEINLINE inline
-#endif
-
-#ifdef __cplusplus
-  extern "C" {
-#endif
-
-// ------------------- zlib-style API's
-
-mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)
-{
-  mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16); size_t block_len = buf_len % 5552;
-  if (!ptr) return MZ_ADLER32_INIT;
-  while (buf_len) {
-    for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
-      s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;
-      s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;
-    }
-    for ( ; i < block_len; ++i) s1 += *ptr++, s2 += s1;
-    s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;
-  }
-  return (s2 << 16) + s1;
-}
-
-// Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/
-mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
-{
-  static const mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
-    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };
-  mz_uint32 crcu32 = (mz_uint32)crc;
-  if (!ptr) return MZ_CRC32_INIT;
-  crcu32 = ~crcu32; while (buf_len--) { mz_uint8 b = *ptr++; crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)]; crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)]; }
-  return ~crcu32;
-}
-
-void mz_free(void *p)
-{
-  MZ_FREE(p);
-}
-
-#ifndef MINIZ_NO_ZLIB_APIS
-
-static void *def_alloc_func(void *opaque, size_t items, size_t size) { (void)opaque, (void)items, (void)size; return MZ_MALLOC(items * size); }
-static void def_free_func(void *opaque, void *address) { (void)opaque, (void)address; MZ_FREE(address); }
-static void *def_realloc_func(void *opaque, void *address, size_t items, size_t size) { (void)opaque, (void)address, (void)items, (void)size; return MZ_REALLOC(address, items * size); }
-
-const char *mz_version(void)
-{
-  return MZ_VERSION;
-}
-
-#ifndef MINIZ_NO_COMPRESSION
-
-UInt32 mz_deflateInit(mz_streamp pStream, UInt32 level)
-{
-  return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9, MZ_DEFAULT_STRATEGY);
-}
-
-UInt32 mz_deflateInit2(mz_streamp pStream, UInt32 level, UInt32 method, UInt32 window_bits, UInt32 mem_level, UInt32 strategy)
-{
-  tdefl_compressor *pComp;
-  mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);
-
-  if (!pStream) return MZ_STREAM_ERROR;
-  if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS))) return MZ_PARAM_ERROR;
-
-  pStream->data_type = 0;
-  pStream->adler = MZ_ADLER32_INIT;
-  pStream->msg = NULL;
-  pStream->reserved = 0;
-  pStream->total_in = 0;
-  pStream->total_out = 0;
-  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;
-  if (!pStream->zfree) pStream->zfree = def_free_func;
-
-  pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1, sizeof(tdefl_compressor));
-  if (!pComp)
-    return MZ_MEM_ERROR;
-
-  pStream->state = (struct mz_internal_state *)pComp;
-
-  if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY)
-  {
-    mz_deflateEnd(pStream);
-    return MZ_PARAM_ERROR;
-  }
-
-  return MZ_OK;
-}
-
-UInt32 mz_deflateReset(mz_streamp pStream)
-{
-  if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree)) return MZ_STREAM_ERROR;
-  pStream->total_in = pStream->total_out = 0;
-  tdefl_init((tdefl_compressor*)pStream->state, NULL, NULL, ((tdefl_compressor*)pStream->state)->m_flags);
-  return MZ_OK;
-}
-
-UInt32 mz_deflate(mz_streamp pStream, UInt32 flush)
-{
-  size_t in_bytes, out_bytes;
-  mz_ulong orig_total_in, orig_total_out;
-  UInt32 mz_status = MZ_OK;
-
-  if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out)) return MZ_STREAM_ERROR;
-  if (!pStream->avail_out) return MZ_BUF_ERROR;
-
-  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
-
-  if (((tdefl_compressor*)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)
-    return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;
-
-  orig_total_in = pStream->total_in; orig_total_out = pStream->total_out;
-  for ( ; ; )
-  {
-    tdefl_status defl_status;
-    in_bytes = pStream->avail_in; out_bytes = pStream->avail_out;
-
-    defl_status = tdefl_compress((tdefl_compressor*)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);
-    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes;
-    pStream->total_in += (mz_uint)in_bytes; pStream->adler = tdefl_get_adler32((tdefl_compressor*)pStream->state);
-
-    pStream->next_out += (mz_uint)out_bytes; pStream->avail_out -= (mz_uint)out_bytes;
-    pStream->total_out += (mz_uint)out_bytes;
-
-    if (defl_status < 0)
-    {
-      mz_status = MZ_STREAM_ERROR;
-      break;
-    }
-    else if (defl_status == TDEFL_STATUS_DONE)
-    {
-      mz_status = MZ_STREAM_END;
-      break;
-    }
-    else if (!pStream->avail_out)
-      break;
-    else if ((!pStream->avail_in) && (flush != MZ_FINISH))
-    {
-      if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out))
-        break;
-      return MZ_BUF_ERROR; // Can't make forward progress without some input.
-    }
-  }
-  return mz_status;
-}
-
-UInt32 mz_deflateEnd(mz_streamp pStream)
-{
-  if (!pStream) return MZ_STREAM_ERROR;
-  if (pStream->state)
-  {
-    pStream->zfree(pStream->opaque, pStream->state);
-    pStream->state = NULL;
-  }
-  return MZ_OK;
-}
-
-mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len)
-{
-  (void)pStream;
-  // This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.)
-  return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
-}
-
-UInt32 mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, UInt32 level)
-{
-  UInt32 status;
-  mz_stream stream;
-  memset(&stream, 0, sizeof(stream));
-
-  // In case mz_ulong is 64-bits (argh I hate longs).
-  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;
-
-  stream.next_in = pSource;
-  stream.avail_in = (mz_uint32)source_len;
-  stream.next_out = pDest;
-  stream.avail_out = (mz_uint32)*pDest_len;
-
-  status = mz_deflateInit(&stream, level);
-  if (status != MZ_OK) return status;
-
-  status = mz_deflate(&stream, MZ_FINISH);
-  if (status != MZ_STREAM_END)
-  {
-    mz_deflateEnd(&stream);
-    return (status == MZ_OK) ? MZ_BUF_ERROR : status;
-  }
-
-  *pDest_len = stream.total_out;
-  return mz_deflateEnd(&stream);
-}
-
-UInt32 mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
-{
-  return mz_compress2(pDest, pDest_len, pSource, source_len, MZ_DEFAULT_COMPRESSION);
-}
-
-mz_ulong mz_compressBound(mz_ulong source_len)
-{
-  return mz_deflateBound(NULL, source_len);
-}
-
-#endif // MINIZ_NO_COMPRESSION
-
-typedef struct
-{
-  tinfl_decompressor m_decomp;
-  mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed; UInt32 m_window_bits;
-  mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];
-  tinfl_status m_last_status;
-} inflate_state;
-
-UInt32 mz_inflateInit2(mz_streamp pStream, UInt32 window_bits)
-{
-  inflate_state *pDecomp;
-  if (!pStream) return MZ_STREAM_ERROR;
-  if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)) return MZ_PARAM_ERROR;
-
-  pStream->data_type = 0;
-  pStream->adler = 0;
-  pStream->msg = NULL;
-  pStream->total_in = 0;
-  pStream->total_out = 0;
-  pStream->reserved = 0;
-  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;
-  if (!pStream->zfree) pStream->zfree = def_free_func;
-
-  pDecomp = (inflate_state*)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state));
-  if (!pDecomp) return MZ_MEM_ERROR;
-
-  pStream->state = (struct mz_internal_state *)pDecomp;
-
-  tinfl_init(&pDecomp->m_decomp);
-  pDecomp->m_dict_ofs = 0;
-  pDecomp->m_dict_avail = 0;
-  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
-  pDecomp->m_first_call = 1;
-  pDecomp->m_has_flushed = 0;
-  pDecomp->m_window_bits = window_bits;
-
-  return MZ_OK;
-}
-
-UInt32 mz_inflateInit(mz_streamp pStream)
-{
-   return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);
-}
-
-UInt32 mz_inflate(mz_streamp pStream, UInt32 flush)
-{
-  inflate_state* pState;
-  mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
-  size_t in_bytes, out_bytes, orig_avail_in;
-  tinfl_status status;
-
-  if ((!pStream) || (!pStream->state)) return MZ_STREAM_ERROR;
-  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
-  if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;
-
-  pState = (inflate_state*)pStream->state;
-  if (pState->m_window_bits > 0) decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
-  orig_avail_in = pStream->avail_in;
-
-  first_call = pState->m_first_call; pState->m_first_call = 0;
-  if (pState->m_last_status < 0) return MZ_DATA_ERROR;
-
-  if (pState->m_has_flushed && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;
-  pState->m_has_flushed |= (flush == MZ_FINISH);
-
-  if ((flush == MZ_FINISH) && (first_call))
-  {
-    // MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire compressed/decompressed file.
-    decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
-    in_bytes = pStream->avail_in; out_bytes = pStream->avail_out;
-    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags);
-    pState->m_last_status = status;
-    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes; pStream->total_in += (mz_uint)in_bytes;
-    pStream->adler = tinfl_get_adler32(&pState->m_decomp);
-    pStream->next_out += (mz_uint)out_bytes; pStream->avail_out -= (mz_uint)out_bytes; pStream->total_out += (mz_uint)out_bytes;
-
-    if (status < 0)
-      return MZ_DATA_ERROR;
-    else if (status != TINFL_STATUS_DONE)
-    {
-      pState->m_last_status = TINFL_STATUS_FAILED;
-      return MZ_BUF_ERROR;
-    }
-    return MZ_STREAM_END;
-  }
-  // flush != MZ_FINISH then we must assume there's more input.
-  if (flush != MZ_FINISH) decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;
-
-  if (pState->m_dict_avail)
-  {
-    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
-    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
-    pStream->next_out += n; pStream->avail_out -= n; pStream->total_out += n;
-    pState->m_dict_avail -= n; pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
-    return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
-  }
-
-  for ( ; ; )
-  {
-    in_bytes = pStream->avail_in;
-    out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;
-
-    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
-    pState->m_last_status = status;
-
-    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes;
-    pStream->total_in += (mz_uint)in_bytes; pStream->adler = tinfl_get_adler32(&pState->m_decomp);
-
-    pState->m_dict_avail = (mz_uint)out_bytes;
-
-    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
-    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
-    pStream->next_out += n; pStream->avail_out -= n; pStream->total_out += n;
-    pState->m_dict_avail -= n; pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
-
-    if (status < 0)
-       return MZ_DATA_ERROR; // Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well).
-    else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
-      return MZ_BUF_ERROR; // Signal caller that we can't make forward progress without supplying more input or by setting flush to MZ_FINISH.
-    else if (flush == MZ_FINISH)
-    {
-       // The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH.
-       if (status == TINFL_STATUS_DONE)
-          return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
-       // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If there's no more room left in the output buffer then something is wrong.
-       else if (!pStream->avail_out)
-          return MZ_BUF_ERROR;
-    }
-    else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))
-      break;
-  }
-
-  return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
-}
-
-UInt32 mz_inflateEnd(mz_streamp pStream)
-{
-  if (!pStream)
-    return MZ_STREAM_ERROR;
-  if (pStream->state)
-  {
-    pStream->zfree(pStream->opaque, pStream->state);
-    pStream->state = NULL;
-  }
-  return MZ_OK;
-}
-
-UInt32 mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
-{
-  mz_stream stream;
-  UInt32 status;
-  memset(&stream, 0, sizeof(stream));
-
-  // In case mz_ulong is 64-bits (argh I hate longs).
-  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;
-
-  stream.next_in = pSource;
-  stream.avail_in = (mz_uint32)source_len;
-  stream.next_out = pDest;
-  stream.avail_out = (mz_uint32)*pDest_len;
-
-  status = mz_inflateInit(&stream);
-  if (status != MZ_OK)
-    return status;
-
-  status = mz_inflate(&stream, MZ_FINISH);
-  if (status != MZ_STREAM_END)
-  {
-    mz_inflateEnd(&stream);
-    return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR : status;
-  }
-  *pDest_len = stream.total_out;
-
-  return mz_inflateEnd(&stream);
-}
-
-const char *mz_error(UInt32 err)
-{
-  static struct { UInt32 m_err; const char *m_pDesc; } s_error_descs[] =
-  {
-    { MZ_OK, "" }, { MZ_STREAM_END, "stream end" }, { MZ_NEED_DICT, "need dictionary" }, { MZ_ERRNO, "file error" }, { MZ_STREAM_ERROR, "stream error" },
-    { MZ_DATA_ERROR, "data error" }, { MZ_MEM_ERROR, "out of memory" }, { MZ_BUF_ERROR, "buf error" }, { MZ_VERSION_ERROR, "version error" }, { MZ_PARAM_ERROR, "parameter error" }
-  };
-  mz_uint i; for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i) if (s_error_descs[i].m_err == err) return s_error_descs[i].m_pDesc;
-  return NULL;
-}
-
-#endif //MINIZ_NO_ZLIB_APIS
-
-// ------------------- Low-level Decompression (completely independent from all compression API's)
-
-#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)
-#define TINFL_MEMSET(p, c, l) memset(p, c, l)
-
-#define TINFL_CR_BEGIN switch(r->m_state) { case 0:
-#define TINFL_CR_RETURN(state_index, result) do { status = result; r->m_state = state_index; goto common_exit; case state_index:; } MZ_MACRO_END
-#define TINFL_CR_RETURN_FOREVER(state_index, result) do { for ( ; ; ) { TINFL_CR_RETURN(state_index, result); } } MZ_MACRO_END
-#define TINFL_CR_FINISH }
-
-// TODO: If the caller has indicated that there's no more input, and we attempt to read beyond the input buf, then something is wrong with the input because the inflator never
-// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of the stream with 0's in this scenario.
-#define TINFL_GET_BYTE(state_index, c) do { \
-  if (pIn_buf_cur >= pIn_buf_end) { \
-    for ( ; ; ) { \
-      if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) { \
-        TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT); \
-        if (pIn_buf_cur < pIn_buf_end) { \
-          c = *pIn_buf_cur++; \
-          break; \
-        } \
-      } else { \
-        c = 0; \
-        break; \
-      } \
-    } \
-  } else c = *pIn_buf_cur++; } MZ_MACRO_END
-
-#define TINFL_NEED_BITS(state_index, n) do { mz_uint c; TINFL_GET_BYTE(state_index, c); bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); num_bits += 8; } while (num_bits < (mz_uint)(n))
-#define TINFL_SKIP_BITS(state_index, n) do { if (num_bits < (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } bit_buf >>= (n); num_bits -= (n); } MZ_MACRO_END
-#define TINFL_GET_BITS(state_index, b, n) do { if (num_bits < (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } b = bit_buf & ((1 << (n)) - 1); bit_buf >>= (n); num_bits -= (n); } MZ_MACRO_END
-
-// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2.
-// It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a
-// Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the
-// bit buffer contains >=15 bits (deflate's max. Huffman code size).
-#define TINFL_HUFF_BITBUF_FILL(state_index, pHuff) \
-  do { \
-    temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]; \
-    if (temp >= 0) { \
-      code_len = temp >> 9; \
-      if ((code_len) && (num_bits >= code_len)) \
-      break; \
-    } else if (num_bits > TINFL_FAST_LOOKUP_BITS) { \
-       code_len = TINFL_FAST_LOOKUP_BITS; \
-       do { \
-          temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; \
-       } while ((temp < 0) && (num_bits >= (code_len + 1))); if (temp >= 0) break; \
-    } TINFL_GET_BYTE(state_index, c); bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); num_bits += 8; \
-  } while (num_bits < 15);
-
-// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read
-// beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully
-// decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32.
-// The slow path is only executed at the very end of the input buffer.
-#define TINFL_HUFF_DECODE(state_index, sym, pHuff) do { \
-  UInt32 temp; mz_uint code_len, c; \
-  if (num_bits < 15) { \
-    if ((pIn_buf_end - pIn_buf_cur) < 2) { \
-       TINFL_HUFF_BITBUF_FILL(state_index, pHuff); \
-    } else { \
-       bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8)); pIn_buf_cur += 2; num_bits += 16; \
-    } \
-  } \
-  if ((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0) \
-    code_len = temp >> 9, temp &= 511; \
-  else { \
-    code_len = TINFL_FAST_LOOKUP_BITS; do { temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; } while (temp < 0); \
-  } sym = temp; bit_buf >>= code_len; num_bits -= code_len; } MZ_MACRO_END
-
-tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)
-{
-  static const Int32 s_length_base[31] = { 3,4,5,6,7,8,9,10,11,13, 15,17,19,23,27,31,35,43,51,59, 67,83,99,115,131,163,195,227,258,0,0 };
-  static const Int32 s_length_extra[31]= { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
-  static const Int32 s_dist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193, 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
-  static const Int32 s_dist_extra[32] = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
-  static const mz_uint8 s_length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
-  static const Int32 s_min_table_sizes[3] = { 257, 1, 4 };
-
-  tinfl_status status = TINFL_STATUS_FAILED; mz_uint32 num_bits, dist, counter, num_extra; tinfl_bit_buf_t bit_buf;
-  const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
-  mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end = pOut_buf_next + *pOut_buf_size;
-  size_t out_buf_size_mask = (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1, dist_from_out_buf_start;
-
-  // Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter).
-  if (((out_buf_size_mask + 1) & out_buf_size_mask) || (pOut_buf_next < pOut_buf_start)) { *pIn_buf_size = *pOut_buf_size = 0; return TINFL_STATUS_BAD_PARAM; }
-
-  num_bits = r->m_num_bits; bit_buf = r->m_bit_buf; dist = r->m_dist; counter = r->m_counter; num_extra = r->m_num_extra; dist_from_out_buf_start = r->m_dist_from_out_buf_start;
-  TINFL_CR_BEGIN
-
-  bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0; r->m_z_adler32 = r->m_check_adler32 = 1;
-  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
-  {
-    TINFL_GET_BYTE(1, r->m_zhdr0); TINFL_GET_BYTE(2, r->m_zhdr1);
-    counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));
-    if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) || ((out_buf_size_mask + 1) < (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))));
-    if (counter) { TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED); }
-  }
-
-  do
-  {
-    TINFL_GET_BITS(3, r->m_final, 3); r->m_type = r->m_final >> 1;
-    if (r->m_type == 0)
-    {
-      TINFL_SKIP_BITS(5, num_bits & 7);
-      for (counter = 0; counter < 4; ++counter) { if (num_bits) TINFL_GET_BITS(6, r->m_raw_header[counter], 8); else TINFL_GET_BYTE(7, r->m_raw_header[counter]); }
-      if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8)))) { TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED); }
-      while ((counter) && (num_bits))
-      {
-        TINFL_GET_BITS(51, dist, 8);
-        while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT); }
-        *pOut_buf_cur++ = (mz_uint8)dist;
-        counter--;
-      }
-      while (counter)
-      {
-        size_t n; while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT); }
-        while (pIn_buf_cur >= pIn_buf_end)
-        {
-          if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT)
-          {
-            TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);
-          }
-          else
-          {
-            TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);
-          }
-        }
-        n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter);
-        TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n); pIn_buf_cur += n; pOut_buf_cur += n; counter -= (mz_uint)n;
-      }
-    }
-    else if (r->m_type == 3)
-    {
-      TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);
-    }
-    else
-    {
-      if (r->m_type == 1)
-      {
-        mz_uint8 *p = r->m_tables[0].m_code_size; mz_uint i;
-        r->m_table_sizes[0] = 288; r->m_table_sizes[1] = 32; TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32);
-        for ( i = 0; i <= 143; ++i) *p++ = 8; for ( ; i <= 255; ++i) *p++ = 9; for ( ; i <= 279; ++i) *p++ = 7; for ( ; i <= 287; ++i) *p++ = 8;
-      }
-      else
-      {
-        for (counter = 0; counter < 3; counter++) { TINFL_GET_BITS(11, r->m_table_sizes[counter], "\05\05\04"[counter]); r->m_table_sizes[counter] += s_min_table_sizes[counter]; }
-        MZ_CLEAR_OBJ(r->m_tables[2].m_code_size); for (counter = 0; counter < r->m_table_sizes[2]; counter++) { mz_uint s; TINFL_GET_BITS(14, s, 3); r->m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s; }
-        r->m_table_sizes[2] = 19;
-      }
-      for ( ; (Int32)r->m_type >= 0; r->m_type--)
-      {
-        Int32 tree_next, tree_cur; tinfl_huff_table *pTable;
-        mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16]; pTable = &r->m_tables[r->m_type]; MZ_CLEAR_OBJ(total_syms); MZ_CLEAR_OBJ(pTable->m_look_up); MZ_CLEAR_OBJ(pTable->m_tree);
-        for (i = 0; i < r->m_table_sizes[r->m_type]; ++i) total_syms[pTable->m_code_size[i]]++;
-        used_syms = 0, total = 0; next_code[0] = next_code[1] = 0;
-        for (i = 1; i <= 15; ++i) { used_syms += total_syms[i]; next_code[i + 1] = (total = ((total + total_syms[i]) << 1)); }
-        if ((65536 != total) && (used_syms > 1))
-        {
-          TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);
-        }
-        for (tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index)
-        {
-          mz_uint rev_code = 0, l, cur_code, code_size = pTable->m_code_size[sym_index]; if (!code_size) continue;
-          cur_code = next_code[code_size]++; for (l = code_size; l > 0; l--, cur_code >>= 1) rev_code = (rev_code << 1) | (cur_code & 1);
-          if (code_size <= TINFL_FAST_LOOKUP_BITS) { mz_int16 k = (mz_int16)((code_size << 9) | sym_index); while (rev_code < TINFL_FAST_LOOKUP_SIZE) { pTable->m_look_up[rev_code] = k; rev_code += (1 << code_size); } continue; }
-          if (0 == (tree_cur = pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)])) { pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; }
-          rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);
-          for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--)
-          {
-            tree_cur -= ((rev_code >>= 1) & 1);
-            if (!pTable->m_tree[-tree_cur - 1]) { pTable->m_tree[-tree_cur - 1] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; } else tree_cur = pTable->m_tree[-tree_cur - 1];
-          }
-          tree_cur -= ((rev_code >>= 1) & 1); pTable->m_tree[-tree_cur - 1] = (mz_int16)sym_index;
-        }
-        if (r->m_type == 2)
-        {
-          for (counter = 0; counter < (r->m_table_sizes[0] + r->m_table_sizes[1]); )
-          {
-            mz_uint s; TINFL_HUFF_DECODE(16, dist, &r->m_tables[2]); if (dist < 16) { r->m_len_codes[counter++] = (mz_uint8)dist; continue; }
-            if ((dist == 16) && (!counter))
-            {
-              TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);
-            }
-            num_extra = "\02\03\07"[dist - 16]; 
-            TINFL_GET_BITS(18, s, num_extra); 
-            s += "\03\03\013"[dist - 16];
-            TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s);
-            counter += s;
-          }
-          if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter)
-          {
-            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);
-          }
-          TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes, r->m_table_sizes[0]); TINFL_MEMCPY(r->m_tables[1].m_code_size, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1]);
-        }
-      }
-      for ( ; ; )
-      {
-        mz_uint8 *pSrc;
-        for ( ; ; )
-        {
-          if (((pIn_buf_end - pIn_buf_cur) < 4) || ((pOut_buf_end - pOut_buf_cur) < 2))
-          {
-            TINFL_HUFF_DECODE(23, counter, &r->m_tables[0]);
-            if (counter >= 256)
-              break;
-            while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT); }
-            *pOut_buf_cur++ = (mz_uint8)counter;
-          }
-          else
-          {
-            Int32 sym2; mz_uint code_len;
-#if TINFL_USE_64BIT_BITBUF
-            if (num_bits < 30) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits); pIn_buf_cur += 4; num_bits += 32; }
-#else
-            if (num_bits < 15) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits); pIn_buf_cur += 2; num_bits += 16; }
-#endif
-            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
-              code_len = sym2 >> 9;
-            else
-            {
-              code_len = TINFL_FAST_LOOKUP_BITS; do { sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)]; } while (sym2 < 0);
-            }
-            counter = sym2; bit_buf >>= code_len; num_bits -= code_len;
-            if (counter & 256)
-              break;
-
-#if !TINFL_USE_64BIT_BITBUF
-            if (num_bits < 15) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits); pIn_buf_cur += 2; num_bits += 16; }
-#endif
-            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
-              code_len = sym2 >> 9;
-            else
-            {
-              code_len = TINFL_FAST_LOOKUP_BITS; do { sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)]; } while (sym2 < 0);
-            }
-            bit_buf >>= code_len; num_bits -= code_len;
-
-            pOut_buf_cur[0] = (mz_uint8)counter;
-            if (sym2 & 256)
-            {
-              pOut_buf_cur++;
-              counter = sym2;
-              break;
-            }
-            pOut_buf_cur[1] = (mz_uint8)sym2;
-            pOut_buf_cur += 2;
-          }
-        }
-        if ((counter &= 511) == 256) break;
-
-        num_extra = s_length_extra[counter - 257]; counter = s_length_base[counter - 257];
-        if (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(25, extra_bits, num_extra); counter += extra_bits; }
-
-        TINFL_HUFF_DECODE(26, dist, &r->m_tables[1]);
-        num_extra = s_dist_extra[dist]; dist = s_dist_base[dist];
-        if (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(27, extra_bits, num_extra); dist += extra_bits; }
-
-        dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;
-        if ((dist > dist_from_out_buf_start) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
-        {
-          TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);
-        }
-
-        pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) & out_buf_size_mask);
-
-        if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end)
-        {
-          while (counter--)
-          {
-            while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT); }
-            *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) & out_buf_size_mask];
-          }
-          continue;
-        }
-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
-        else if ((counter >= 9) && (counter <= dist))
-        {
-          const mz_uint8 *pSrc_end = pSrc + (counter & ~7);
-          do
-          {
-            ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];
-            ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];
-            pOut_buf_cur += 8;
-          } while ((pSrc += 8) < pSrc_end);
-          if ((counter &= 7) < 3)
-          {
-            if (counter)
-            {
-              pOut_buf_cur[0] = pSrc[0];
-              if (counter > 1)
-                pOut_buf_cur[1] = pSrc[1];
-              pOut_buf_cur += counter;
-            }
-            continue;
-          }
-        }
-#endif
-        do
-        {
-          pOut_buf_cur[0] = pSrc[0];
-          pOut_buf_cur[1] = pSrc[1];
-          pOut_buf_cur[2] = pSrc[2];
-          pOut_buf_cur += 3; pSrc += 3;
-        } while ((Int32)(counter -= 3) > 2);
-        if ((Int32)counter > 0)
-        {
-          pOut_buf_cur[0] = pSrc[0];
-          if ((Int32)counter > 1)
-            pOut_buf_cur[1] = pSrc[1];
-          pOut_buf_cur += counter;
-        }
-      }
-    }
-  } while (!(r->m_final & 1));
-  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
-  {
-    TINFL_SKIP_BITS(32, num_bits & 7); for (counter = 0; counter < 4; ++counter) { mz_uint s; if (num_bits) TINFL_GET_BITS(41, s, 8); else TINFL_GET_BYTE(42, s); r->m_z_adler32 = (r->m_z_adler32 << 8) | s; }
-  }
-  TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);
-  TINFL_CR_FINISH
-
-common_exit:
-  r->m_num_bits = num_bits; r->m_bit_buf = bit_buf; r->m_dist = dist; r->m_counter = counter; r->m_num_extra = num_extra; r->m_dist_from_out_buf_start = dist_from_out_buf_start;
-  *pIn_buf_size = pIn_buf_cur - pIn_buf_next; *pOut_buf_size = pOut_buf_cur - pOut_buf_next;
-  if ((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0))
-  {
-    const mz_uint8 *ptr = pOut_buf_next; size_t buf_len = *pOut_buf_size;
-    mz_uint32 i, s1 = r->m_check_adler32 & 0xffff, s2 = r->m_check_adler32 >> 16; size_t block_len = buf_len % 5552;
-    while (buf_len)
-    {
-      for (i = 0; i + 7 < block_len; i += 8, ptr += 8)
-      {
-        s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;
-        s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;
-      }
-      for ( ; i < block_len; ++i) s1 += *ptr++, s2 += s1;
-      s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;
-    }
-    r->m_check_adler32 = (s2 << 16) + s1; if ((status == TINFL_STATUS_DONE) && (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) && (r->m_check_adler32 != r->m_z_adler32)) status = TINFL_STATUS_ADLER32_MISMATCH;
-  }
-  return status;
-}
-
-// Higher level helper functions.
-void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, UInt32 flags)
-{
-  tinfl_decompressor decomp; void *pBuf = NULL, *pNew_buf; size_t src_buf_ofs = 0, out_buf_capacity = 0;
-  *pOut_len = 0;
-  tinfl_init(&decomp);
-  for ( ; ; )
-  {
-    size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
-    tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8*)pBuf, pBuf ? (mz_uint8*)pBuf + *pOut_len : NULL, &dst_buf_size,
-      (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
-    if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))
-    {
-      MZ_FREE(pBuf); *pOut_len = 0; return NULL;
-    }
-    src_buf_ofs += src_buf_size;
-    *pOut_len += dst_buf_size;
-    if (status == TINFL_STATUS_DONE) break;
-    new_out_buf_capacity = out_buf_capacity * 2; if (new_out_buf_capacity < 128) new_out_buf_capacity = 128;
-    pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
-    if (!pNew_buf)
-    {
-      MZ_FREE(pBuf); *pOut_len = 0; return NULL;
-    }
-    pBuf = pNew_buf; out_buf_capacity = new_out_buf_capacity;
-  }
-  return pBuf;
-}
-
-size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, UInt32 flags)
-{
-  tinfl_decompressor decomp; tinfl_status status; tinfl_init(&decomp);
-  status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf, &src_buf_len, (mz_uint8*)pOut_buf, (mz_uint8*)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
-  return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;
-}
-
-UInt32 tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, UInt32 flags)
-{
-  UInt32 result = 0;
-  tinfl_decompressor decomp;
-  mz_uint8 *pDict = (mz_uint8*)MZ_MALLOC(TINFL_LZ_DICT_SIZE); size_t in_buf_ofs = 0, dict_ofs = 0;
-  if (!pDict)
-    return TINFL_STATUS_FAILED;
-  tinfl_init(&decomp);
-  for ( ; ; )
-  {
-    size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
-    tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,
-      (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
-    in_buf_ofs += in_buf_size;
-    if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (UInt32)dst_buf_size, pPut_buf_user)))
-      break;
-    if (status != TINFL_STATUS_HAS_MORE_OUTPUT)
-    {
-      result = (status == TINFL_STATUS_DONE);
-      break;
-    }
-    dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
-  }
-  MZ_FREE(pDict);
-  *pIn_buf_size = in_buf_ofs;
-  return result;
-}
-
-#ifndef MINIZ_NO_COMPRESSION
-// ------------------- Low-level Compression (independent from all decompression API's)
-
-// Purposely making these tables static for faster init and thread safety.
-static const mz_uint16 s_tdefl_len_sym[256] = {
-  257,258,259,260,261,262,263,264,265,265,266,266,267,267,268,268,269,269,269,269,270,270,270,270,271,271,271,271,272,272,272,272,
-  273,273,273,273,273,273,273,273,274,274,274,274,274,274,274,274,275,275,275,275,275,275,275,275,276,276,276,276,276,276,276,276,
-  277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,
-  279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,
-  281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,
-  282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,
-  283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,
-  284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,285 };
-
-static const mz_uint8 s_tdefl_len_extra[256] = {
-  0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
-  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
-  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0 };
-
-static const mz_uint8 s_tdefl_small_dist_sym[512] = {
-  0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,
-  11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,
-  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,
-  14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
-  14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
-  15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,
-  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
-  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
-  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
-  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
-  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
-  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17 };
-
-static const mz_uint8 s_tdefl_small_dist_extra[512] = {
-  0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,
-  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-  7,7,7,7,7,7,7,7 };
-
-static const mz_uint8 s_tdefl_large_dist_sym[128] = {
-  0,0,18,19,20,20,21,21,22,22,22,22,23,23,23,23,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,
-  26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,
-  28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29 };
-
-static const mz_uint8 s_tdefl_large_dist_extra[128] = {
-  0,0,8,8,9,9,9,9,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
-  12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
-  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13 };
-
-// Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values.
-typedef struct { mz_uint16 m_key, m_sym_index; } tdefl_sym_freq;
-static tdefl_sym_freq* tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq* pSyms0, tdefl_sym_freq* pSyms1)
-{
-  mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2]; tdefl_sym_freq* pCur_syms = pSyms0, *pNew_syms = pSyms1; MZ_CLEAR_OBJ(hist);
-  for (i = 0; i < num_syms; i++) { mz_uint freq = pSyms0[i].m_key; hist[freq & 0xFF]++; hist[256 + ((freq >> 8) & 0xFF)]++; }
-  while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256])) total_passes--;
-  for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)
-  {
-    const mz_uint32* pHist = &hist[pass << 8];
-    mz_uint offsets[256], cur_ofs = 0;
-    for (i = 0; i < 256; i++) { offsets[i] = cur_ofs; cur_ofs += pHist[i]; }
-    for (i = 0; i < num_syms; i++) pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
-    { tdefl_sym_freq* t = pCur_syms; pCur_syms = pNew_syms; pNew_syms = t; }
-  }
-  return pCur_syms;
-}
-
-// tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.
-static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, UInt32 n)
-{
-  UInt32 root, leaf, next, avbl, used, dpth;
-  if (n==0) return; else if (n==1) { A[0].m_key = 1; return; }
-  A[0].m_key += A[1].m_key; root = 0; leaf = 2;
-  for (next=1; next < n-1; next++)
-  {
-    if (leaf>=n || A[root].m_key<A[leaf].m_key) { A[next].m_key = A[root].m_key; A[root++].m_key = (mz_uint16)next; } else A[next].m_key = A[leaf++].m_key;
-    if (leaf>=n || (root<next && A[root].m_key<A[leaf].m_key)) { A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key); A[root++].m_key = (mz_uint16)next; } else A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);
-  }
-  A[n-2].m_key = 0; for (next=n-3; next>=0; next--) A[next].m_key = A[A[next].m_key].m_key+1;
-  avbl = 1; used = dpth = 0; root = n-2; next = n-1;
-  while (avbl>0)
-  {
-    while (root>=0 && (UInt32)A[root].m_key==dpth) { used++; root--; }
-    while (avbl>used) { A[next--].m_key = (mz_uint16)(dpth); avbl--; }
-    avbl = 2*used; dpth++; used = 0;
-  }
-}
-
-// Limits canonical Huffman code table's max code size.
-enum { TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32 };
-static void tdefl_huffman_enforce_max_code_size(UInt32 *pNum_codes, UInt32 code_list_len, UInt32 max_code_size)
-{
-  UInt32 i; mz_uint32 total = 0; if (code_list_len <= 1) return;
-  for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++) pNum_codes[max_code_size] += pNum_codes[i];
-  for (i = max_code_size; i > 0; i--) total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));
-  while (total != (1UL << max_code_size))
-  {
-    pNum_codes[max_code_size]--;
-    for (i = max_code_size - 1; i > 0; i--) if (pNum_codes[i]) { pNum_codes[i]--; pNum_codes[i + 1] += 2; break; }
-    total--;
-  }
-}
-
-static void tdefl_optimize_huffman_table(tdefl_compressor *d, UInt32 table_num, UInt32 table_len, UInt32 code_size_limit, UInt32 static_table)
-{
-  UInt32 i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE]; mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1]; MZ_CLEAR_OBJ(num_codes);
-  if (static_table)
-  {
-    for (i = 0; i < table_len; i++) num_codes[d->m_huff_code_sizes[table_num][i]]++;
-  }
-  else
-  {
-    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;
-    UInt32 num_used_syms = 0;
-    const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];
-    for (i = 0; i < table_len; i++) if (pSym_count[i]) { syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i]; syms0[num_used_syms++].m_sym_index = (mz_uint16)i; }
-
-    pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1); tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);
-
-    for (i = 0; i < num_used_syms; i++) num_codes[pSyms[i].m_key]++;
-
-    tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);
-
-    MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num]); MZ_CLEAR_OBJ(d->m_huff_codes[table_num]);
-    for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
-      for (l = num_codes[i]; l > 0; l--) d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);
-  }
-
-  next_code[1] = 0; for (j = 0, i = 2; i <= code_size_limit; i++) next_code[i] = j = ((j + num_codes[i - 1]) << 1);
-
-  for (i = 0; i < table_len; i++)
-  {
-    mz_uint rev_code = 0, code, code_size; if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0) continue;
-    code = next_code[code_size]++; for (l = code_size; l > 0; l--, code >>= 1) rev_code = (rev_code << 1) | (code & 1);
-    d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
-  }
-}
-
-#define TDEFL_PUT_BITS(b, l) do { \
-  mz_uint bits = b; mz_uint len = l; MZ_ASSERT(bits <= ((1U << len) - 1U)); \
-  d->m_bit_buffer |= (bits << d->m_bits_in); d->m_bits_in += len; \
-  while (d->m_bits_in >= 8) { \
-    if (d->m_pOutput_buf < d->m_pOutput_buf_end) \
-      *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \
-      d->m_bit_buffer >>= 8; \
-      d->m_bits_in -= 8; \
-  } \
-} MZ_MACRO_END
-
-#define TDEFL_RLE_PREV_CODE_SIZE() { if (rle_repeat_count) { \
-  if (rle_repeat_count < 3) { \
-    d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
-    while (rle_repeat_count--) packed_code_sizes[num_packed_code_sizes++] = prev_code_size; \
-  } else { \
-    d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1); packed_code_sizes[num_packed_code_sizes++] = 16; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3); \
-} rle_repeat_count = 0; } }
-
-#define TDEFL_RLE_ZERO_CODE_SIZE() { if (rle_z_count) { \
-  if (rle_z_count < 3) { \
-    d->m_huff_count[2][0] = (mz_uint16)(d->m_huff_count[2][0] + rle_z_count); while (rle_z_count--) packed_code_sizes[num_packed_code_sizes++] = 0; \
-  } else if (rle_z_count <= 10) { \
-    d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1); packed_code_sizes[num_packed_code_sizes++] = 17; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3); \
-  } else { \
-    d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1); packed_code_sizes[num_packed_code_sizes++] = 18; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \
-} rle_z_count = 0; } }
-
-static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
-
-static void tdefl_start_dynamic_block(tdefl_compressor *d)
-{
-  UInt32 num_lit_codes, num_dist_codes, num_bit_lengths; mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;
-  mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;
-
-  d->m_huff_count[0][256] = 1;
-
-  tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);
-  tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);
-
-  for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--) if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;
-  for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--) if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;
-
-  memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
-  memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);
-  total_code_sizes_to_pack = num_lit_codes + num_dist_codes; num_packed_code_sizes = 0; rle_z_count = 0; rle_repeat_count = 0;
-
-  memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);
-  for (i = 0; i < total_code_sizes_to_pack; i++)
-  {
-    mz_uint8 code_size = code_sizes_to_pack[i];
-    if (!code_size)
-    {
-      TDEFL_RLE_PREV_CODE_SIZE();
-      if (++rle_z_count == 138) { TDEFL_RLE_ZERO_CODE_SIZE(); }
-    }
-    else
-    {
-      TDEFL_RLE_ZERO_CODE_SIZE();
-      if (code_size != prev_code_size)
-      {
-        TDEFL_RLE_PREV_CODE_SIZE();
-        d->m_huff_count[2][code_size] = (mz_uint16)(d->m_huff_count[2][code_size] + 1); packed_code_sizes[num_packed_code_sizes++] = code_size;
-      }
-      else if (++rle_repeat_count == 6)
-      {
-        TDEFL_RLE_PREV_CODE_SIZE();
-      }
-    }
-    prev_code_size = code_size;
-  }
-  if (rle_repeat_count) { TDEFL_RLE_PREV_CODE_SIZE(); } else { TDEFL_RLE_ZERO_CODE_SIZE(); }
-
-  tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);
-
-  TDEFL_PUT_BITS(2, 2);
-
-  TDEFL_PUT_BITS(num_lit_codes - 257, 5);
-  TDEFL_PUT_BITS(num_dist_codes - 1, 5);
-
-  for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--) if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]]) break;
-  num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1)); TDEFL_PUT_BITS(num_bit_lengths - 4, 4);
-  for (i = 0; (UInt32)i < num_bit_lengths; i++) TDEFL_PUT_BITS(d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);
-
-  for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes; )
-  {
-    mz_uint code = packed_code_sizes[packed_code_sizes_index++]; MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);
-    TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
-    if (code >= 16) TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], "\02\03\07"[code - 16]);
-  }
-}
-
-static void tdefl_start_static_block(tdefl_compressor *d)
-{
-  mz_uint i;
-  mz_uint8 *p = &d->m_huff_code_sizes[0][0];
-
-  for (i = 0; i <= 143; ++i) *p++ = 8;
-  for ( ; i <= 255; ++i) *p++ = 9;
-  for ( ; i <= 279; ++i) *p++ = 7;
-  for ( ; i <= 287; ++i) *p++ = 8;
-
-  memset(d->m_huff_code_sizes[1], 5, 32);
-
-  tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);
-  tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);
-
-  TDEFL_PUT_BITS(1, 2);
-}
-
-static const mz_uint mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };
-
-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
-static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
-{
-  mz_uint flags;
-  mz_uint8 *pLZ_codes;
-  mz_uint8 *pOutput_buf = d->m_pOutput_buf;
-  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
-  mz_uint64 bit_buffer = d->m_bit_buffer;
-  mz_uint bits_in = d->m_bits_in;
-
-#define TDEFL_PUT_BITS_FAST(b, l) { bit_buffer |= (((mz_uint64)(b)) << bits_in); bits_in += (l); }
-
-  flags = 1;
-  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1)
-  {
-    if (flags == 1)
-      flags = *pLZ_codes++ | 0x100;
-
-    if (flags & 1)
-    {
-      mz_uint s0, s1, n0, n1, sym, num_extra_bits;
-      mz_uint match_len = pLZ_codes[0], match_dist = *(const mz_uint16 *)(pLZ_codes + 1); pLZ_codes += 3;
-
-      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
-      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
-      TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);
-
-      // This sequence coaxes MSVC into using cmov's vs. jmp's.
-      s0 = s_tdefl_small_dist_sym[match_dist & 511];
-      n0 = s_tdefl_small_dist_extra[match_dist & 511];
-      s1 = s_tdefl_large_dist_sym[match_dist >> 8];
-      n1 = s_tdefl_large_dist_extra[match_dist >> 8];
-      sym = (match_dist < 512) ? s0 : s1;
-      num_extra_bits = (match_dist < 512) ? n0 : n1;
-
-      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
-      TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
-      TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
-    }
-    else
-    {
-      mz_uint lit = *pLZ_codes++;
-      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
-      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
-
-      if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
-      {
-        flags >>= 1;
-        lit = *pLZ_codes++;
-        MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
-        TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
-
-        if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
-        {
-          flags >>= 1;
-          lit = *pLZ_codes++;
-          MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
-          TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
-        }
-      }
-    }
-
-    if (pOutput_buf >= d->m_pOutput_buf_end)
-      return MZ_FALSE;
-
-    *(mz_uint64*)pOutput_buf = bit_buffer;
-    pOutput_buf += (bits_in >> 3);
-    bit_buffer >>= (bits_in & ~7);
-    bits_in &= 7;
-  }
-
-#undef TDEFL_PUT_BITS_FAST
-
-  d->m_pOutput_buf = pOutput_buf;
-  d->m_bits_in = 0;
-  d->m_bit_buffer = 0;
-
-  while (bits_in)
-  {
-    mz_uint32 n = MZ_MIN(bits_in, 16);
-    TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);
-    bit_buffer >>= n;
-    bits_in -= n;
-  }
-
-  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);
-
-  return (d->m_pOutput_buf < d->m_pOutput_buf_end);
-}
-#else
-static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
-{
-  mz_uint flags;
-  mz_uint8 *pLZ_codes;
-
-  flags = 1;
-  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1)
-  {
-    if (flags == 1)
-      flags = *pLZ_codes++ | 0x100;
-    if (flags & 1)
-    {
-      mz_uint sym, num_extra_bits;
-      mz_uint match_len = pLZ_codes[0], match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8)); pLZ_codes += 3;
-
-      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
-      TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
-      TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);
-
-      if (match_dist < 512)
-      {
-        sym = s_tdefl_small_dist_sym[match_dist]; num_extra_bits = s_tdefl_small_dist_extra[match_dist];
-      }
-      else
-      {
-        sym = s_tdefl_large_dist_sym[match_dist >> 8]; num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];
-      }
-      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
-      TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
-      TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
-    }
-    else
-    {
-      mz_uint lit = *pLZ_codes++;
-      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
-      TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
-    }
-  }
-
-  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);
-
-  return (d->m_pOutput_buf < d->m_pOutput_buf_end);
-}
-#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
-
-static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)
-{
-  if (static_block)
-    tdefl_start_static_block(d);
-  else
-    tdefl_start_dynamic_block(d);
-  return tdefl_compress_lz_codes(d);
-}
-
-static UInt32 tdefl_flush_block(tdefl_compressor *d, UInt32 flush)
-{
-  mz_uint saved_bit_buf, saved_bits_in;
-  mz_uint8 *pSaved_output_buf;
-  mz_bool comp_block_succeeded = MZ_FALSE;
-  UInt32 n, use_raw_block = ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;
-  mz_uint8 *pOutput_buf_start = ((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE)) ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs) : d->m_output_buf;
-
-  d->m_pOutput_buf = pOutput_buf_start;
-  d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;
-
-  MZ_ASSERT(!d->m_output_flush_remaining);
-  d->m_output_flush_ofs = 0;
-  d->m_output_flush_remaining = 0;
-
-  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);
-  d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);
-
-  if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index))
-  {
-    TDEFL_PUT_BITS(0x78, 8); TDEFL_PUT_BITS(0x01, 8);
-  }
-
-  TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);
-
-  pSaved_output_buf = d->m_pOutput_buf; saved_bit_buf = d->m_bit_buffer; saved_bits_in = d->m_bits_in;
-
-  if (!use_raw_block)
-    comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48));
-
-  // If the block gets expanded, forget the current contents of the output buffer and send a raw block instead.
-  if ( ((use_raw_block) || ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >= d->m_total_lz_bytes))) &&
-       ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size) )
-  {
-    mz_uint i; d->m_pOutput_buf = pSaved_output_buf; d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
-    TDEFL_PUT_BITS(0, 2);
-    if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); }
-    for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF)
-    {
-      TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);
-    }
-    for (i = 0; i < d->m_total_lz_bytes; ++i)
-    {
-      TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8);
-    }
-  }
-  // Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes.
-  else if (!comp_block_succeeded)
-  {
-    d->m_pOutput_buf = pSaved_output_buf; d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
-    tdefl_compress_block(d, MZ_TRUE);
-  }
-
-  if (flush)
-  {
-    if (flush == TDEFL_FINISH)
-    {
-      if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); }
-      if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER) { mz_uint i, a = d->m_adler32; for (i = 0; i < 4; i++) { TDEFL_PUT_BITS((a >> 24) & 0xFF, 8); a <<= 8; } }
-    }
-    else
-    {
-      mz_uint i, z = 0; TDEFL_PUT_BITS(0, 3); if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); } for (i = 2; i; --i, z ^= 0xFFFF) { TDEFL_PUT_BITS(z & 0xFFFF, 16); }
-    }
-  }
-
-  MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);
-
-  memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
-  memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
-
-  d->m_pLZ_code_buf = d->m_lz_code_buf + 1; d->m_pLZ_flags = d->m_lz_code_buf; d->m_num_flags_left = 8; d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes; d->m_total_lz_bytes = 0; d->m_block_index++;
-
-  if ((n = (UInt32)(d->m_pOutput_buf - pOutput_buf_start)) != 0)
-  {
-    if (d->m_pPut_buf_func)
-    {
-      *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
-      if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))
-        return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);
-    }
-    else if (pOutput_buf_start == d->m_output_buf)
-    {
-      UInt32 bytes_to_copy = (UInt32)MZ_MIN((size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));
-      memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy);
-      d->m_out_buf_ofs += bytes_to_copy;
-      if ((n -= bytes_to_copy) != 0)
-      {
-        d->m_output_flush_ofs = bytes_to_copy;
-        d->m_output_flush_remaining = n;
-      }
-    }
-    else
-    {
-      d->m_out_buf_ofs += n;
-    }
-  }
-
-  return d->m_output_flush_remaining;
-}
-
-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
-#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16*)(p)
-static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
-{
-  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
-  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
-  const mz_uint16 *s = (const mz_uint16*)(d->m_dict + pos), *p, *q;
-  mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD(s);
-  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN); if (max_match_len <= match_len) return;
-  for ( ; ; )
-  {
-    for ( ; ; )
-    {
-      if (--num_probes_left == 0) return;
-      #define TDEFL_PROBE \
-        next_probe_pos = d->m_next[probe_pos]; \
-        if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \
-        probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK; \
-        if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01) break;
-      TDEFL_PROBE; TDEFL_PROBE; TDEFL_PROBE;
-    }
-    if (!dist) break; q = (const mz_uint16*)(d->m_dict + probe_pos); if (TDEFL_READ_UNALIGNED_WORD(q) != s01) continue; p = s; probe_len = 32;
-    do { } while ( (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
-                   (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0) );
-    if (!probe_len)
-    {
-      *pMatch_dist = dist; *pMatch_len = MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN); break;
-    }
-    else if ((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8*)p == *(const mz_uint8*)q)) > match_len)
-    {
-      *pMatch_dist = dist; if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len) break;
-      c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);
-    }
-  }
-}
-#else
-static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
-{
-  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
-  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
-  const mz_uint8 *s = d->m_dict + pos, *p, *q;
-  mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];
-  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN); if (max_match_len <= match_len) return;
-  for ( ; ; )
-  {
-    for ( ; ; )
-    {
-      if (--num_probes_left == 0) return;
-      #define TDEFL_PROBE \
-        next_probe_pos = d->m_next[probe_pos]; \
-        if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \
-        probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK; \
-        if ((d->m_dict[probe_pos + match_len] == c0) && (d->m_dict[probe_pos + match_len - 1] == c1)) break;
-      TDEFL_PROBE; TDEFL_PROBE; TDEFL_PROBE;
-    }
-    if (!dist) break; p = s; q = d->m_dict + probe_pos; for (probe_len = 0; probe_len < max_match_len; probe_len++) if (*p++ != *q++) break;
-    if (probe_len > match_len)
-    {
-      *pMatch_dist = dist; if ((*pMatch_len = match_len = probe_len) == max_match_len) return;
-      c0 = d->m_dict[pos + match_len]; c1 = d->m_dict[pos + match_len - 1];
-    }
-  }
-}
-#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
-
-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-static mz_bool tdefl_compress_fast(tdefl_compressor *d)
-{
-  // Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio.
-  mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size, total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;
-  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
-  mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
-
-  while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))
-  {
-    const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
-    mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
-    mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
-    d->m_src_buf_left -= num_bytes_to_process;
-    lookahead_size += num_bytes_to_process;
-
-    while (num_bytes_to_process)
-    {
-      mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
-      memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
-      if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
-        memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
-      d->m_pSrc += n;
-      dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
-      num_bytes_to_process -= n;
-    }
-
-    dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
-    if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE)) break;
-
-    while (lookahead_size >= 4)
-    {
-      mz_uint cur_match_dist, cur_match_len = 1;
-      mz_uint8 *pCur_dict = d->m_dict + cur_pos;
-      mz_uint first_trigram = (*(const mz_uint32 *)pCur_dict) & 0xFFFFFF;
-      mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;
-      mz_uint probe_pos = d->m_hash[hash];
-      d->m_hash[hash] = (mz_uint16)lookahead_pos;
-
-      if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size) && ((*(const mz_uint32 *)(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram))
-      {
-        const mz_uint16 *p = (const mz_uint16 *)pCur_dict;
-        const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);
-        mz_uint32 probe_len = 32;
-        do { } while ( (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
-          (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0) );
-        cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);
-        if (!probe_len)
-          cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;
-
-        if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U*1024U)))
-        {
-          cur_match_len = 1;
-          *pLZ_code_buf++ = (mz_uint8)first_trigram;
-          *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
-          d->m_huff_count[0][(mz_uint8)first_trigram]++;
-        }
-        else
-        {
-          mz_uint32 s0, s1;
-          cur_match_len = MZ_MIN(cur_match_len, lookahead_size);
-
-          MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));
-
-          cur_match_dist--;
-
-          pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
-          *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
-          pLZ_code_buf += 3;
-          *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);
-
-          s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
-          s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
-          d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;
-
-          d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;
-        }
-      }
-      else
-      {
-        *pLZ_code_buf++ = (mz_uint8)first_trigram;
-        *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
-        d->m_huff_count[0][(mz_uint8)first_trigram]++;
-      }
-
-      if (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }
-
-      total_lz_bytes += cur_match_len;
-      lookahead_pos += cur_match_len;
-      dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);
-      cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
-      MZ_ASSERT(lookahead_size >= cur_match_len);
-      lookahead_size -= cur_match_len;
-
-      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
-      {
-        UInt32 n;
-        d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;
-        d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;
-        if ((n = tdefl_flush_block(d, 0)) != 0)
-          return (n < 0) ? MZ_FALSE : MZ_TRUE;
-        total_lz_bytes = d->m_total_lz_bytes; pLZ_code_buf = d->m_pLZ_code_buf; pLZ_flags = d->m_pLZ_flags; num_flags_left = d->m_num_flags_left;
-      }
-    }
-
-    while (lookahead_size)
-    {
-      mz_uint8 lit = d->m_dict[cur_pos];
-
-      total_lz_bytes++;
-      *pLZ_code_buf++ = lit;
-      *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
-      if (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }
-
-      d->m_huff_count[0][lit]++;
-
-      lookahead_pos++;
-      dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);
-      cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
-      lookahead_size--;
-
-      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
-      {
-        UInt32 n;
-        d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;
-        d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;
-        if ((n = tdefl_flush_block(d, 0)) != 0)
-          return (n < 0) ? MZ_FALSE : MZ_TRUE;
-        total_lz_bytes = d->m_total_lz_bytes; pLZ_code_buf = d->m_pLZ_code_buf; pLZ_flags = d->m_pLZ_flags; num_flags_left = d->m_num_flags_left;
-      }
-    }
-  }
-
-  d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;
-  d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;
-  return MZ_TRUE;
-}
-#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-
-static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)
-{
-  d->m_total_lz_bytes++;
-  *d->m_pLZ_code_buf++ = lit;
-  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1); if (--d->m_num_flags_left == 0) { d->m_num_flags_left = 8; d->m_pLZ_flags = d->m_pLZ_code_buf++; }
-  d->m_huff_count[0][lit]++;
-}
-
-static MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)
-{
-  mz_uint32 s0, s1;
-
-  MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE));
-
-  d->m_total_lz_bytes += match_len;
-
-  d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);
-
-  match_dist -= 1;
-  d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);
-  d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8); d->m_pLZ_code_buf += 3;
-
-  *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80); if (--d->m_num_flags_left == 0) { d->m_num_flags_left = 8; d->m_pLZ_flags = d->m_pLZ_code_buf++; }
-
-  s0 = s_tdefl_small_dist_sym[match_dist & 511]; s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];
-  d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;
-
-  if (match_len >= TDEFL_MIN_MATCH_LEN) d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;
-}
-
-static mz_bool tdefl_compress_normal(tdefl_compressor *d)
-{
-  const mz_uint8 *pSrc = d->m_pSrc; size_t src_buf_left = d->m_src_buf_left;
-  tdefl_flush flush = d->m_flush;
-
-  while ((src_buf_left) || ((flush) && (d->m_lookahead_size)))
-  {
-    mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;
-    // Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN.
-    if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1))
-    {
-      mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK, ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;
-      mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];
-      mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
-      const mz_uint8 *pSrc_end = pSrc + num_bytes_to_process;
-      src_buf_left -= num_bytes_to_process;
-      d->m_lookahead_size += num_bytes_to_process;
-      while (pSrc != pSrc_end)
-      {
-        mz_uint8 c = *pSrc++; d->m_dict[dst_pos] = c; if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
-        hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
-        d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash]; d->m_hash[hash] = (mz_uint16)(ins_pos);
-        dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK; ins_pos++;
-      }
-    }
-    else
-    {
-      while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
-      {
-        mz_uint8 c = *pSrc++;
-        mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
-        src_buf_left--;
-        d->m_dict[dst_pos] = c;
-        if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
-          d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
-        if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN)
-        {
-          mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;
-          mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2)) ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
-          d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash]; d->m_hash[hash] = (mz_uint16)(ins_pos);
-        }
-      }
-    }
-    d->m_dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);
-    if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
-      break;
-
-    // Simple lazy/greedy parsing state machine.
-    len_to_move = 1; cur_match_dist = 0; cur_match_len = d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1); cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
-    if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS))
-    {
-      if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))
-      {
-        mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];
-        cur_match_len = 0; while (cur_match_len < d->m_lookahead_size) { if (d->m_dict[cur_pos + cur_match_len] != c) break; cur_match_len++; }
-        if (cur_match_len < TDEFL_MIN_MATCH_LEN) cur_match_len = 0; else cur_match_dist = 1;
-      }
-    }
-    else
-    {
-      tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size, d->m_lookahead_size, &cur_match_dist, &cur_match_len);
-    }
-    if (((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U*1024U)) || (cur_pos == cur_match_dist) || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5)))
-    {
-      cur_match_dist = cur_match_len = 0;
-    }
-    if (d->m_saved_match_len)
-    {
-      if (cur_match_len > d->m_saved_match_len)
-      {
-        tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);
-        if (cur_match_len >= 128)
-        {
-          tdefl_record_match(d, cur_match_len, cur_match_dist);
-          d->m_saved_match_len = 0; len_to_move = cur_match_len;
-        }
-        else
-        {
-          d->m_saved_lit = d->m_dict[cur_pos]; d->m_saved_match_dist = cur_match_dist; d->m_saved_match_len = cur_match_len;
-        }
-      }
-      else
-      {
-        tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);
-        len_to_move = d->m_saved_match_len - 1; d->m_saved_match_len = 0;
-      }
-    }
-    else if (!cur_match_dist)
-      tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);
-    else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) || (cur_match_len >= 128))
-    {
-      tdefl_record_match(d, cur_match_len, cur_match_dist);
-      len_to_move = cur_match_len;
-    }
-    else
-    {
-      d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]; d->m_saved_match_dist = cur_match_dist; d->m_saved_match_len = cur_match_len;
-    }
-    // Move the lookahead forward by len_to_move bytes.
-    d->m_lookahead_pos += len_to_move;
-    MZ_ASSERT(d->m_lookahead_size >= len_to_move);
-    d->m_lookahead_size -= len_to_move;
-    d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, TDEFL_LZ_DICT_SIZE);
-    // Check if it's time to flush the current LZ codes to the internal output buffer.
-    if ( (d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||
-         ( (d->m_total_lz_bytes > 31*1024) && (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >= d->m_total_lz_bytes) || (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))) )
-    {
-      UInt32 n;
-      d->m_pSrc = pSrc; d->m_src_buf_left = src_buf_left;
-      if ((n = tdefl_flush_block(d, 0)) != 0)
-        return (n < 0) ? MZ_FALSE : MZ_TRUE;
-    }
-  }
-
-  d->m_pSrc = pSrc; d->m_src_buf_left = src_buf_left;
-  return MZ_TRUE;
-}
-
-static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)
-{
-  if (d->m_pIn_buf_size)
-  {
-    *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
-  }
-
-  if (d->m_pOut_buf_size)
-  {
-    size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining);
-    memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n);
-    d->m_output_flush_ofs += (mz_uint)n;
-    d->m_output_flush_remaining -= (mz_uint)n;
-    d->m_out_buf_ofs += n;
-
-    *d->m_pOut_buf_size = d->m_out_buf_ofs;
-  }
-
-  return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;
-}
-
-tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)
-{
-  if (!d)
-  {
-    if (pIn_buf_size) *pIn_buf_size = 0;
-    if (pOut_buf_size) *pOut_buf_size = 0;
-    return TDEFL_STATUS_BAD_PARAM;
-  }
-
-  d->m_pIn_buf = pIn_buf; d->m_pIn_buf_size = pIn_buf_size;
-  d->m_pOut_buf = pOut_buf; d->m_pOut_buf_size = pOut_buf_size;
-  d->m_pSrc = (const mz_uint8 *)(pIn_buf); d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;
-  d->m_out_buf_ofs = 0;
-  d->m_flush = flush;
-
-  if ( ((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||
-        (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf) || (pOut_buf_size && *pOut_buf_size && !pOut_buf) )
-  {
-    if (pIn_buf_size) *pIn_buf_size = 0;
-    if (pOut_buf_size) *pOut_buf_size = 0;
-    return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);
-  }
-  d->m_wants_to_finish |= (flush == TDEFL_FINISH);
-
-  if ((d->m_output_flush_remaining) || (d->m_finished))
-    return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
-
-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-  if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&
-      ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&
-      ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))
-  {
-    if (!tdefl_compress_fast(d))
-      return d->m_prev_return_status;
-  }
-  else
-#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-  {
-    if (!tdefl_compress_normal(d))
-      return d->m_prev_return_status;
-  }
-
-  if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf))
-    d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf, d->m_pSrc - (const mz_uint8 *)pIn_buf);
-
-  if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) && (!d->m_output_flush_remaining))
-  {
-    if (tdefl_flush_block(d, flush) < 0)
-      return d->m_prev_return_status;
-    d->m_finished = (flush == TDEFL_FINISH);
-    if (flush == TDEFL_FULL_FLUSH) { MZ_CLEAR_OBJ(d->m_hash); MZ_CLEAR_OBJ(d->m_next); d->m_dict_size = 0; }
-  }
-
-  return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
-}
-
-tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)
-{
-  MZ_ASSERT(d->m_pPut_buf_func); return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
-}
-
-tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, UInt32 flags)
-{
-  d->m_pPut_buf_func = pPut_buf_func; d->m_pPut_buf_user = pPut_buf_user;
-  d->m_flags = (mz_uint)(flags); d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3; d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
-  d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;
-  if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) MZ_CLEAR_OBJ(d->m_hash);
-  d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size = d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;
-  d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished = d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;
-  d->m_pLZ_code_buf = d->m_lz_code_buf + 1; d->m_pLZ_flags = d->m_lz_code_buf; d->m_num_flags_left = 8;
-  d->m_pOutput_buf = d->m_output_buf; d->m_pOutput_buf_end = d->m_output_buf; d->m_prev_return_status = TDEFL_STATUS_OKAY;
-  d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0; d->m_adler32 = 1;
-  d->m_pIn_buf = NULL; d->m_pOut_buf = NULL;
-  d->m_pIn_buf_size = NULL; d->m_pOut_buf_size = NULL;
-  d->m_flush = TDEFL_NO_FLUSH; d->m_pSrc = NULL; d->m_src_buf_left = 0; d->m_out_buf_ofs = 0;
-  memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
-  memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
-  return TDEFL_STATUS_OKAY;
-}
-
-tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d)
-{
-  return d->m_prev_return_status;
-}
-
-mz_uint32 tdefl_get_adler32(tdefl_compressor *d)
-{
-  return d->m_adler32;
-}
-
-mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, UInt32 flags)
-{
-  tdefl_compressor *pComp; mz_bool succeeded; if (((buf_len) && (!pBuf)) || (!pPut_buf_func)) return MZ_FALSE;
-  pComp = (tdefl_compressor*)MZ_MALLOC(sizeof(tdefl_compressor)); if (!pComp) return MZ_FALSE;
-  succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);
-  succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);
-  MZ_FREE(pComp); return succeeded;
-}
-
-typedef struct
-{
-  size_t m_size, m_capacity;
-  mz_uint8 *m_pBuf;
-  mz_bool m_expandable;
-} tdefl_output_buffer;
-
-static mz_bool tdefl_output_buffer_putter(const void *pBuf, UInt32 len, void *pUser)
-{
-  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
-  size_t new_size = p->m_size + len;
-  if (new_size > p->m_capacity)
-  {
-    size_t new_capacity = p->m_capacity; mz_uint8 *pNew_buf; if (!p->m_expandable) return MZ_FALSE;
-    do { new_capacity = MZ_MAX(128U, new_capacity << 1U); } while (new_size > new_capacity);
-    pNew_buf = (mz_uint8*)MZ_REALLOC(p->m_pBuf, new_capacity); if (!pNew_buf) return MZ_FALSE;
-    p->m_pBuf = pNew_buf; p->m_capacity = new_capacity;
-  }
-  memcpy((mz_uint8*)p->m_pBuf + p->m_size, pBuf, len); p->m_size = new_size;
-  return MZ_TRUE;
-}
-
-void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, UInt32 flags)
-{
-  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);
-  if (!pOut_len) return MZ_FALSE; else *pOut_len = 0;
-  out_buf.m_expandable = MZ_TRUE;
-  if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return NULL;
-  *pOut_len = out_buf.m_size; return out_buf.m_pBuf;
-}
-
-size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, UInt32 flags)
-{
-  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);
-  if (!pOut_buf) return 0;
-  out_buf.m_pBuf = (mz_uint8*)pOut_buf; out_buf.m_capacity = out_buf_len;
-  if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return 0;
-  return out_buf.m_size;
-}
-
-#ifndef MINIZ_NO_ZLIB_APIS
-static const mz_uint s_tdefl_num_probes[11] = { 0, 1, 6, 32,  16, 32, 128, 256,  512, 768, 1500 };
-
-// level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files).
-mz_uint tdefl_create_comp_flags_from_zip_params(UInt32 level, UInt32 window_bits, UInt32 strategy)
-{
-  mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
-  if (window_bits > 0) comp_flags |= TDEFL_WRITE_ZLIB_HEADER;
-
-  if (!level) comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
-  else if (strategy == MZ_FILTERED) comp_flags |= TDEFL_FILTER_MATCHES;
-  else if (strategy == MZ_HUFFMAN_ONLY) comp_flags &= ~TDEFL_MAX_PROBES_MASK;
-  else if (strategy == MZ_FIXED) comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
-  else if (strategy == MZ_RLE) comp_flags |= TDEFL_RLE_MATCHES;
-
-  return comp_flags;
-}
-#endif //MINIZ_NO_ZLIB_APIS
-
-#ifdef _MSC_VER
-#pragma warning (push)
-#pragma warning (disable:4204) // nonstandard extension used : non-constant aggregate initializer (also supported by GNU C and C99, so no big deal)
-#endif
-
-// Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
-// http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
-// This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck.
-void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, UInt32 w, UInt32 h, UInt32 num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)
-{
-  // Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined.
-  static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32,  16, 32, 128, 256,  512, 768, 1500 };
-  tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor)); tdefl_output_buffer out_buf; UInt32 i, bpl = w * num_chans, y, z; mz_uint32 c; *pLen_out = 0;
-  if (!pComp) return NULL;
-  MZ_CLEAR_OBJ(out_buf); out_buf.m_expandable = MZ_TRUE; out_buf.m_capacity = 57+MZ_MAX(64, (1+bpl)*h); if (NULL == (out_buf.m_pBuf = (mz_uint8*)MZ_MALLOC(out_buf.m_capacity))) { MZ_FREE(pComp); return NULL; }
-  // write dummy header
-  for (z = 41; z; --z) tdefl_output_buffer_putter(&z, 1, &out_buf);
-  // compress image data
-  tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
-  for (y = 0; y < h; ++y) { tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH); tdefl_compress_buffer(pComp, (mz_uint8*)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH); }
-  if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE) { MZ_FREE(pComp); MZ_FREE(out_buf.m_pBuf); return NULL; }
-  // write real header
-  *pLen_out = out_buf.m_size-41;
-  {
-    static const mz_uint8 chans[] = {0x00, 0x00, 0x04, 0x02, 0x06};
-    mz_uint8 pnghdr[41]={0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a,0x00,0x00,0x00,0x0d,0x49,0x48,0x44,0x52,
-      0,0,(mz_uint8)(w>>8),(mz_uint8)w,0,0,(mz_uint8)(h>>8),(mz_uint8)h,8,chans[num_chans],0,0,0,0,0,0,0,
-      (mz_uint8)(*pLen_out>>24),(mz_uint8)(*pLen_out>>16),(mz_uint8)(*pLen_out>>8),(mz_uint8)*pLen_out,0x49,0x44,0x41,0x54};
-    c=(mz_uint32)mz_crc32(MZ_CRC32_INIT,pnghdr+12,17); for (i=0; i<4; ++i, c<<=8) ((mz_uint8*)(pnghdr+29))[i]=(mz_uint8)(c>>24);
-    memcpy(out_buf.m_pBuf, pnghdr, 41);
-  }
-  // write footer (IDAT CRC-32, followed by IEND chunk)
-  if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf)) { *pLen_out = 0; MZ_FREE(pComp); MZ_FREE(out_buf.m_pBuf); return NULL; }
-  c = (mz_uint32)mz_crc32(MZ_CRC32_INIT,out_buf.m_pBuf+41-4, *pLen_out+4); for (i=0; i<4; ++i, c<<=8) (out_buf.m_pBuf+out_buf.m_size-16)[i] = (mz_uint8)(c >> 24);
-  // compute final size of file, grab compressed data buffer and return
-  *pLen_out += 57; MZ_FREE(pComp); return out_buf.m_pBuf;
-}
-void *tdefl_write_image_to_png_file_in_memory(const void *pImage, UInt32 w, UInt32 h, UInt32 num_chans, size_t *pLen_out)
-{
-  // Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out)
-  return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);
-}
-
-#endif // MINIZ_NO_COMPRESSION
-
-#ifdef _MSC_VER
-#pragma warning (pop)
-#endif
-
-// ------------------- .ZIP archive reading
-
-#ifndef MINIZ_NO_ARCHIVE_APIS
-
-#ifdef MINIZ_NO_STDIO
-  #define MZ_FILE void *
-#else
-  #include <stdio.h>
-  #include <sys/stat.h>
-
-  #if defined(_MSC_VER) || defined(__MINGW64__)
-    static FILE *mz_fopen(const char *pFilename, const char *pMode)
-    {
-      FILE* pFile = NULL;
-      fopen_s(&pFile, pFilename, pMode);
-      return pFile;
-    }
-    static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream)
-    {
-      FILE* pFile = NULL;
-      if (freopen_s(&pFile, pPath, pMode, pStream))
-        return NULL;
-      return pFile;
-    }
-    #ifndef MINIZ_NO_TIME
-      #include <sys/utime.h>
-    #endif
-    #define MZ_FILE FILE
-    #define MZ_FOPEN mz_fopen
-    #define MZ_FCLOSE fclose
-    #define MZ_FREAD fread
-    #define MZ_FWRITE fwrite
-    #define MZ_FTELL64 _ftelli64
-    #define MZ_FSEEK64 _fseeki64
-    #define MZ_FILE_STAT_STRUCT _stat
-    #define MZ_FILE_STAT _stat
-    #define MZ_FFLUSH fflush
-    #define MZ_FREOPEN mz_freopen
-    #define MZ_DELETE_FILE remove
-  #elif defined(__MINGW32__)
-    #ifndef MINIZ_NO_TIME
-      #include <sys/utime.h>
-    #endif
-    #define MZ_FILE FILE
-    #define MZ_FOPEN(f, m) fopen(f, m)
-    #define MZ_FCLOSE fclose
-    #define MZ_FREAD fread
-    #define MZ_FWRITE fwrite
-    #define MZ_FTELL64 ftello64
-    #define MZ_FSEEK64 fseeko64
-    #define MZ_FILE_STAT_STRUCT _stat
-    #define MZ_FILE_STAT _stat
-    #define MZ_FFLUSH fflush
-    #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
-    #define MZ_DELETE_FILE remove
-  #elif defined(__TINYC__)
-    #ifndef MINIZ_NO_TIME
-      #include <sys/utime.h>
-    #endif
-    #define MZ_FILE FILE
-    #define MZ_FOPEN(f, m) fopen(f, m)
-    #define MZ_FCLOSE fclose
-    #define MZ_FREAD fread
-    #define MZ_FWRITE fwrite
-    #define MZ_FTELL64 ftell
-    #define MZ_FSEEK64 fseek
-    #define MZ_FILE_STAT_STRUCT stat
-    #define MZ_FILE_STAT stat
-    #define MZ_FFLUSH fflush
-    #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
-    #define MZ_DELETE_FILE remove
-  #elif defined(__GNUC__) && _LARGEFILE64_SOURCE
-    #ifndef MINIZ_NO_TIME
-      #include <utime.h>
-    #endif
-    #define MZ_FILE FILE
-    #define MZ_FOPEN(f, m) fopen64(f, m)
-    #define MZ_FCLOSE fclose
-    #define MZ_FREAD fread
-    #define MZ_FWRITE fwrite
-    #define MZ_FTELL64 ftello64
-    #define MZ_FSEEK64 fseeko64
-    #define MZ_FILE_STAT_STRUCT stat64
-    #define MZ_FILE_STAT stat64
-    #define MZ_FFLUSH fflush
-    #define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
-    #define MZ_DELETE_FILE remove
-  #else
-    #ifndef MINIZ_NO_TIME
-      #include <utime.h>
-    #endif
-    #define MZ_FILE FILE
-    #define MZ_FOPEN(f, m) fopen(f, m)
-    #define MZ_FCLOSE fclose
-    #define MZ_FREAD fread
-    #define MZ_FWRITE fwrite
-    #define MZ_FTELL64 ftello
-    #define MZ_FSEEK64 fseeko
-    #define MZ_FILE_STAT_STRUCT stat
-    #define MZ_FILE_STAT stat
-    #define MZ_FFLUSH fflush
-    #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
-    #define MZ_DELETE_FILE remove
-  #endif // #ifdef _MSC_VER
-#endif // #ifdef MINIZ_NO_STDIO
-
-#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))
-
-// Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff.
-enum
-{
-  // ZIP archive identifiers and record sizes
-  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50, MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50, MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
-  MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,
-  // Central directory header record offsets
-  MZ_ZIP_CDH_SIG_OFS = 0, MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4, MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6, MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
-  MZ_ZIP_CDH_METHOD_OFS = 10, MZ_ZIP_CDH_FILE_TIME_OFS = 12, MZ_ZIP_CDH_FILE_DATE_OFS = 14, MZ_ZIP_CDH_CRC32_OFS = 16,
-  MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20, MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24, MZ_ZIP_CDH_FILENAME_LEN_OFS = 28, MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
-  MZ_ZIP_CDH_COMMENT_LEN_OFS = 32, MZ_ZIP_CDH_DISK_START_OFS = 34, MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36, MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38, MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,
-  // Local directory header offsets
-  MZ_ZIP_LDH_SIG_OFS = 0, MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4, MZ_ZIP_LDH_BIT_FLAG_OFS = 6, MZ_ZIP_LDH_METHOD_OFS = 8, MZ_ZIP_LDH_FILE_TIME_OFS = 10,
-  MZ_ZIP_LDH_FILE_DATE_OFS = 12, MZ_ZIP_LDH_CRC32_OFS = 14, MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18, MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
-  MZ_ZIP_LDH_FILENAME_LEN_OFS = 26, MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
-  // End of central directory offsets
-  MZ_ZIP_ECDH_SIG_OFS = 0, MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4, MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6, MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
-  MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10, MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12, MZ_ZIP_ECDH_CDIR_OFS_OFS = 16, MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,
-};
-
-typedef struct
-{
-  void *m_p;
-  size_t m_size, m_capacity;
-  mz_uint m_element_size;
-} mz_zip_array;
-
-struct mz_zip_internal_state_tag
-{
-  mz_zip_array m_central_dir;
-  mz_zip_array m_central_dir_offsets;
-  mz_zip_array m_sorted_central_dir_offsets;
-  MZ_FILE *m_pFile;
-  void *m_pMem;
-  size_t m_mem_size;
-  size_t m_mem_capacity;
-};
-
-#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size
-#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[index]
-
-static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip, mz_zip_array *pArray)
-{
-  pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
-  memset(pArray, 0, sizeof(mz_zip_array));
-}
-
-static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip, mz_zip_array *pArray, size_t min_new_capacity, mz_uint growing)
-{
-  void *pNew_p; size_t new_capacity = min_new_capacity; MZ_ASSERT(pArray->m_element_size); if (pArray->m_capacity >= min_new_capacity) return MZ_TRUE;
-  if (growing) { new_capacity = MZ_MAX(1, pArray->m_capacity); while (new_capacity < min_new_capacity) new_capacity *= 2; }
-  if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity))) return MZ_FALSE;
-  pArray->m_p = pNew_p; pArray->m_capacity = new_capacity;
-  return MZ_TRUE;
-}
-
-static MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity, mz_uint growing)
-{
-  if (new_capacity > pArray->m_capacity) { if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing)) return MZ_FALSE; }
-  return MZ_TRUE;
-}
-
-static MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)
-{
-  if (new_size > pArray->m_capacity) { if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing)) return MZ_FALSE; }
-  pArray->m_size = new_size;
-  return MZ_TRUE;
-}
-
-static MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)
-{
-  return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
-}
-
-static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray, const void *pElements, size_t n)
-{
-  size_t orig_size = pArray->m_size; if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE)) return MZ_FALSE;
-  memcpy((mz_uint8*)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);
-  return MZ_TRUE;
-}
-
-#ifndef MINIZ_NO_TIME
-static time_t mz_zip_dos_to_time_t(UInt32 dos_time, UInt32 dos_date)
-{
-  struct tm tm;
-  memset(&tm, 0, sizeof(tm)); tm.tm_isdst = -1;
-  tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900; tm.tm_mon = ((dos_date >> 5) & 15) - 1; tm.tm_mday = dos_date & 31;
-  tm.tm_hour = (dos_time >> 11) & 31; tm.tm_min = (dos_time >> 5) & 63; tm.tm_sec = (dos_time << 1) & 62;
-  return mktime(&tm);
-}
-
-static void mz_zip_time_to_dos_time(time_t time, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
-{
-#ifdef _MSC_VER
-  struct tm tm_struct;
-  struct tm *tm = &tm_struct;
-  errno_t err = localtime_s(tm, &time);
-  if (err)
-  {
-    *pDOS_date = 0; *pDOS_time = 0;
-    return;
-  }
-#else
-  struct tm *tm = localtime(&time);
-#endif
-  *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
-  *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);
-}
-#endif
-
-#ifndef MINIZ_NO_STDIO
-static mz_bool mz_zip_get_file_modified_time(const char *pFilename, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
-{
-#ifdef MINIZ_NO_TIME
-  (void)pFilename; *pDOS_date = *pDOS_time = 0;
-#else
-  struct MZ_FILE_STAT_STRUCT file_stat;
-  // On Linux with x86 glibc, this call will fail on large files (>= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh.
-  if (MZ_FILE_STAT(pFilename, &file_stat) != 0)
-    return MZ_FALSE;
-  mz_zip_time_to_dos_time(file_stat.st_mtime, pDOS_time, pDOS_date);
-#endif // #ifdef MINIZ_NO_TIME
-  return MZ_TRUE;
-}
-
-#ifndef MINIZ_NO_TIME
-static mz_bool mz_zip_set_file_times(const char *pFilename, time_t access_time, time_t modified_time)
-{
-  struct utimbuf t; t.actime = access_time; t.modtime = modified_time;
-  return !utime(pFilename, &t);
-}
-#endif // #ifndef MINIZ_NO_TIME
-#endif // #ifndef MINIZ_NO_STDIO
-
-static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip, mz_uint32 flags)
-{
-  (void)flags;
-  if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
-    return MZ_FALSE;
-
-  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;
-  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;
-  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;
-
-  pZip->m_zip_mode = MZ_ZIP_MODE_READING;
-  pZip->m_archive_size = 0;
-  pZip->m_central_directory_file_ofs = 0;
-  pZip->m_total_files = 0;
-
-  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
-    return MZ_FALSE;
-  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
-  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
-  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
-  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
-  return MZ_TRUE;
-}
-
-static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, mz_uint r_index)
-{
-  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
-  const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
-  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-  mz_uint8 l = 0, r = 0;
-  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE; pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
-  pE = pL + MZ_MIN(l_len, r_len);
-  while (pL < pE)
-  {
-    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
-      break;
-    pL++; pR++;
-  }
-  return (pL == pE) ? (l_len < r_len) : (l < r);
-}
-
-#define MZ_SWAP_UINT32(a, b) do { mz_uint32 t = a; a = b; b = t; } MZ_MACRO_END
-
-// Heap sort of lowercased filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.)
-static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)
-{
-  mz_zip_internal_state *pState = pZip->m_pState;
-  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
-  const mz_zip_array *pCentral_dir = &pState->m_central_dir;
-  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
-  const UInt32 size = pZip->m_total_files;
-  UInt32 start = (size - 2) >> 1, end;
-  while (start >= 0)
-  {
-    UInt32 child, root = start;
-    for ( ; ; )
-    {
-      if ((child = (root << 1) + 1) >= size)
-        break;
-      child += (((child + 1) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1])));
-      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
-        break;
-      MZ_SWAP_UINT32(pIndices[root], pIndices[child]); root = child;
-    }
-    start--;
-  }
-
-  end = size - 1;
-  while (end > 0)
-  {
-    UInt32 child, root = 0;
-    MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
-    for ( ; ; )
-    {
-      if ((child = (root << 1) + 1) >= end)
-        break;
-      child += (((child + 1) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1]));
-      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
-        break;
-      MZ_SWAP_UINT32(pIndices[root], pIndices[child]); root = child;
-    }
-    end--;
-  }
-}
-
-static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip, mz_uint32 flags)
-{
-  mz_uint cdir_size, num_this_disk, cdir_disk_index;
-  mz_uint64 cdir_ofs;
-  mz_int64 cur_file_ofs;
-  const mz_uint8 *p;
-  mz_uint32 buf_u32[4096 / sizeof(mz_uint32)]; mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
-  mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
-  // Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there.
-  if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
-    return MZ_FALSE;
-  // Find the end of central directory record by scanning the file from the end towards the beginning.
-  cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
-  for ( ; ; )
-  {
-    UInt32 i, n = (UInt32)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);
-    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)
-      return MZ_FALSE;
-    for (i = n - 4; i >= 0; --i)
-      if (MZ_READ_LE32(pBuf + i) == MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
-        break;
-    if (i >= 0)
-    {
-      cur_file_ofs += i;
-      break;
-    }
-    if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (0xFFFF + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))
-      return MZ_FALSE;
-    cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
-  }
-  // Read and verify the end of central directory record.
-  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
-    return MZ_FALSE;
-  if ((MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) ||
-      ((pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS)) != MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS)))
-    return MZ_FALSE;
-
-  num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
-  cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
-  if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1)))
-    return MZ_FALSE;
-
-  if ((cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS)) < pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
-    return MZ_FALSE;
-
-  cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);
-  if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
-    return MZ_FALSE;
-
-  pZip->m_central_directory_file_ofs = cdir_ofs;
-
-  if (pZip->m_total_files)
-  {
-     mz_uint i, n;
-
-    // Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and another to hold the sorted indices.
-    if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE)) ||
-        (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))
-      return MZ_FALSE;
-
-    if (sort_central_dir)
-    {
-      if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE))
-        return MZ_FALSE;
-    }
-
-    if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size)
-      return MZ_FALSE;
-
-    // Now create an index into the central directory file records, do some basic sanity checking on each record, and check for zip64 entries (which are not yet supported).
-    p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;
-    for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i)
-    {
-      mz_uint total_header_size, comp_size, decomp_size, disk_index;
-      if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))
-        return MZ_FALSE;
-      MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) = (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);
-      if (sort_central_dir)
-        MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;
-      comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
-      decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
-      if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size) || (decomp_size == 0xFFFFFFFF) || (comp_size == 0xFFFFFFFF))
-        return MZ_FALSE;
-      disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
-      if ((disk_index != num_this_disk) && (disk_index != 1))
-        return MZ_FALSE;
-      if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
-        return MZ_FALSE;
-      if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) > n)
-        return MZ_FALSE;
-      n -= total_header_size; p += total_header_size;
-    }
-  }
-
-  if (sort_central_dir)
-    mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);
-
-  return MZ_TRUE;
-}
-
-mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint32 flags)
-{
-  if ((!pZip) || (!pZip->m_pRead))
-    return MZ_FALSE;
-  if (!mz_zip_reader_init_internal(pZip, flags))
-    return MZ_FALSE;
-  pZip->m_archive_size = size;
-  if (!mz_zip_reader_read_central_dir(pZip, flags))
-  {
-    mz_zip_reader_end(pZip);
-    return MZ_FALSE;
-  }
-  return MZ_TRUE;
-}
-
-static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
-{
-  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
-  size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
-  memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
-  return s;
-}
-
-mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint32 flags)
-{
-  if (!mz_zip_reader_init_internal(pZip, flags))
-    return MZ_FALSE;
-  pZip->m_archive_size = size;
-  pZip->m_pRead = mz_zip_mem_read_func;
-  pZip->m_pIO_opaque = pZip;
-#ifdef __cplusplus
-  pZip->m_pState->m_pMem = const_cast<void *>(pMem);
-#else
-  pZip->m_pState->m_pMem = (void *)pMem;
-#endif
-  pZip->m_pState->m_mem_size = size;
-  if (!mz_zip_reader_read_central_dir(pZip, flags))
-  {
-    mz_zip_reader_end(pZip);
-    return MZ_FALSE;
-  }
-  return MZ_TRUE;
-}
-
-#ifndef MINIZ_NO_STDIO
-static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
-{
-  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
-  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
-  if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
-    return 0;
-  return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
-}
-
-mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags)
-{
-  mz_uint64 file_size;
-  MZ_FILE *pFile = MZ_FOPEN(pFilename, "rb");
-  if (!pFile)
-    return MZ_FALSE;
-  if (MZ_FSEEK64(pFile, 0, SEEK_END))
-  {
-    MZ_FCLOSE(pFile);
-    return MZ_FALSE;
-  }
-  file_size = MZ_FTELL64(pFile);
-  if (!mz_zip_reader_init_internal(pZip, flags))
-  {
-    MZ_FCLOSE(pFile);
-    return MZ_FALSE;
-  }
-  pZip->m_pRead = mz_zip_file_read_func;
-  pZip->m_pIO_opaque = pZip;
-  pZip->m_pState->m_pFile = pFile;
-  pZip->m_archive_size = file_size;
-  if (!mz_zip_reader_read_central_dir(pZip, flags))
-  {
-    mz_zip_reader_end(pZip);
-    return MZ_FALSE;
-  }
-  return MZ_TRUE;
-}
-#endif // #ifndef MINIZ_NO_STDIO
-
-mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip)
-{
-  return pZip ? pZip->m_total_files : 0;
-}
-
-static MZ_FORCEINLINE const mz_uint8 *mz_zip_reader_get_cdh(mz_zip_archive *pZip, mz_uint file_index)
-{
-  if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
-    return NULL;
-  return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
-}
-
-mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index)
-{
-  mz_uint m_bit_flag;
-  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
-  if (!p)
-    return MZ_FALSE;
-  m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
-  return (m_bit_flag & 1);
-}
-
-mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index)
-{
-  mz_uint filename_len, external_attr;
-  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
-  if (!p)
-    return MZ_FALSE;
-
-  // First see if the filename ends with a '/' character.
-  filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-  if (filename_len)
-  {
-    if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')
-      return MZ_TRUE;
-  }
-
-  // Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct.
-  // Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field.
-  // FIXME: Remove this check? Is it necessary - we already check the filename.
-  external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
-  if ((external_attr & 0x10) != 0)
-    return MZ_TRUE;
-
-  return MZ_FALSE;
-}
-
-mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)
-{
-  mz_uint n;
-  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
-  if ((!p) || (!pStat))
-    return MZ_FALSE;
-
-  // Unpack the central directory record.
-  pStat->m_file_index = file_index;
-  pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
-  pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
-  pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
-  pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
-  pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
-#ifndef MINIZ_NO_TIME
-  pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
-#endif
-  pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
-  pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
-  pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
-  pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
-  pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
-  pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
-
-  // Copy as much of the filename and comment as possible.
-  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS); n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
-  memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n); pStat->m_filename[n] = '\0';
-
-  n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS); n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
-  pStat->m_comment_size = n;
-  memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n); pStat->m_comment[n] = '\0';
-
-  return MZ_TRUE;
-}
-
-mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size)
-{
-  mz_uint n;
-  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
-  if (!p) { if (filename_buf_size) pFilename[0] = '\0'; return 0; }
-  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-  if (filename_buf_size)
-  {
-    n = MZ_MIN(n, filename_buf_size - 1);
-    memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
-    pFilename[n] = '\0';
-  }
-  return n + 1;
-}
-
-static MZ_FORCEINLINE mz_bool mz_zip_reader_string_equal(const char *pA, const char *pB, mz_uint len, mz_uint flags)
-{
-  mz_uint i;
-  if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)
-    return 0 == memcmp(pA, pB, len);
-  for (i = 0; i < len; ++i)
-    if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))
-      return MZ_FALSE;
-  return MZ_TRUE;
-}
-
-static MZ_FORCEINLINE UInt32 mz_zip_reader_filename_compare(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR, mz_uint r_len)
-{
-  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
-  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-  mz_uint8 l = 0, r = 0;
-  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
-  pE = pL + MZ_MIN(l_len, r_len);
-  while (pL < pE)
-  {
-    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
-      break;
-    pL++; pR++;
-  }
-  return (pL == pE) ? (UInt32)(l_len - r_len) : (l - r);
-}
-
-static UInt32 mz_zip_reader_locate_file_binary_search(mz_zip_archive *pZip, const char *pFilename)
-{
-  mz_zip_internal_state *pState = pZip->m_pState;
-  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
-  const mz_zip_array *pCentral_dir = &pState->m_central_dir;
-  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
-  const UInt32 size = pZip->m_total_files;
-  const mz_uint filename_len = (mz_uint)strlen(pFilename);
-  UInt32 l = 0, h = size - 1;
-  while (l <= h)
-  {
-    UInt32 m = (l + h) >> 1, file_index = pIndices[m], comp = mz_zip_reader_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);
-    if (!comp)
-      return file_index;
-    else if (comp < 0)
-      l = m + 1;
-    else
-      h = m - 1;
-  }
-  return -1;
-}
-
-UInt32 mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)
-{
-  mz_uint file_index; size_t name_len, comment_len;
-  if ((!pZip) || (!pZip->m_pState) || (!pName) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
-    return -1;
-  if (((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
-    return mz_zip_reader_locate_file_binary_search(pZip, pName);
-  name_len = strlen(pName); if (name_len > 0xFFFF) return -1;
-  comment_len = pComment ? strlen(pComment) : 0; if (comment_len > 0xFFFF) return -1;
-  for (file_index = 0; file_index < pZip->m_total_files; file_index++)
-  {
-    const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
-    mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-    const char *pFilename = (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
-    if (filename_len < name_len)
-      continue;
-    if (comment_len)
-    {
-      mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS), file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
-      const char *pFile_comment = pFilename + filename_len + file_extra_len;
-      if ((file_comment_len != comment_len) || (!mz_zip_reader_string_equal(pComment, pFile_comment, file_comment_len, flags)))
-        continue;
-    }
-    if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len))
-    {
-      UInt32 ofs = filename_len - 1;
-      do
-      {
-        if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') || (pFilename[ofs] == ':'))
-          break;
-      } while (--ofs >= 0);
-      ofs++;
-      pFilename += ofs; filename_len -= ofs;
-    }
-    if ((filename_len == name_len) && (mz_zip_reader_string_equal(pName, pFilename, filename_len, flags)))
-      return file_index;
-  }
-  return -1;
-}
-
-mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
-{
-  UInt32 status = TINFL_STATUS_DONE;
-  mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
-  mz_zip_archive_file_stat file_stat;
-  void *pRead_buf;
-  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
-  tinfl_decompressor inflator;
-
-  if ((buf_size) && (!pBuf))
-    return MZ_FALSE;
-
-  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
-    return MZ_FALSE;
-
-  // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)
-  if (!file_stat.m_comp_size)
-    return MZ_TRUE;
-
-  // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).
-  // I'm torn how to handle this case - should it fail instead?
-  if (mz_zip_reader_is_file_a_directory(pZip, file_index))
-    return MZ_TRUE;
-
-  // Encryption and patch files are not supported.
-  if (file_stat.m_bit_flag & (1 | 32))
-    return MZ_FALSE;
-
-  // This function only supports stored and deflate.
-  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
-    return MZ_FALSE;
-
-  // Ensure supplied output buffer is large enough.
-  needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
-  if (buf_size < needed_size)
-    return MZ_FALSE;
-
-  // Read and parse the local directory entry.
-  cur_file_ofs = file_stat.m_local_header_ofs;
-  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-    return MZ_FALSE;
-  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
-    return MZ_FALSE;
-
-  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
-  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
-    return MZ_FALSE;
-
-  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
-  {
-    // The file is stored or the caller has requested the compressed data.
-    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size)
-      return MZ_FALSE;
-    return ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) != 0) || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) == file_stat.m_crc32);
-  }
-
-  // Decompress the file either directly from memory or from a file input buffer.
-  tinfl_init(&inflator);
-
-  if (pZip->m_pState->m_pMem)
-  {
-    // Read directly from the archive in memory.
-    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
-    read_buf_size = read_buf_avail = file_stat.m_comp_size;
-    comp_remaining = 0;
-  }
-  else if (pUser_read_buf)
-  {
-    // Use a user provided read buffer.
-    if (!user_read_buf_size)
-      return MZ_FALSE;
-    pRead_buf = (mz_uint8 *)pUser_read_buf;
-    read_buf_size = user_read_buf_size;
-    read_buf_avail = 0;
-    comp_remaining = file_stat.m_comp_size;
-  }
-  else
-  {
-    // Temporarily allocate a read buffer.
-    read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
-#ifdef _MSC_VER
-    if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
-#else
-    if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
-#endif
-      return MZ_FALSE;
-    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
-      return MZ_FALSE;
-    read_buf_avail = 0;
-    comp_remaining = file_stat.m_comp_size;
-  }
-
-  do
-  {
-    size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
-    if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
-    {
-      read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
-      if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
-      {
-        status = TINFL_STATUS_FAILED;
-        break;
-      }
-      cur_file_ofs += read_buf_avail;
-      comp_remaining -= read_buf_avail;
-      read_buf_ofs = 0;
-    }
-    in_buf_size = (size_t)read_buf_avail;
-    status = tinfl_decompress(&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
-    read_buf_avail -= in_buf_size;
-    read_buf_ofs += in_buf_size;
-    out_buf_ofs += out_buf_size;
-  } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);
-
-  if (status == TINFL_STATUS_DONE)
-  {
-    // Make sure the entire file was decompressed, and check its CRC.
-    if ((out_buf_ofs != file_stat.m_uncomp_size) || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32))
-      status = TINFL_STATUS_FAILED;
-  }
-
-  if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-
-  return status == TINFL_STATUS_DONE;
-}
-
-mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
-{
-  UInt32 file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
-  if (file_index < 0)
-    return MZ_FALSE;
-  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size);
-}
-
-mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags)
-{
-  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, NULL, 0);
-}
-
-mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags)
-{
-  return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);
-}
-
-void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)
-{
-  mz_uint64 comp_size, uncomp_size, alloc_size;
-  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
-  void *pBuf;
-
-  if (pSize)
-    *pSize = 0;
-  if (!p)
-    return NULL;
-
-  comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
-  uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
-
-  alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;
-#ifdef _MSC_VER
-  if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
-#else
-  if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
-#endif
-    return NULL;
-  if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))
-    return NULL;
-
-  if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size, flags))
-  {
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-    return NULL;
-  }
-
-  if (pSize) *pSize = (size_t)alloc_size;
-  return pBuf;
-}
-
-void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags)
-{
-  UInt32 file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
-  if (file_index < 0)
-  {
-    if (pSize) *pSize = 0;
-    return MZ_FALSE;
-  }
-  return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
-}
-
-mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
-{
-  UInt32 status = TINFL_STATUS_DONE; mz_uint file_crc32 = MZ_CRC32_INIT;
-  mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;
-  mz_zip_archive_file_stat file_stat;
-  void *pRead_buf = NULL; void *pWrite_buf = NULL;
-  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
-
-  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
-    return MZ_FALSE;
-
-  // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)
-  if (!file_stat.m_comp_size)
-    return MZ_TRUE;
-
-  // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).
-  // I'm torn how to handle this case - should it fail instead?
-  if (mz_zip_reader_is_file_a_directory(pZip, file_index))
-    return MZ_TRUE;
-
-  // Encryption and patch files are not supported.
-  if (file_stat.m_bit_flag & (1 | 32))
-    return MZ_FALSE;
-
-  // This function only supports stored and deflate.
-  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
-    return MZ_FALSE;
-
-  // Read and parse the local directory entry.
-  cur_file_ofs = file_stat.m_local_header_ofs;
-  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-    return MZ_FALSE;
-  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
-    return MZ_FALSE;
-
-  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
-  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
-    return MZ_FALSE;
-
-  // Decompress the file either directly from memory or from a file input buffer.
-  if (pZip->m_pState->m_pMem)
-  {
-    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
-    read_buf_size = read_buf_avail = file_stat.m_comp_size;
-    comp_remaining = 0;
-  }
-  else
-  {
-    read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
-    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
-      return MZ_FALSE;
-    read_buf_avail = 0;
-    comp_remaining = file_stat.m_comp_size;
-  }
-
-  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
-  {
-    // The file is stored or the caller has requested the compressed data.
-    if (pZip->m_pState->m_pMem)
-    {
-#ifdef _MSC_VER
-      if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))
-#else
-      if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))
-#endif
-        return MZ_FALSE;
-      if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
-        status = TINFL_STATUS_FAILED;
-      else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
-        file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)file_stat.m_comp_size);
-      cur_file_ofs += file_stat.m_comp_size;
-      out_buf_ofs += file_stat.m_comp_size;
-      comp_remaining = 0;
-    }
-    else
-    {
-      while (comp_remaining)
-      {
-        read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
-        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
-        {
-          status = TINFL_STATUS_FAILED;
-          break;
-        }
-
-        if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
-          file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);
-
-        if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
-        {
-          status = TINFL_STATUS_FAILED;
-          break;
-        }
-        cur_file_ofs += read_buf_avail;
-        out_buf_ofs += read_buf_avail;
-        comp_remaining -= read_buf_avail;
-      }
-    }
-  }
-  else
-  {
-    tinfl_decompressor inflator;
-    tinfl_init(&inflator);
-
-    if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
-      status = TINFL_STATUS_FAILED;
-    else
-    {
-      do
-      {
-        mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
-        size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
-        if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
-        {
-          read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
-          if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
-          {
-            status = TINFL_STATUS_FAILED;
-            break;
-          }
-          cur_file_ofs += read_buf_avail;
-          comp_remaining -= read_buf_avail;
-          read_buf_ofs = 0;
-        }
-
-        in_buf_size = (size_t)read_buf_avail;
-        status = tinfl_decompress(&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
-        read_buf_avail -= in_buf_size;
-        read_buf_ofs += in_buf_size;
-
-        if (out_buf_size)
-        {
-          if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size)
-          {
-            status = TINFL_STATUS_FAILED;
-            break;
-          }
-          file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
-          if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size)
-          {
-            status = TINFL_STATUS_FAILED;
-            break;
-          }
-        }
-      } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));
-    }
-  }
-
-  if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
-  {
-    // Make sure the entire file was decompressed, and check its CRC.
-    if ((out_buf_ofs != file_stat.m_uncomp_size) || (file_crc32 != file_stat.m_crc32))
-      status = TINFL_STATUS_FAILED;
-  }
-
-  if (!pZip->m_pState->m_pMem)
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-  if (pWrite_buf)
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);
-
-  return status == TINFL_STATUS_DONE;
-}
-
-mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
-{
-  UInt32 file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
-  if (file_index < 0)
-    return MZ_FALSE;
-  return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);
-}
-
-#ifndef MINIZ_NO_STDIO
-static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs, const void *pBuf, size_t n)
-{
-  (void)ofs; return MZ_FWRITE(pBuf, 1, n, (MZ_FILE*)pOpaque);
-}
-
-mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags)
-{
-  mz_bool status;
-  mz_zip_archive_file_stat file_stat;
-  MZ_FILE *pFile;
-  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
-    return MZ_FALSE;
-  pFile = MZ_FOPEN(pDst_filename, "wb");
-  if (!pFile)
-    return MZ_FALSE;
-  status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
-  if (MZ_FCLOSE(pFile) == EOF)
-    return MZ_FALSE;
-#ifndef MINIZ_NO_TIME
-  if (status)
-    mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
-#endif
-  return status;
-}
-#endif // #ifndef MINIZ_NO_STDIO
-
-mz_bool mz_zip_reader_end(mz_zip_archive *pZip)
-{
-  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
-    return MZ_FALSE;
-
-  if (pZip->m_pState)
-  {
-    mz_zip_internal_state *pState = pZip->m_pState; pZip->m_pState = NULL;
-    mz_zip_array_clear(pZip, &pState->m_central_dir);
-    mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
-    mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
-
-#ifndef MINIZ_NO_STDIO
-    if (pState->m_pFile)
-    {
-      MZ_FCLOSE(pState->m_pFile);
-      pState->m_pFile = NULL;
-    }
-#endif // #ifndef MINIZ_NO_STDIO
-
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-  }
-  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
-
-  return MZ_TRUE;
-}
-
-#ifndef MINIZ_NO_STDIO
-mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags)
-{
-  UInt32 file_index = mz_zip_reader_locate_file(pZip, pArchive_filename, NULL, flags);
-  if (file_index < 0)
-    return MZ_FALSE;
-  return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
-}
-#endif
-
-// ------------------- .ZIP archive writing
-
-#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-
-static void mz_write_le16(mz_uint8 *p, mz_uint16 v) { p[0] = (mz_uint8)v; p[1] = (mz_uint8)(v >> 8); }
-static void mz_write_le32(mz_uint8 *p, mz_uint32 v) { p[0] = (mz_uint8)v; p[1] = (mz_uint8)(v >> 8); p[2] = (mz_uint8)(v >> 16); p[3] = (mz_uint8)(v >> 24); }
-#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))
-#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))
-
-mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)
-{
-  if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
-    return MZ_FALSE;
-
-  if (pZip->m_file_offset_alignment)
-  {
-    // Ensure user specified file offset alignment is a power of 2.
-    if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))
-      return MZ_FALSE;
-  }
-
-  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;
-  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;
-  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;
-
-  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
-  pZip->m_archive_size = existing_size;
-  pZip->m_central_directory_file_ofs = 0;
-  pZip->m_total_files = 0;
-
-  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
-    return MZ_FALSE;
-  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
-  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
-  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
-  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
-  return MZ_TRUE;
-}
-
-static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
-{
-  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
-  mz_zip_internal_state *pState = pZip->m_pState;
-  mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);
-#ifdef _MSC_VER
-  if ((!n) || ((0, sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
-#else
-  if ((!n) || ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
-#endif
-    return 0;
-  if (new_size > pState->m_mem_capacity)
-  {
-    void *pNew_block;
-    size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity); while (new_capacity < new_size) new_capacity *= 2;
-    if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))
-      return 0;
-    pState->m_pMem = pNew_block; pState->m_mem_capacity = new_capacity;
-  }
-  memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);
-  pState->m_mem_size = (size_t)new_size;
-  return n;
-}
-
-mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size)
-{
-  pZip->m_pWrite = mz_zip_heap_write_func;
-  pZip->m_pIO_opaque = pZip;
-  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))
-    return MZ_FALSE;
-  if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning)))
-  {
-    if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size)))
-    {
-      mz_zip_writer_end(pZip);
-      return MZ_FALSE;
-    }
-    pZip->m_pState->m_mem_capacity = initial_allocation_size;
-  }
-  return MZ_TRUE;
-}
-
-#ifndef MINIZ_NO_STDIO
-static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
-{
-  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
-  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
-  if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
-    return 0;
-  return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
-}
-
-mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)
-{
-  MZ_FILE *pFile;
-  pZip->m_pWrite = mz_zip_file_write_func;
-  pZip->m_pIO_opaque = pZip;
-  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))
-    return MZ_FALSE;
-  if (NULL == (pFile = MZ_FOPEN(pFilename, "wb")))
-  {
-    mz_zip_writer_end(pZip);
-    return MZ_FALSE;
-  }
-  pZip->m_pState->m_pFile = pFile;
-  if (size_to_reserve_at_beginning)
-  {
-    mz_uint64 cur_ofs = 0; char buf[4096]; MZ_CLEAR_OBJ(buf);
-    do
-    {
-      size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
-      if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n)
-      {
-        mz_zip_writer_end(pZip);
-        return MZ_FALSE;
-      }
-      cur_ofs += n; size_to_reserve_at_beginning -= n;
-    } while (size_to_reserve_at_beginning);
-  }
-  return MZ_TRUE;
-}
-#endif // #ifndef MINIZ_NO_STDIO
-
-mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename)
-{
-  mz_zip_internal_state *pState;
-  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
-    return MZ_FALSE;
-  // No sense in trying to write to an archive that's already at the support max size
-  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
-    return MZ_FALSE;
-
-  pState = pZip->m_pState;
-
-  if (pState->m_pFile)
-  {
-#ifdef MINIZ_NO_STDIO
-    pFilename; return MZ_FALSE;
-#else
-    // Archive is being read from stdio - try to reopen as writable.
-    if (pZip->m_pIO_opaque != pZip)
-      return MZ_FALSE;
-    if (!pFilename)
-      return MZ_FALSE;
-    pZip->m_pWrite = mz_zip_file_write_func;
-    if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile)))
-    {
-      // The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it.
-      mz_zip_reader_end(pZip);
-      return MZ_FALSE;
-    }
-#endif // #ifdef MINIZ_NO_STDIO
-  }
-  else if (pState->m_pMem)
-  {
-    // Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback.
-    if (pZip->m_pIO_opaque != pZip)
-      return MZ_FALSE;
-    pState->m_mem_capacity = pState->m_mem_size;
-    pZip->m_pWrite = mz_zip_heap_write_func;
-  }
-  // Archive is being read via a user provided read function - make sure the user has specified a write function too.
-  else if (!pZip->m_pWrite)
-    return MZ_FALSE;
-
-  // Start writing new files at the archive's current central directory location.
-  pZip->m_archive_size = pZip->m_central_directory_file_ofs;
-  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
-  pZip->m_central_directory_file_ofs = 0;
-
-  return MZ_TRUE;
-}
-
-mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags)
-{
-  return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);
-}
-
-typedef struct
-{
-  mz_zip_archive *m_pZip;
-  mz_uint64 m_cur_archive_file_ofs;
-  mz_uint64 m_comp_size;
-} mz_zip_writer_add_state;
-
-static mz_bool mz_zip_writer_add_put_buf_callback(const void* pBuf, UInt32 len, void *pUser)
-{
-  mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
-  if ((UInt32)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len)
-    return MZ_FALSE;
-  pState->m_cur_archive_file_ofs += len;
-  pState->m_comp_size += len;
-  return MZ_TRUE;
-}
-
-static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date)
-{
-  (void)pZip;
-  memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
-  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
-  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
-  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, comp_size);
-  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
-  return MZ_TRUE;
-}
-
-static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
-{
-  (void)pZip;
-  memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
-  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
-  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
-  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, comp_size);
-  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
-  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
-  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
-  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_header_ofs);
-  return MZ_TRUE;
-}
-
-static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size, const void *pExtra, mz_uint16 extra_size, const void *pComment, mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
-{
-  mz_zip_internal_state *pState = pZip->m_pState;
-  mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
-  size_t orig_central_dir_size = pState->m_central_dir.m_size;
-  mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
-
-  // No zip64 support yet
-  if ((local_header_ofs > 0xFFFFFFFF) || (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + comment_size) > 0xFFFFFFFF))
-    return MZ_FALSE;
-
-  if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, extra_size, comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))
-    return MZ_FALSE;
-
-  if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||
-      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size)) ||
-      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size)) ||
-      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size)) ||
-      (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1)))
-  {
-    // Try to push the central directory array back into its original state.
-    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
-    return MZ_FALSE;
-  }
-
-  return MZ_TRUE;
-}
-
-static mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name)
-{
-  // Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes.
-  if (*pArchive_name == '/')
-    return MZ_FALSE;
-  while (*pArchive_name)
-  {
-    if ((*pArchive_name == '\\') || (*pArchive_name == ':'))
-      return MZ_FALSE;
-    pArchive_name++;
-  }
-  return MZ_TRUE;
-}
-
-static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip)
-{
-  mz_uint32 n;
-  if (!pZip->m_file_offset_alignment)
-    return 0;
-  n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
-  return (pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1);
-}
-
-static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip, mz_uint64 cur_file_ofs, mz_uint32 n)
-{
-  char buf[4096];
-  memset(buf, 0, MZ_MIN(sizeof(buf), n));
-  while (n)
-  {
-    mz_uint32 s = MZ_MIN(sizeof(buf), n);
-    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
-      return MZ_FALSE;
-    cur_file_ofs += s; n -= s;
-  }
-  return MZ_TRUE;
-}
-
-mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)
-{
-  mz_uint16 method = 0, dos_time = 0, dos_date = 0;
-  mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
-  mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
-  size_t archive_name_size;
-  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
-  tdefl_compressor *pComp = NULL;
-  mz_bool store_data_uncompressed;
-  mz_zip_internal_state *pState;
-
-  if ((UInt32)level_and_flags < 0)
-    level_and_flags = MZ_DEFAULT_LEVEL;
-  level = level_and_flags & 0xF;
-  store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));
-
-  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (pZip->m_total_files == 0xFFFF) || (level > MZ_UBER_COMPRESSION))
-    return MZ_FALSE;
-
-  pState = pZip->m_pState;
-
-  if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))
-    return MZ_FALSE;
-  // No zip64 support yet
-  if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))
-    return MZ_FALSE;
-  if (!mz_zip_writer_validate_archive_name(pArchive_name))
-    return MZ_FALSE;
-
-#ifndef MINIZ_NO_TIME
-  {
-    time_t cur_time; time(&cur_time);
-    mz_zip_time_to_dos_time(cur_time, &dos_time, &dos_date);
-  }
-#endif // #ifndef MINIZ_NO_TIME
-
-  archive_name_size = strlen(pArchive_name);
-  if (archive_name_size > 0xFFFF)
-    return MZ_FALSE;
-
-  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
-
-  // no zip64 support yet
-  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size + archive_name_size) > 0xFFFFFFFF))
-    return MZ_FALSE;
-
-  if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/'))
-  {
-    // Set DOS Subdirectory attribute bit.
-    ext_attributes |= 0x10;
-    // Subdirectories cannot contain data.
-    if ((buf_size) || (uncomp_size))
-      return MZ_FALSE;
-  }
-
-  // Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.)
-  if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size)) || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
-    return MZ_FALSE;
-
-  if ((!store_data_uncompressed) && (buf_size))
-  {
-    if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))
-      return MZ_FALSE;
-  }
-
-  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header)))
-  {
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-    return MZ_FALSE;
-  }
-  local_dir_header_ofs += num_alignment_padding_bytes;
-  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }
-  cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);
-
-  MZ_CLEAR_OBJ(local_dir_header);
-  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
-  {
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-    return MZ_FALSE;
-  }
-  cur_archive_file_ofs += archive_name_size;
-
-  if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
-  {
-    uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8*)pBuf, buf_size);
-    uncomp_size = buf_size;
-    if (uncomp_size <= 3)
-    {
-      level = 0;
-      store_data_uncompressed = MZ_TRUE;
-    }
-  }
-
-  if (store_data_uncompressed)
-  {
-    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size)
-    {
-      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-      return MZ_FALSE;
-    }
-
-    cur_archive_file_ofs += buf_size;
-    comp_size = buf_size;
-
-    if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
-      method = MZ_DEFLATED;
-  }
-  else if (buf_size)
-  {
-    mz_zip_writer_add_state state;
-
-    state.m_pZip = pZip;
-    state.m_cur_archive_file_ofs = cur_archive_file_ofs;
-    state.m_comp_size = 0;
-
-    if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY) ||
-        (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE))
-    {
-      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-      return MZ_FALSE;
-    }
-
-    comp_size = state.m_comp_size;
-    cur_archive_file_ofs = state.m_cur_archive_file_ofs;
-
-    method = MZ_DEFLATED;
-  }
-
-  pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-  pComp = NULL;
-
-  // no zip64 support yet
-  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))
-    return MZ_FALSE;
-
-  if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date))
-    return MZ_FALSE;
-
-  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
-    return MZ_FALSE;
-
-  if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))
-    return MZ_FALSE;
-
-  pZip->m_total_files++;
-  pZip->m_archive_size = cur_archive_file_ofs;
-
-  return MZ_TRUE;
-}
-
-#ifndef MINIZ_NO_STDIO
-mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
-{
-  mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
-  mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
-  mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0, comp_size = 0;
-  size_t archive_name_size;
-  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
-  MZ_FILE *pSrc_file = NULL;
-
-  if ((UInt32)level_and_flags < 0)
-    level_and_flags = MZ_DEFAULT_LEVEL;
-  level = level_and_flags & 0xF;
-
-  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
-    return MZ_FALSE;
-  if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
-    return MZ_FALSE;
-  if (!mz_zip_writer_validate_archive_name(pArchive_name))
-    return MZ_FALSE;
-
-  archive_name_size = strlen(pArchive_name);
-  if (archive_name_size > 0xFFFF)
-    return MZ_FALSE;
-
-  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
-
-  // no zip64 support yet
-  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size + archive_name_size) > 0xFFFFFFFF))
-    return MZ_FALSE;
-
-  if (!mz_zip_get_file_modified_time(pSrc_filename, &dos_time, &dos_date))
-    return MZ_FALSE;
-    
-  pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
-  if (!pSrc_file)
-    return MZ_FALSE;
-  MZ_FSEEK64(pSrc_file, 0, SEEK_END);
-  uncomp_size = MZ_FTELL64(pSrc_file);
-  MZ_FSEEK64(pSrc_file, 0, SEEK_SET);
-
-  if (uncomp_size > 0xFFFFFFFF)
-  {
-    // No zip64 support yet
-    MZ_FCLOSE(pSrc_file);
-    return MZ_FALSE;
-  }
-  if (uncomp_size <= 3)
-    level = 0;
-
-  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header)))
-  {
-    MZ_FCLOSE(pSrc_file);
-    return MZ_FALSE;
-  }
-  local_dir_header_ofs += num_alignment_padding_bytes;
-  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }
-  cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);
-
-  MZ_CLEAR_OBJ(local_dir_header);
-  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
-  {
-    MZ_FCLOSE(pSrc_file);
-    return MZ_FALSE;
-  }
-  cur_archive_file_ofs += archive_name_size;
-
-  if (uncomp_size)
-  {
-    mz_uint64 uncomp_remaining = uncomp_size;
-    void *pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
-    if (!pRead_buf)
-    {
-      MZ_FCLOSE(pSrc_file);
-      return MZ_FALSE;
-    }
-
-    if (!level)
-    {
-      while (uncomp_remaining)
-      {
-        mz_uint n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);
-        if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n) || (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n))
-        {
-          pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-          MZ_FCLOSE(pSrc_file);
-          return MZ_FALSE;
-        }
-        uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);
-        uncomp_remaining -= n;
-        cur_archive_file_ofs += n;
-      }
-      comp_size = uncomp_size;
-    }
-    else
-    {
-      mz_bool result = MZ_FALSE;
-      mz_zip_writer_add_state state;
-      tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
-      if (!pComp)
-      {
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-        MZ_FCLOSE(pSrc_file);
-        return MZ_FALSE;
-      }
-
-      state.m_pZip = pZip;
-      state.m_cur_archive_file_ofs = cur_archive_file_ofs;
-      state.m_comp_size = 0;
-
-      if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY)
-      {
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-        MZ_FCLOSE(pSrc_file);
-        return MZ_FALSE;
-      }
-
-      for ( ; ; )
-      {
-        size_t in_buf_size = (mz_uint32)MZ_MIN(uncomp_remaining, MZ_ZIP_MAX_IO_BUF_SIZE);
-        tdefl_status status;
-
-        if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size)
-          break;
-
-        uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, in_buf_size);
-        uncomp_remaining -= in_buf_size;
-
-        status = tdefl_compress_buffer(pComp, pRead_buf, in_buf_size, uncomp_remaining ? TDEFL_NO_FLUSH : TDEFL_FINISH);
-        if (status == TDEFL_STATUS_DONE)
-        {
-          result = MZ_TRUE;
-          break;
-        }
-        else if (status != TDEFL_STATUS_OKAY)
-          break;
-      }
-
-      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-
-      if (!result)
-      {
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-        MZ_FCLOSE(pSrc_file);
-        return MZ_FALSE;
-      }
-
-      comp_size = state.m_comp_size;
-      cur_archive_file_ofs = state.m_cur_archive_file_ofs;
-
-      method = MZ_DEFLATED;
-    }
-
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-  }
-
-  MZ_FCLOSE(pSrc_file); pSrc_file = NULL;
-
-  // no zip64 support yet
-  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))
-    return MZ_FALSE;
-
-  if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date))
-    return MZ_FALSE;
-
-  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
-    return MZ_FALSE;
-
-  if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))
-    return MZ_FALSE;
-
-  pZip->m_total_files++;
-  pZip->m_archive_size = cur_archive_file_ofs;
-
-  return MZ_TRUE;
-}
-#endif // #ifndef MINIZ_NO_STDIO
-
-mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint file_index)
-{
-  mz_uint n, bit_flags, num_alignment_padding_bytes;
-  mz_uint64 comp_bytes_remaining, local_dir_header_ofs;
-  mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;
-  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
-  mz_uint8 central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
-  size_t orig_central_dir_size;
-  mz_zip_internal_state *pState;
-  void *pBuf; const mz_uint8 *pSrc_central_header;
-
-  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
-    return MZ_FALSE;
-  if (NULL == (pSrc_central_header = mz_zip_reader_get_cdh(pSource_zip, file_index)))
-    return MZ_FALSE;
-  pState = pZip->m_pState;
-
-  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
-
-  // no zip64 support yet
-  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
-    return MZ_FALSE;
-
-  cur_src_file_ofs = MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
-  cur_dst_file_ofs = pZip->m_archive_size;
-
-  if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-    return MZ_FALSE;
-  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
-    return MZ_FALSE;
-  cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;
-
-  if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes))
-    return MZ_FALSE;
-  cur_dst_file_ofs += num_alignment_padding_bytes;
-  local_dir_header_ofs = cur_dst_file_ofs;
-  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }
-
-  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-    return MZ_FALSE;
-  cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;
-
-  n = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
-  comp_bytes_remaining = n + MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
-
-  if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)MZ_MAX(sizeof(mz_uint32) * 4, MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining)))))
-    return MZ_FALSE;
-
-  while (comp_bytes_remaining)
-  {
-    n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining);
-    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n)
-    {
-      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-      return MZ_FALSE;
-    }
-    cur_src_file_ofs += n;
-
-    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
-    {
-      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-      return MZ_FALSE;
-    }
-    cur_dst_file_ofs += n;
-
-    comp_bytes_remaining -= n;
-  }
-
-  bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
-  if (bit_flags & 8)
-  {
-    // Copy data descriptor
-    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4)
-    {
-      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-      return MZ_FALSE;
-    }
-
-    n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == 0x08074b50) ? 4 : 3);
-    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
-    {
-      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-      return MZ_FALSE;
-    }
-
-    cur_src_file_ofs += n;
-    cur_dst_file_ofs += n;
-  }
-  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-
-  // no zip64 support yet
-  if (cur_dst_file_ofs > 0xFFFFFFFF)
-    return MZ_FALSE;
-
-  orig_central_dir_size = pState->m_central_dir.m_size;
-
-  memcpy(central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
-  MZ_WRITE_LE32(central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);
-  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
-    return MZ_FALSE;
-
-  n = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);
-  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n))
-  {
-    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
-    return MZ_FALSE;
-  }
-
-  if (pState->m_central_dir.m_size > 0xFFFFFFFF)
-    return MZ_FALSE;
-  n = (mz_uint32)orig_central_dir_size;
-  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1))
-  {
-    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
-    return MZ_FALSE;
-  }
-
-  pZip->m_total_files++;
-  pZip->m_archive_size = cur_dst_file_ofs;
-
-  return MZ_TRUE;
-}
-
-mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip)
-{
-  mz_zip_internal_state *pState;
-  mz_uint64 central_dir_ofs, central_dir_size;
-  mz_uint8 hdr[MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE];
-
-  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
-    return MZ_FALSE;
-
-  pState = pZip->m_pState;
-
-  // no zip64 support yet
-  if ((pZip->m_total_files > 0xFFFF) || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
-    return MZ_FALSE;
-
-  central_dir_ofs = 0;
-  central_dir_size = 0;
-  if (pZip->m_total_files)
-  {
-    // Write central directory
-    central_dir_ofs = pZip->m_archive_size;
-    central_dir_size = pState->m_central_dir.m_size;
-    pZip->m_central_directory_file_ofs = central_dir_ofs;
-    if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)
-      return MZ_FALSE;
-    pZip->m_archive_size += central_dir_size;
-  }
-
-  // Write end of central directory record
-  MZ_CLEAR_OBJ(hdr);
-  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
-  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);
-  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
-  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, central_dir_size);
-  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, central_dir_ofs);
-
-  if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, sizeof(hdr)) != sizeof(hdr))
-    return MZ_FALSE;
-#ifndef MINIZ_NO_STDIO
-  if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))
-    return MZ_FALSE;
-#endif // #ifndef MINIZ_NO_STDIO
-
-  pZip->m_archive_size += sizeof(hdr);
-
-  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
-  return MZ_TRUE;
-}
-
-mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf, size_t *pSize)
-{
-  if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pSize))
-    return MZ_FALSE;
-  if (pZip->m_pWrite != mz_zip_heap_write_func)
-    return MZ_FALSE;
-  if (!mz_zip_writer_finalize_archive(pZip))
-    return MZ_FALSE;
-
-  *pBuf = pZip->m_pState->m_pMem;
-  *pSize = pZip->m_pState->m_mem_size;
-  pZip->m_pState->m_pMem = NULL;
-  pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;
-  return MZ_TRUE;
-}
-
-mz_bool mz_zip_writer_end(mz_zip_archive *pZip)
-{
-  mz_zip_internal_state *pState;
-  mz_bool status = MZ_TRUE;
-  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
-    return MZ_FALSE;
-
-  pState = pZip->m_pState;
-  pZip->m_pState = NULL;
-  mz_zip_array_clear(pZip, &pState->m_central_dir);
-  mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
-  mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
-
-#ifndef MINIZ_NO_STDIO
-  if (pState->m_pFile)
-  {
-    MZ_FCLOSE(pState->m_pFile);
-    pState->m_pFile = NULL;
-  }
-#endif // #ifndef MINIZ_NO_STDIO
-
-  if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem))
-  {
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
-    pState->m_pMem = NULL;
-  }
-
-  pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
-  return status;
-}
-
-#ifndef MINIZ_NO_STDIO
-mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
-{
-  mz_bool status, created_new_archive = MZ_FALSE;
-  mz_zip_archive zip_archive;
-  struct MZ_FILE_STAT_STRUCT file_stat;
-  MZ_CLEAR_OBJ(zip_archive);
-  if ((UInt32)level_and_flags < 0)
-     level_and_flags = MZ_DEFAULT_LEVEL;
-  if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment)) || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
-    return MZ_FALSE;
-  if (!mz_zip_writer_validate_archive_name(pArchive_name))
-    return MZ_FALSE;
-  if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0)
-  {
-    // Create a new archive.
-    if (!mz_zip_writer_init_file(&zip_archive, pZip_filename, 0))
-      return MZ_FALSE;
-    created_new_archive = MZ_TRUE;
-  }
-  else
-  {
-    // Append to an existing archive.
-    if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))
-      return MZ_FALSE;
-    if (!mz_zip_writer_init_from_reader(&zip_archive, pZip_filename))
-    {
-      mz_zip_reader_end(&zip_archive);
-      return MZ_FALSE;
-    }
-  }
-  status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);
-  // Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.)
-  if (!mz_zip_writer_finalize_archive(&zip_archive))
-    status = MZ_FALSE;
-  if (!mz_zip_writer_end(&zip_archive))
-    status = MZ_FALSE;
-  if ((!status) && (created_new_archive))
-  {
-    // It's a new archive and something went wrong, so just delete it.
-    UInt32 ignoredStatus = MZ_DELETE_FILE(pZip_filename);
-    (void)ignoredStatus;
-  }
-  return status;
-}
-
-void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags)
-{
-  UInt32 file_index;
-  mz_zip_archive zip_archive;
-  void *p = NULL;
-
-  if (pSize)
-    *pSize = 0;
-
-  if ((!pZip_filename) || (!pArchive_name))
-    return NULL;
-
-  MZ_CLEAR_OBJ(zip_archive);
-  if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))
-    return NULL;
-
-  if ((file_index = mz_zip_reader_locate_file(&zip_archive, pArchive_name, NULL, flags)) >= 0)
-    p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);
-
-  mz_zip_reader_end(&zip_archive);
-  return p;
-}
-
-#endif // #ifndef MINIZ_NO_STDIO
-
-#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-
-#endif // #ifndef MINIZ_NO_ARCHIVE_APIS
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // MINIZ_HEADER_FILE_ONLY
-
-/*
-  This is free and unencumbered software released into the public domain.
-
-  Anyone is free to copy, modify, publish, use, compile, sell, or
-  distribute this software, either in source code form or as a compiled
-  binary, for any purpose, commercial or non-commercial, and by any
-  means.
-
-  In jurisdictions that recognize copyright laws, the author or authors
-  of this software dedicate any and all copyright interest in the
-  software to the public domain. We make this dedication for the benefit
-  of the public at large and to the detriment of our heirs and
-  successors. We intend this dedication to be an overt act of
-  relinquishment in perpetuity of all present and future rights to this
-  software under copyright law.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
-  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-  OTHER DEALINGS IN THE SOFTWARE.
-
-  For more information, please refer to <http://unlicense.org/>
-*/
\ No newline at end of file
diff --git a/Src/miniz.h b/Src/miniz.h
deleted file mode 100644
index 748cbaf..0000000
--- a/Src/miniz.h
+++ /dev/null
@@ -1,2 +0,0 @@
-#define MINIZ_HEADER_FILE_ONLY
-#include "../Src/miniz.c"
\ No newline at end of file
diff --git a/Src/pngDraw-68k.c b/Src/pngDraw-68k.c
deleted file mode 100644
index 0101dca..0000000
--- a/Src/pngDraw-68k.c
+++ /dev/null
@@ -1,39 +0,0 @@
-#include <PalmOS.h>
-#include "Src/pngle.h"
-#include "pngDrawInt.h"
-
-#pragma GCC optimize ("O3")
-
-
-void __attribute__((visibility("hidden"),always_inline)) on_draw(pngle_t *pngle, uint_fast16_t x, uint_fast16_t y, uint_fast16_t vR, uint_fast16_t vG, uint_fast16_t vB, uint_fast16_t vA, struct DrawState *ds)
-{
-	uint_fast16_t r = vR & 0xf8;
-	uint_fast16_t g = vG & 0xfc;
-	uint_fast16_t b = vB & 0xf8;
-	uint_fast16_t color = (r << 8) + (g << 3) + (b >> 3);
-	uint32_t offset;
-
-	//le sigh....gcc refuses to use 16x16->32 multiplication as it should here. The perf cost is large so we make it!
-	//the code here does what this line SHOULD do:
-	// offset = (uint32_t)(uint16_t)y * (uint32_t)(uint16_t)ds->rowHalfwords;
-	asm("move.w %1, %0 \n mulu.w %2, %0" :"=&d"(offset): "d"(y) , "d"(ds->rowHalfwords));
-	
-
-	uint16_t *dst = ds->bits + offset + x;
-
-	*dst = color;
-}
-
-int pngDrawDecode(struct DrawState *ds, const void *data, uint32_t dataSz, PngHdrDecodedCbkF hdrCbk)
-{
-	pngle_t *pngle;
-	int ret;
-
-	pngle = pngle_new();
-	pngle_set_draw_callback(pngle, ds);
-	pngle_set_init_callback(pngle, hdrCbk);
-	ret = pngle_feed(pngle, data, dataSz);
-	pngle_destroy(pngle);
-
-	return ret;
-}
diff --git a/Src/pngDraw.c b/Src/pngDraw.c
deleted file mode 100644
index 304621b..0000000
--- a/Src/pngDraw.c
+++ /dev/null
@@ -1,185 +0,0 @@
-#include <PalmOS.h>
-#include <PceNativeCall.h>
-#include <SonyCLIE.h>
-#include "pngDrawInt.h"
-#include "pngDraw.h"
-
-#define PNG_HI_RES_SUPPORTED				1		//sonyHR only supports double
-#define PNG_VARIOUS_DENSITIES_SUPPORTED		2		//palmHR supports various
-
-
-static Boolean isHighDensitySupported(void)
-{
-	UInt32 version;
-
-	return errNone == FtrGet(sysFtrCreator, sysFtrNumWinVersion, &version) && version >= 4;
-}
-
-static Boolean isSonyHiResSupported(void)
-{
-	UInt16 hrLibRef;
-
-	return errNone == SysLibFind(sonySysLibNameHR, &hrLibRef) && hrLibRef != 0xffff;
-}
-
-void pngDrawStateFree(struct DrawState *ds)
-{
-	BmpDelete(ds->b);
-	MemPtrFree(ds);
-}
-
-void pngDrawRedraw(struct DrawState *ds, int16_t x, int16_t y)
-{
-	if (ds->density == kDensityLow) {
-
-		WinDrawBitmap(ds->b, x, y);
-	}
-	else if (ds->densitySupportFlags & PNG_VARIOUS_DENSITIES_SUPPORTED) {	//high density feature set is easier to deal with  - use that
-
-		BitmapPtr b3 = (BitmapPtr)BmpCreateBitmapV3(ds->b, ds->density, ds->bits, NULL);
-
-		if (b3) {
-
-			WinDrawBitmap(b3, x, y);
-			BmpDelete(b3);
-		}
-	}
-	else if (ds->density == kDensityDouble && (ds->densitySupportFlags & PNG_HI_RES_SUPPORTED)) {
-
-		UInt16 hrLibRef;
-
-		if (errNone == SysLibFind(sonySysLibNameHR, &hrLibRef) && hrLibRef != 0xffff) {
-
-			HRWinDrawBitmap(hrLibRef, ds->b, x * 2, y * 2);
-		}
-	}
-}
-
-static unsigned char pngDrawHdrCbk(struct DrawState *ds, uint32_t w, uint32_t h)
-{
-	UInt16 rowBytes;
-	BitmapPtr b;
-	UInt32 val;
-	Err err;
-
-	//check for exact integer or 1/2 multiple of size, same for W & H
-	if (w * 2 % ds->expectedW || h * 2 % ds->expectedW || w * 2 / ds->expectedW != h * 2 / ds->expectedW)
-		return false;
-	
-	//see WHICH multiple it is, along the way, verify we support & expect that density
-	switch (w * 2 / ds->expectedW) {
-		case 2:	//expected size
-			ds->density = kDensityLow;
-			break;
-		
-		case 3:	//1.5 the size
-			ds->density = kDensityOneAndAHalf;
-			if (!(ds->densitySupportFlags & PNG_VARIOUS_DENSITIES_SUPPORTED))
-				return false;
-			break;
-		
-		case 4:	//2x the size
-			ds->density = kDensityDouble;
-			if (!(ds->densitySupportFlags & (PNG_VARIOUS_DENSITIES_SUPPORTED | PNG_HI_RES_SUPPORTED)))
-				return false;
-			break;
-		
-		case 6:	//3x the density
-			ds->density = kDensityTriple;
-			if (!(ds->densitySupportFlags & PNG_VARIOUS_DENSITIES_SUPPORTED))
-				return false;
-			break;
-		
-		case 8:	//4x the density
-			ds->density = kDensityQuadruple;
-			if (!(ds->densitySupportFlags & PNG_VARIOUS_DENSITIES_SUPPORTED))
-				return false;
-			break;
-		
-		default:
-			return false;
-	}
-
-	b = BmpCreate(w, h, 16, NULL, &err);
-	if (b == NULL) {
-		if (err == sysErrParamErr)
-		{
-			ErrFatalDisplay("Sprites not supported on this device as of now! Please uninstall them to use Palmkedex.");
-		}
-		if (err != sysErrNoFreeResource)
-		{
-			ErrFatalDisplay("Not enough memory!");
-		}
-		ErrFatalDisplay("Error creating bitmap!");
-		
-		return false;
-	}
-	ds->bits = BmpGetBits(b);
-	if (ds->bits == NULL) {
-		BmpDelete(b);
-		ErrFatalDisplay("Error getting bitmap bits!");
-		
-		return false;
-	}
-	
-	BmpGetDimensions(b, NULL, NULL, &rowBytes);
-	ds->rowHalfwords = rowBytes / sizeof(UInt16);
-	ds->b = b;
-	
-	return true;
-}
-
-int pngDrawDecodeCall(struct DrawState *ds, const void *data, uint32_t dataSz)
-{
-	UInt32 processorType, result;
-	int ret;
-	
-	if (errNone == FtrGet(sysFileCSystem, sysFtrNumProcessorID, &processorType)	&& sysFtrNumProcessorIsARM(processorType)) {
-		
-		MemHandle armH;
-	
-		struct ArmParams p = {
-			.ds = ds,
-			.data = data,
-			.dataSz = dataSz,
-			.hdrDecodedF = pngDrawHdrCbk,
-		};
-				
-		ret = PceNativeCall((NativeFuncType*)MemHandleLock(armH = DmGetResource('armc', 1)), &p);
-		MemHandleUnlock(armH);
-		DmReleaseResource(armH);
-	}
-	else {
-		
-		ret = pngDrawDecode(ds, data, dataSz, pngDrawHdrCbk);
-	}
-	
-	return ret;
-}
-
-void pngDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_t x, int16_t y, uint32_t expectedW, uint32_t expectedH)
-{
-	uint8_t densitySupportFlags = 0;
-	struct DrawState *ds;
-	int ret;
-
-	if (isHighDensitySupported())
-		densitySupportFlags |= PNG_VARIOUS_DENSITIES_SUPPORTED;
-	if (isSonyHiResSupported())
-		densitySupportFlags |= PNG_HI_RES_SUPPORTED;
-
-	ds = (struct DrawState *)MemPtrNew(sizeof(struct DrawState));
-	if (!ds)
-		return;
-	MemSet(ds, sizeof(*ds), 0);
-	ds->expectedW = expectedW;
-	ds->expectedH = expectedH;
-	ds->densitySupportFlags = densitySupportFlags;
-
-	ret = pngDrawDecodeCall(ds, data, dataSz);
-	ErrFatalDisplayIf(ret < 0, "Error feeding PNG data!");
-
-	pngDrawRedraw(ds, x, y);
-
-	*dsP = ds;
-}
diff --git a/Src/pngDrawInt.h b/Src/pngDrawInt.h
deleted file mode 100644
index c6595e8..0000000
--- a/Src/pngDrawInt.h
+++ /dev/null
@@ -1,36 +0,0 @@
-#ifndef _PNG_DRAW_INT_H_
-#define _PNG_DRAW_INT_H_
-
-#include <stdbool.h>
-#include <stdint.h>		//avoid PalmOS includes in ARM code
-
-struct BitmapType;
-
-struct DrawState {
-	struct BitmapType *b;
-	uint16_t *bits;
-	
-	uint32_t expectedW;
-	uint32_t expectedH;
-	
-	uint16_t rowHalfwords;
-	uint16_t density;
-	
-	uint8_t densitySupportFlags;
-};
-
-//callback on size
-typedef unsigned char (*PngHdrDecodedCbkF)(struct DrawState *ds, uint32_t width, uint32_t height);
-
-//68k entry
-int pngDrawDecode(struct DrawState *ds, const void *data, uint32_t dataSz, PngHdrDecodedCbkF hdrCbk);
-
-struct ArmParams {
-	struct DrawState *ds;
-	const void *data;
-	uint32_t dataSz;
-	
-	PngHdrDecodedCbkF hdrDecodedF;
-};
-
-#endif
diff --git a/Src/pngle.c b/Src/pngle.c
deleted file mode 100644
index 9213d31..0000000
--- a/Src/pngle.c
+++ /dev/null
@@ -1,947 +0,0 @@
-/*-
- * MIT License
- *
- * Copyright (c) 2019 kikuchan
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-#pragma GCC optimize ("O3")
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <math.h>
-#include <PalmOS.h>
-#include <stdarg.h>
-
-#include "miniz.h"
-#include "pngle.h"
-
-#ifndef MIN
-#define MIN(a, b) ((a) < (b) ? (a) : (b))
-#endif
-
-#ifdef PNGLE_DEBUG
-void debug_printf(const char* fmt, ...) {
-    UInt32 ftrValue;
-    char buffer[256];
-    va_list args;
-
-    if (FtrGet('cldp', 0, &ftrValue) || ftrValue != 0x20150103) return;
-
-    va_start(args, fmt);
-
-    if (StrVPrintF(buffer, fmt, (_Palm_va_list)args) > 255)
-        DbgMessage("DebugLog: buffer overflowed, memory corruption ahead");
-    else
-        DbgMessage(buffer);
-}
-#else
-#define debug_printf(str, ...) ((void)0)
-#endif
-
-#define PNGLE_ERROR(s) (pngle->error = (s), pngle->state = PNGLE_STATE_ERROR, -1)
-#define PNGLE_CALLOC(a, b, name) (debug_printf("[pngle] Allocating %lu bytes for %lu", (size_t)(a) * (size_t)(b), (name)), calloc((size_t)(a), (size_t)(b)))
-
-#define PNGLE_UNUSED(x) (void)(x)
-
-static void debug_printf1(Char *str, UInt32 d) {
-     Char *CurrClass;
-
-    CurrClass = (Char *)MemPtrNew(sizeof(Char[52]));
-    if ((UInt32)CurrClass == 0)
-        return;
-    MemSet(CurrClass, sizeof(Char[52]), 0);
-    StrPrintF(CurrClass, str, d);
-    ErrDisplay(CurrClass);
-    MemPtrFree(CurrClass);
-}
-
-typedef enum {
-	PNGLE_STATE_ERROR = -2,
-	PNGLE_STATE_EOF = -1,
-	PNGLE_STATE_INITIAL = 0,
-
-	PNGLE_STATE_FIND_CHUNK_HEADER,
-	PNGLE_STATE_HANDLE_CHUNK,
-	PNGLE_STATE_CRC,
-} pngle_state_t;
-
-typedef enum {
-// Supported chunks
-//   Filter chunk names by following command to (re)generate hex constants;
-//     % perl -ne 'chomp; s/.*\s*\/\/\s*//; print "\tPNGLE_CHUNK_$_ = 0x" . unpack("H*") . "UL, // $_";'
-	PNGLE_CHUNK_IHDR = 0x49484452UL, // IHDR
-	PNGLE_CHUNK_PLTE = 0x504c5445UL, // PLTE
-	PNGLE_CHUNK_IDAT = 0x49444154UL, // IDAT
-	PNGLE_CHUNK_IEND = 0x49454e44UL, // IEND
-	PNGLE_CHUNK_tRNS = 0x74524e53UL, // tRNS
-	PNGLE_CHUNK_gAMA = 0x67414d41UL, // gAMA
-} pngle_chunk_t;
-
-// typedef struct _pngle_t pngle_t; // declared in pngle.h
-struct _pngle_t {
-	pngle_ihdr_t hdr;
-
-	uint_fast8_t channels; // 0 indicates IHDR hasn't been processed yet
-
-	// PLTE chunk
-	size_t n_palettes;
-	uint8_t *palette;
-
-	// tRNS chunk
-	size_t n_trans_palettes;
-	uint8_t *trans_palette;
-
-	// parser state (reset on every chunk header)
-	pngle_state_t state;
-	uint32_t chunk_type;
-	uint32_t chunk_remain;
-
-#ifndef PNGLE_SKIP_CRC
-	mz_ulong crc32;
-#endif
-
-	// scanline decoder (reset on every set_interlace_pass() call)
-	uint8_t *scanline_ringbuf;
-	size_t scanline_ringbuf_size;
-	size_t scanline_ringbuf_cidx;
-	int_fast8_t scanline_remain_bytes_to_render;
-	int_fast8_t filter_type;
-	uint32_t drawing_x;
-	uint32_t drawing_y;
-
-	// interlace
-	uint_fast8_t interlace_pass;
-
-#ifndef PNGLE_NO_GAMMA_CORRECTION
-	uint8_t *gamma_table;
-	double display_gamma;
-#endif
-
-	// callbacks
-	pngle_init_callback_t init_callback;
-	pngle_done_callback_t done_callback;
-
-	// misc
-	const char *error;
-	void *user_data;
-
-	// decompression state (reset on IHDR)
-	uint8_t *next_out; // NULL indicates IDAT hasn't been processed yet
-	size_t  avail_out;
-	tinfl_decompressor inflator; // 11000 bytes
-	uint8_t lz_buf[TINFL_LZ_DICT_SIZE]; // 32768 bytes
-	struct DrawState *draw_state;
-};
-
-// magic
-static const uint8_t png_sig[] = { 137, 80, 78, 71, 13, 10, 26, 10 };
-static uint32_t interlace_off_x[8] = { 0,  0, 4, 0, 2, 0, 1, 0 };
-static uint32_t interlace_off_y[8] = { 0,  0, 0, 4, 0, 2, 0, 1 };
-static uint32_t interlace_div_x[8] = { 1,  8, 8, 4, 4, 2, 2, 1 };
-static uint32_t interlace_div_y[8] = { 1,  8, 8, 8, 4, 4, 2, 2 };
-
-
-static inline uint8_t  read_uint8(const uint8_t *p)
-{
-	return *p;
-}
-
-static inline uint32_t read_uint32(const uint8_t *p)
-{
-	return (p[0] << 24)
-	     | (p[1] << 16)
-	     | (p[2] <<  8)
-	     | (p[3] <<  0)
-	;
-}
-
-static inline uint32_t U32_CLAMP_ADD(uint32_t a, uint32_t b, uint32_t top)
-{
-	uint32_t v = a + b;
-	if (v < a) return top; // uint32 overflow
-	if (v > top) return top; // clamp
-	return v;
-}
-
-
-void pngle_reset(pngle_t *pngle)
-{
-	if (!pngle) return ;
-
-	pngle->state = PNGLE_STATE_INITIAL;
-	pngle->error = "No error";
-
-	if (pngle->scanline_ringbuf) free(pngle->scanline_ringbuf);
-	if (pngle->palette) free(pngle->palette);
-	if (pngle->trans_palette) free(pngle->trans_palette);
-#ifndef PNGLE_NO_GAMMA_CORRECTION
-	if (pngle->gamma_table) free(pngle->gamma_table);
-#endif
-
-	pngle->scanline_ringbuf = NULL;
-	pngle->palette = NULL;
-	pngle->trans_palette = NULL;
-#ifndef PNGLE_NO_GAMMA_CORRECTION
-	pngle->gamma_table = NULL;
-#endif
-
-	pngle->channels = 0; // indicates IHDR hasn't been processed yet
-	pngle->next_out = NULL; // indicates IDAT hasn't been processed yet
-
-	// clear them just in case...
-	memset(&pngle->hdr, 0, sizeof(pngle->hdr));
-	pngle->n_palettes = 0;
-	pngle->n_trans_palettes = 0;
-
-	tinfl_init(&pngle->inflator);
-}
-
-pngle_t *pngle_new()
-{
-	pngle_t *pngle = (pngle_t *)PNGLE_CALLOC(1, sizeof(pngle_t), "pngle_t");
-	if (!pngle) return NULL;
-
-	pngle_reset(pngle);
-
-	return pngle;
-}
-
-void pngle_destroy(pngle_t *pngle)
-{
-	if (pngle) {
-		pngle_reset(pngle);
-		free(pngle);
-	}
-}
-
-const char *pngle_error(pngle_t *pngle)
-{
-	if (!pngle) return "Uninitialized";
-	return pngle->error;
-}
-
-uint32_t pngle_get_width(pngle_t *pngle)
-{
-	if (!pngle) return 0;
-	return pngle->hdr.width;
-}
-
-uint32_t pngle_get_height(pngle_t *pngle)
-{
-	if (!pngle) return 0;
-	return pngle->hdr.height;
-}
-
-pngle_ihdr_t *pngle_get_ihdr(pngle_t *pngle)
-{
-	if (!pngle) return NULL;
-	if (pngle->channels == 0) return NULL;
-	return &pngle->hdr;
-}
-
-
-static int is_trans_color(pngle_t *pngle, uint16_t *value, size_t n)
-{
-	if (pngle->n_trans_palettes != 1) return 0; // false (none or indexed)
-
-	for (size_t i = 0; i < n; i++) {
-		if (value[i] != (pngle->trans_palette[i * 2 + 0] * 0x100 + pngle->trans_palette[i * 2 + 1])) return 0; // false
-	}
-	return 1; // true
-}
-
-static inline void scanline_ringbuf_push(pngle_t *pngle, uint8_t value)
-{
-	pngle->scanline_ringbuf[pngle->scanline_ringbuf_cidx] = value;
-	pngle->scanline_ringbuf_cidx = (pngle->scanline_ringbuf_cidx + 1) % pngle->scanline_ringbuf_size;
-}
-
-static inline uint16_t get_value(pngle_t *pngle, size_t *ridx, int *bitcount, int depth)
-{
-	uint16_t v;
-
-	switch (depth) {
-	case 1:
-	case 2:
-	case 4:
-		if (*bitcount >= 8) {
-			*bitcount = 0;
-			*ridx = (*ridx + 1) % pngle->scanline_ringbuf_size;
-		}
-		*bitcount += depth;
-		uint8_t mask = ((1UL << depth) - 1);
-		uint8_t shift = (8 - *bitcount);
-		return (pngle->scanline_ringbuf[*ridx] >> shift) & mask;
-
-	case 8:
-		v = pngle->scanline_ringbuf[*ridx];
-		*ridx = (*ridx + 1) % pngle->scanline_ringbuf_size;
-		return v;
-
-	case 16:
-		v = pngle->scanline_ringbuf[*ridx];
-		*ridx = (*ridx + 1) % pngle->scanline_ringbuf_size;
-
-		v = v * 0x100 + pngle->scanline_ringbuf[*ridx];
-		*ridx = (*ridx + 1) % pngle->scanline_ringbuf_size;
-		return v;
-	}
-
-	return 0;
-}
-
-static int pngle_draw_pixels(pngle_t *pngle, size_t scanline_ringbuf_xidx)
-{
-	uint16_t v[4] = {}; // MAX_CHANNELS
-	int bitcount = 0;
-	uint8_t pixel_depth = (pngle->hdr.color_type & 1) ? 8 : pngle->hdr.depth;
-	uint16_t maxval = (1UL << pixel_depth) - 1;
-
-	int n_pixels = pngle->hdr.depth == 16 ? 1 : (8 / pngle->hdr.depth);
-
-	for (; n_pixels-- > 0 && pngle->drawing_x < pngle->hdr.width; pngle->drawing_x = U32_CLAMP_ADD(pngle->drawing_x, interlace_div_x[pngle->interlace_pass], pngle->hdr.width)) {
-		for (uint_fast8_t c = 0; c < pngle->channels; c++) {
-			v[c] = get_value(pngle, &scanline_ringbuf_xidx, &bitcount, pngle->hdr.depth);
-		}
-
-		// color type: 0000 0111
-		//                     ^-- indexed color (palette)
-		//                    ^--- Color
-		//                   ^---- Alpha channel
-
-		if (pngle->hdr.color_type & 2) {
-			// color
-			if (pngle->hdr.color_type & 1) {
-				// indexed color: type 3
-
-				// lookup palette info
-				uint16_t pidx = v[0];
-				if (pidx >= pngle->n_palettes) return PNGLE_ERROR("Color index is out of range");
-
-				v[0] = pngle->palette[pidx * 3 + 0];
-				v[1] = pngle->palette[pidx * 3 + 1];
-				v[2] = pngle->palette[pidx * 3 + 2];
-
-				// tRNS as an indexed alpha value table (for color type 3)
-				v[3] = pidx < pngle->n_trans_palettes ? pngle->trans_palette[pidx] : maxval;
-			} else {
-				// true color: 2, and 6
-				v[3] = (pngle->hdr.color_type & 4) ? v[3] : is_trans_color(pngle, v, 3) ? 0 : maxval;
-			}
-		} else {
-			// alpha, tRNS, or opaque
-			v[3] = (pngle->hdr.color_type & 4) ? v[1] : is_trans_color(pngle, v, 1) ? 0 : maxval;
-
-			// monochrome
-			v[1] = v[2] = v[0];
-		}
-
-		uint8_t rgba[4];
-		if (pixel_depth != 8) {
-			v[0] = (v[0] * 255 + maxval / 2) / maxval;
-			v[1] = (v[1] * 255 + maxval / 2) / maxval;
-			v[2] = (v[2] * 255 + maxval / 2) / maxval;
-			v[3] = (v[3] * 255 + maxval / 2) / maxval;
-		};
-
-#ifndef PNGLE_NO_GAMMA_CORRECTION
-		if (pngle->gamma_table) {
-			for (int i = 0; i < 3; i++) {
-				v[i] = pngle->gamma_table[v[i]];
-			}
-		}
-#endif
-		on_draw(pngle, pngle->drawing_x, pngle->drawing_y, v[0], v[1], v[2], v[3], pngle->draw_state);
-	}
-
-	return 0;
-}
-
-static inline int paeth(int a, int b, int c)
-{
-	int p = a + b - c;
-	int pa = abs(p - a);
-	int pb = abs(p - b);
-	int pc = abs(p - c);
-
-	if (pa <= pb && pa <= pc) return a;
-	if (pb <= pc) return b;
-	return c;
-}
-
-static int set_interlace_pass(pngle_t *pngle, uint_fast8_t pass)
-{
-	pngle->interlace_pass = pass;
-
-	uint_fast8_t bytes_per_pixel = (pngle->channels * pngle->hdr.depth + 7) / 8; // 1 if depth <= 8
-	size_t scanline_pixels = (pngle->hdr.width - interlace_off_x[pngle->interlace_pass] + interlace_div_x[pngle->interlace_pass] - 1) / interlace_div_x[pngle->interlace_pass];
-	size_t scanline_stride = (scanline_pixels * pngle->channels * pngle->hdr.depth + 7) / 8;
-
-	pngle->scanline_ringbuf_size = scanline_stride + bytes_per_pixel * 2; // 2 rooms for c/x and a
-
-	if (pngle->scanline_ringbuf) free(pngle->scanline_ringbuf);
-	if ((pngle->scanline_ringbuf = PNGLE_CALLOC(pngle->scanline_ringbuf_size, 1, "scanline ringbuf")) == NULL) return PNGLE_ERROR("Insufficient memory");
-
-	pngle->drawing_x = interlace_off_x[pngle->interlace_pass];
-	pngle->drawing_y = interlace_off_y[pngle->interlace_pass];
-	pngle->filter_type = -1;
-
-	pngle->scanline_ringbuf_cidx = 0;
-	pngle->scanline_remain_bytes_to_render = -1;
-
-	return 0;
-}
-
-static int setup_gamma_table(pngle_t *pngle, uint32_t png_gamma)
-{
-#ifndef PNGLE_NO_GAMMA_CORRECTION
-	if (pngle->gamma_table) free(pngle->gamma_table);
-
-	if (pngle->display_gamma <= 0) return 0; // disable gamma correction
-	if (png_gamma == 0) return 0;
-
-	uint8_t pixel_depth = (pngle->hdr.color_type & 1) ? 8 : pngle->hdr.depth;
-	uint16_t maxval = (1UL << pixel_depth) - 1;
-
-	pngle->gamma_table = PNGLE_CALLOC(1, maxval + 1, "gamma table");
-	if (!pngle->gamma_table) return PNGLE_ERROR("Insufficient memory");
-
-	for (int i = 0; i < maxval + 1; i++) {
-		pngle->gamma_table[i] = (uint8_t)floor(pow(i / (double)maxval, 100000.0 / png_gamma / pngle->display_gamma) * 255.0 + 0.5);
-	}
-	debug_printf("[pngle] gamma value = %d", png_gamma);
-#else
-	PNGLE_UNUSED(pngle);
-	PNGLE_UNUSED(png_gamma);
-#endif
-	return 0;
-}
-
-
-static int pngle_on_data(pngle_t *pngle, const uint8_t *p, int len)
-{
-	const uint8_t *ep = p + len;
-
-	uint_fast8_t bytes_per_pixel = (pngle->channels * pngle->hdr.depth + 7) / 8; // 1 if depth <= 8
-
-	while (p < ep) {
-		if (pngle->drawing_x >= pngle->hdr.width) {
-			// New row
-			pngle->drawing_x = interlace_off_x[pngle->interlace_pass];
-			pngle->drawing_y = U32_CLAMP_ADD(pngle->drawing_y, interlace_div_y[pngle->interlace_pass], pngle->hdr.height);
-			pngle->filter_type = -1; // Indicate new line
-		}
-
-		if (pngle->drawing_x >= pngle->hdr.width || pngle->drawing_y >= pngle->hdr.height) {
-			if (pngle->interlace_pass == 0 || pngle->interlace_pass >= 7) return len; // Do nothing further
-
-			// Interlace: Next pass
-			if (set_interlace_pass(pngle, pngle->interlace_pass + 1) < 0) return -1;
-			debug_printf("[pngle] interlace pass changed to: %ld", pngle->interlace_pass);
-
-			continue; // This is required because "No filter type bytes are present in an empty pass".
-		}
-
-		if (pngle->filter_type < 0) {
-			if (*p > 4) {
-				debug_printf("[pngle] Invalid filter type is found; 0x%02x", *p);
-				return PNGLE_ERROR("Invalid filter type is found");
-			}
-
-			pngle->filter_type = (int_fast8_t)*p++; // 0 - 4
-
-			// push sentinel bytes for new line
-			for (uint_fast8_t i = 0; i < bytes_per_pixel; i++) {
-				scanline_ringbuf_push(pngle, 0);
-			}
-
-			continue;
-		}
-
-		size_t cidx =  pngle->scanline_ringbuf_cidx;
-		size_t bidx = (pngle->scanline_ringbuf_cidx                                + bytes_per_pixel) % pngle->scanline_ringbuf_size;
-		size_t aidx = (pngle->scanline_ringbuf_cidx + pngle->scanline_ringbuf_size - bytes_per_pixel) % pngle->scanline_ringbuf_size;
-		// debug_printf("[pngle] cidx = %zd, bidx = %zd, aidx = %zd", cidx, bidx, aidx);
-
-		uint8_t c = pngle->scanline_ringbuf[cidx]; // left-up
-		uint8_t b = pngle->scanline_ringbuf[bidx]; // up
-		uint8_t a = pngle->scanline_ringbuf[aidx]; // left
-		uint8_t x = *p++; // target
-		// debug_printf("[pngle] c = 0x%02x, b = 0x%02x, a = 0x%02x, x = 0x%02x", c, b, a, x);
-
-		// Reverse the filter
-		switch (pngle->filter_type) {
-		case 0: break; // None
-		case 1: x += a; break; // Sub
-		case 2: x += b; break; // Up
-		case 3: x += (a + b) / 2; break; // Average
-		case 4: x += paeth(a, b, c); break; // Paeth
-		}
-
-		scanline_ringbuf_push(pngle, x); // updates scanline_ringbuf_cidx
-
-		if (pngle->scanline_remain_bytes_to_render < 0) pngle->scanline_remain_bytes_to_render = bytes_per_pixel;
-		if (--pngle->scanline_remain_bytes_to_render == 0) {
-			size_t xidx = (pngle->scanline_ringbuf_cidx + pngle->scanline_ringbuf_size - bytes_per_pixel) % pngle->scanline_ringbuf_size;
-
-			if (pngle_draw_pixels(pngle, xidx) < 0) return -1;
-
-			pngle->scanline_remain_bytes_to_render = -1; // reset
-		}
-	}
-
-	return len;
-}
-
-
-static int pngle_handle_chunk(pngle_t *pngle, const uint8_t *buf, size_t len)
-{
-	size_t consume = 0;
-
-	switch (pngle->chunk_type) {
-	case PNGLE_CHUNK_IHDR:
-		// parse IHDR
-		consume = 13;
-		if (len < consume) return 0;
-
-		debug_printf("[pngle]   Parse IHDR");
-
-		pngle->hdr.width       = read_uint32(buf +  0);
-		pngle->hdr.height      = read_uint32(buf +  4);
-		pngle->hdr.depth       = read_uint8 (buf +  8);
-		pngle->hdr.color_type  = read_uint8 (buf +  9);
-		pngle->hdr.compression = read_uint8 (buf + 10);
-		pngle->hdr.filter      = read_uint8 (buf + 11);
-		pngle->hdr.interlace   = read_uint8 (buf + 12);
-
-
-		debug_printf("[pngle]     width      : %ld", pngle->hdr.width);
-		debug_printf("[pngle]     height     : %ld", pngle->hdr.height     );
-		debug_printf("[pngle]     depth      : %ld", pngle->hdr.depth      );
-		debug_printf("[pngle]     color_type : %ld", pngle->hdr.color_type );
-		debug_printf("[pngle]     compression: %ld", pngle->hdr.compression);
-		debug_printf("[pngle]     filter     : %ld", pngle->hdr.filter     );
-		debug_printf("[pngle]     interlace  : %ld", pngle->hdr.interlace  );
-
-		/*
-            Color    Allowed    Interpretation                            channels
-            Type    Bit Depths
-
-            0       1,2,4,8,16  Each pixel is a grayscale sample.         1 channels (Brightness)
-
-            2       8,16        Each pixel is an R,G,B triple.            3 channels (R, G, B)
-
-            3       1,2,4,8     Each pixel is a palette index;            1 channels (palette info)
-                                a PLTE chunk must appear.
-
-            4       8,16        Each pixel is a grayscale sample,         2 channels (Brightness, Alpha)
-                                followed by an alpha sample.
-
-            6       8,16        Each pixel is an R,G,B triple,            4 channels (R, G, B, Alpha)
-                                followed by an alpha sample.
-		*/
-		//  111
-		//    ^-- indexed color (palette)
-		//   ^--- Color
-		//  ^---- Alpha channel
-
-		switch (pngle->hdr.color_type) {
-		case 0: pngle->channels = 1; if (pngle->hdr.depth != 1 && pngle->hdr.depth != 2 && pngle->hdr.depth != 4 && pngle->hdr.depth != 8 && pngle->hdr.depth != 16) return PNGLE_ERROR("Invalid bit depth"); break; // grayscale
-		case 2: pngle->channels = 3; if (                                                                           pngle->hdr.depth != 8 && pngle->hdr.depth != 16) return PNGLE_ERROR("Invalid bit depth"); break; // truecolor
-		case 3: pngle->channels = 1; if (pngle->hdr.depth != 1 && pngle->hdr.depth != 2 && pngle->hdr.depth != 4 && pngle->hdr.depth != 8                          ) return PNGLE_ERROR("Invalid bit depth"); break; // indexed color
-		case 4: pngle->channels = 2; if (                                                                           pngle->hdr.depth != 8 && pngle->hdr.depth != 16) return PNGLE_ERROR("Invalid bit depth"); break; // grayscale + alpha
-		case 6: pngle->channels = 4; if (                                                                           pngle->hdr.depth != 8 && pngle->hdr.depth != 16) return PNGLE_ERROR("Invalid bit depth"); break; // truecolor + alpha
-		default:
-			return PNGLE_ERROR("Incorrect IHDR info");
-		}
-
-		if (pngle->hdr.compression != 0) return PNGLE_ERROR("Unsupported compression type in IHDR");
-		if (pngle->hdr.filter      != 0) return PNGLE_ERROR("Unsupported filter type in IHDR");
-
-		// interlace
-		if (set_interlace_pass(pngle, pngle->hdr.interlace ? 1 : 0) < 0) return -1;
-
-		// callback
-		if (pngle->init_callback && !pngle->init_callback(pngle->draw_state, pngle->hdr.width, pngle->hdr.height))
-			return PNGLE_ERROR("Image decode rejected by user");
-
-		break;
-
-	case PNGLE_CHUNK_IDAT:
-		// parse & decode IDAT chunk
-		if (len < 1) return 0;
-
-		debug_printf("[pngle]   Reading IDAT (len %lu / chunk remain %lu)", len, pngle->chunk_remain);
-
-		size_t in_bytes  = len;
-		size_t out_bytes = pngle->avail_out;
-
-		//debug_printf("[pngle]     in_bytes %zd, out_bytes %zd, next_out %p", in_bytes, out_bytes, pngle->next_out);
-
-		// XXX: tinfl_decompress always requires (next_out - lz_buf + avail_out) == TINFL_LZ_DICT_SIZE
-		tinfl_status status = tinfl_decompress(
-			&pngle->inflator,
-			(const mz_uint8 *)buf,
-			&in_bytes,
-			pngle->lz_buf,
-			(mz_uint8 *)pngle->next_out,
-		 	&out_bytes, 
-			TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_PARSE_ZLIB_HEADER
-		);
-
-		//debug_printf("[pngle]       tinfl_decompress");
-		//debug_printf("[pngle]       => in_bytes %zd, out_bytes %zd, next_out %p, status %d", in_bytes, out_bytes, pngle->next_out, status);
-
-	#ifndef __ARM__
- 		Char *CurrClass;
-
-		CurrClass = (Char *)MemPtrNew(sizeof(Char[85]));
-		if ((UInt32)CurrClass == 0)
-			return 0;
-		MemSet(CurrClass, sizeof(Char[85]), 0);
-		StrPrintF(CurrClass, "[pngle]       => in_bytes %ld, out_bytes %ld, next_out %ld, status %ld", in_bytes, out_bytes, pngle->next_out, status);
-		ErrNonFatalDisplay(CurrClass);
-		MemPtrFree(CurrClass);
-	#endif
-
-		if (status < TINFL_STATUS_DONE) {
-			// Decompression failed.
-			debug_printf("[pngle] tinfl_decompress() failed with status %ld!\n", status);
-			return PNGLE_ERROR("Failed to decompress the IDAT stream");
-            // Char *CurrClass;
-
-            // CurrClass = (Char *)MemPtrNew(sizeof(Char[52]));
-            // if ((UInt32)CurrClass == 0)
-            //     return;
-            // MemSet(CurrClass, sizeof(Char[52]), 0);
-            // StrPrintF(CurrClass, "[pngle] tinfl_decompress() failed with status %ld!", status);
-			// ErrDisplay(CurrClass);
-            // MemPtrFree(CurrClass);
-			// return PNGLE_ERROR("Failed to decompress the IDAT stream");
-		}
-
-		pngle->next_out   += out_bytes;
-		pngle->avail_out  -= out_bytes;
-
-		// debug_printf("[pngle]         => avail_out %zd, next_out %p", pngle->avail_out, pngle->next_out);
-
-		if (status == TINFL_STATUS_DONE || pngle->avail_out == 0) {
-			// Output buffer is full, or decompression is done, so write buffer to output file.
-			// XXX: This is the only chance to process the buffer.
-			uint8_t *read_ptr = pngle->lz_buf;
-			size_t n = TINFL_LZ_DICT_SIZE - (size_t)pngle->avail_out;
-
-			// pngle_on_data() usually returns n, otherwise -1 on error
-			if (pngle_on_data(pngle, read_ptr, n) < 0) return -1;
-
-			// XXX: tinfl_decompress always requires (next_out - lz_buf + avail_out) == TINFL_LZ_DICT_SIZE
-			pngle->next_out = pngle->lz_buf;
-			pngle->avail_out = TINFL_LZ_DICT_SIZE;
-		}
-
-		consume = in_bytes;
-		break;
-
-	case PNGLE_CHUNK_PLTE:
-		consume = 3;
-		if (len < consume) return 0;
-
-		memcpy(pngle->palette + pngle->n_palettes * 3, buf, 3);
-
-		debug_printf("[pngle] PLTE[%ld]: (%ld, %ld, %ld)"
-			, pngle->n_palettes
-			, pngle->palette[pngle->n_palettes * 3 + 0]
-			, pngle->palette[pngle->n_palettes * 3 + 1]
-			, pngle->palette[pngle->n_palettes * 3 + 2]
-		);
-
-		pngle->n_palettes++;
-
-		break;
-
-	case PNGLE_CHUNK_IEND:
-		consume = 0;
-		break;
-
-	case PNGLE_CHUNK_tRNS:
-		switch (pngle->hdr.color_type) {
-		case 3: consume =     1; break;
-		case 0: consume = 2 * 1; break;
-		case 2: consume = 2 * 3; break;
-		default:
-			return PNGLE_ERROR("tRNS chunk is prohibited on the color type");
-		}
-		if (len < consume) return 0;
-
-		memcpy(pngle->trans_palette + pngle->n_trans_palettes, buf, consume);
-
-		pngle->n_trans_palettes++;
-
-		break;
-
-	case PNGLE_CHUNK_gAMA:
-		consume = 4;
-		if (len < consume) return 0;
-
-		if (setup_gamma_table(pngle, read_uint32(buf)) < 0) return -1;
-
-		break;
-
-	default:
-		// unknown chunk
-		consume = len;
-
-		debug_printf("[pngle] Unknown chunk; %ld bytes discarded", consume);
-		break;
-	}
-
-	return consume;
-}
-
-static int pngle_feed_internal(pngle_t *pngle, const uint8_t *buf, size_t len)
-{
-	if (!pngle) return -1;
-
-	switch (pngle->state) {
-	case PNGLE_STATE_ERROR:
-		return -1;
-
-	case PNGLE_STATE_EOF:
-		return len;
-
-	case PNGLE_STATE_INITIAL:
-		// find PNG header
-		if (len < sizeof(png_sig)) return 0;
-
-		if (memcmp(png_sig, buf, sizeof(png_sig)))
-        {
-            return PNGLE_ERROR("Incorrect PNG signature");
-        } 
-
-		debug_printf("[pngle] PNG signature found");
-
-		pngle->state = PNGLE_STATE_FIND_CHUNK_HEADER;
-		return sizeof(png_sig);
-
-	case PNGLE_STATE_FIND_CHUNK_HEADER:
-		if (len < 8) return 0;
-
-		pngle->chunk_remain = read_uint32(buf);
-		pngle->chunk_type = read_uint32(buf + 4);
-
-#ifndef PNGLE_SKIP_CRC
-		pngle->crc32 = mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)(buf + 4), 4);
-#endif
-
-		debug_printf("[pngle] Chunk '%ld' len %lu", buf + 4, pngle->chunk_remain);
-
-		pngle->state = PNGLE_STATE_HANDLE_CHUNK;
-
-		// initialize & sanity check
-		switch (pngle->chunk_type) {
-		case PNGLE_CHUNK_IHDR:
-			if (pngle->chunk_remain != 13){
-                return PNGLE_ERROR("Invalid IHDR chunk size");
-            } 
-			if (pngle->channels != 0) return PNGLE_ERROR("Multiple IHDR chunks are not allowed");
-			break;
-
-		case PNGLE_CHUNK_IDAT:
-			if (pngle->chunk_remain <= 0) return PNGLE_ERROR("Invalid IDAT chunk size");
-			if (pngle->channels == 0) return PNGLE_ERROR("No IHDR chunk is found");
-			if (pngle->hdr.color_type == 3 && pngle->palette == NULL) return PNGLE_ERROR("No PLTE chunk is found");
-
-			if (pngle->next_out == NULL) {
-				// Very first IDAT
-				pngle->next_out = pngle->lz_buf;
-				pngle->avail_out = TINFL_LZ_DICT_SIZE;
-			}
-			break;
-
-		case PNGLE_CHUNK_PLTE:
-			if (pngle->chunk_remain <= 0) return PNGLE_ERROR("Invalid PLTE chunk size");
-			if (pngle->channels == 0) return PNGLE_ERROR("No IHDR chunk is found");
-			if (pngle->palette) return PNGLE_ERROR("Too many PLTE chunk");
-
-			switch (pngle->hdr.color_type) {
-			case 3: // indexed color
-				break;
-			case 2: // truecolor
-			case 6: // truecolor + alpha
-				// suggested palettes
-				break;
-			default:
-				return PNGLE_ERROR("PLTE chunk is prohibited on the color type");
-			}
-
-			if (pngle->chunk_remain % 3) return PNGLE_ERROR("Invalid PLTE chunk size");
-			if (pngle->chunk_remain / 3 > MIN(256, (1UL << pngle->hdr.depth))) return PNGLE_ERROR("Too many palettes in PLTE");
-			if ((pngle->palette = PNGLE_CALLOC(pngle->chunk_remain / 3, 3, "palette")) == NULL) return PNGLE_ERROR("Insufficient memory");
-			pngle->n_palettes = 0;
-			break;
-
-		case PNGLE_CHUNK_IEND:
-			if (pngle->next_out == NULL) return PNGLE_ERROR("No IDAT chunk is found");
-			if (pngle->chunk_remain > 0) return PNGLE_ERROR("Invalid IEND chunk size");
-			break;
-
-		case PNGLE_CHUNK_tRNS:
-			if (pngle->chunk_remain <= 0) return PNGLE_ERROR("Invalid tRNS chunk size");
-			if (pngle->channels == 0) return PNGLE_ERROR("No IHDR chunk is found");
-			if (pngle->trans_palette) return PNGLE_ERROR("Too many tRNS chunk");
-
-			switch (pngle->hdr.color_type) {
-			case 3: // indexed color
-				if (pngle->chunk_remain > (1UL << pngle->hdr.depth)) return PNGLE_ERROR("Too many palettes in tRNS");
-				break;
-			case 0: // grayscale
-				if (pngle->chunk_remain != 2) return PNGLE_ERROR("Invalid tRNS chunk size");
-				break;
-			case 2: // truecolor
-				if (pngle->chunk_remain != 6) return PNGLE_ERROR("Invalid tRNS chunk size");
-				break;
-
-			default:
-				return PNGLE_ERROR("tRNS chunk is prohibited on the color type");
-			}
-			if ((pngle->trans_palette = PNGLE_CALLOC(pngle->chunk_remain, 1, "trans palette")) == NULL) return PNGLE_ERROR("Insufficient memory");
-			pngle->n_trans_palettes = 0;
-			break;
-
-		default:
-			break;
-		}
-
-		return 8;
-
-	case PNGLE_STATE_HANDLE_CHUNK:
-		len = MIN(len, pngle->chunk_remain);
-
-		int consumed = pngle_handle_chunk(pngle, buf, len);
-
-		if (consumed > 0) {
-			if (pngle->chunk_remain < (uint32_t)consumed) return PNGLE_ERROR("Chunk data has been consumed too much");
-
-			pngle->chunk_remain -= consumed;
-#ifndef PNGLE_SKIP_CRC
-			pngle->crc32 = mz_crc32(pngle->crc32, (const mz_uint8 *)buf, consumed);
-#endif
-		}
-		if (pngle->chunk_remain <= 0) pngle->state = PNGLE_STATE_CRC;
-
-		return consumed;
-
-	case PNGLE_STATE_CRC:
-		if (len < 4) return 0;
-
-#ifndef PNGLE_SKIP_CRC
-		uint32_t crc32 = read_uint32(buf);
-
-		if (crc32 != pngle->crc32) {
-			debug_printf("[pngle] CRC: %08x vs %08x => NG", crc32, (uint32_t)pngle->crc32);
-			return PNGLE_ERROR("CRC mismatch");
-		}
-		debug_printf("[pngle] CRC: %08x vs %08x => OK", crc32, (uint32_t)pngle->crc32);
-#endif
-		pngle->state = PNGLE_STATE_FIND_CHUNK_HEADER;
-
-		// XXX:
-		if (pngle->chunk_type == PNGLE_CHUNK_IEND) {
-			pngle->state = PNGLE_STATE_EOF;
-			if (pngle->done_callback) pngle->done_callback(pngle);
-			debug_printf("[pngle] DONE");
-		}
-
-		return 4;
-
-	default:
-		break;
-	}
-
-	return PNGLE_ERROR("Invalid state");
-}
-
-int pngle_feed(pngle_t *pngle, const void *buf, size_t len)
-{
-	size_t pos = 0;
-	pngle_state_t last_state = pngle->state;
-
-	while (pos < len) {
-		int r = pngle_feed_internal(pngle, (const uint8_t *)buf + pos, len - pos);
-		if (r < 0) {
-#ifndef __ARM__
-            ErrDisplay(pngle->error);
-#endif
-            return r; // error
-        } 
-
-		if (r == 0 && last_state == pngle->state) break;
-		last_state = pngle->state;
-
-		pos += r;
-	}
-
-	return pos;
-}
-
-void pngle_set_display_gamma(pngle_t *pngle, double display_gamma)
-{
-	if (!pngle) return ;
-#ifndef PNGLE_NO_GAMMA_CORRECTION
-	pngle->display_gamma = display_gamma;
-#else
-	PNGLE_UNUSED(display_gamma);
-#endif
-}
-
-void pngle_set_init_callback(pngle_t *pngle, pngle_init_callback_t callback)
-{
-	if (!pngle) return ;
-	pngle->init_callback = callback;
-}
-
-void pngle_set_draw_callback(pngle_t *pngle, struct DrawState *ds)
-{
-	if (!pngle) return ;
-	pngle->draw_state = ds;
-}
-
-void pngle_set_done_callback(pngle_t *pngle, pngle_done_callback_t callback)
-{
-	if (!pngle) return ;
-	pngle->done_callback = callback;
-}
-
-void pngle_set_user_data(pngle_t *pngle, void *user_data)
-{
-	if (!pngle) return ;
-	pngle->user_data = user_data;
-}
-
-void *pngle_get_user_data(pngle_t *pngle)
-{
-	if (!pngle) return NULL;
-	return pngle->user_data;
-}
-
-/* vim: set ts=4 sw=4 noexpandtab: */
diff --git a/Src/pngle.h b/Src/pngle.h
deleted file mode 100644
index af6427a..0000000
--- a/Src/pngle.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*-
- * MIT License
- *
- * Copyright (c) 2019 kikuchan
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-#ifndef __PNGLE_H__
-#define __PNGLE_H__
-
-#include <stdint.h>
-#include <stddef.h>
-//#include <Src/Palmkedex.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define PNGLE_SKIP_CRC
-
-struct DrawState;
-
-// Main Pngle object
-typedef struct _pngle_t pngle_t;
-
-// Callback signatures
-typedef unsigned char (*pngle_init_callback_t)(struct DrawState *ds, uint32_t w, uint32_t h);		//return 0 to bail out
-typedef void (*pngle_done_callback_t)(pngle_t *pngle);
-
-// ----------------
-// Basic interfaces
-// ----------------
-pngle_t *pngle_new();
-void pngle_destroy(pngle_t *pngle);
-void pngle_reset(pngle_t *pngle); // clear its internal state (not applied to pngle_set_* functions)
-const char *pngle_error(pngle_t *pngle);
-int pngle_feed(pngle_t *pngle, const void *buf, size_t len); // returns -1: On error, 0: Need more data, n: n bytes eaten
-
-uint32_t pngle_get_width(pngle_t *pngle);
-uint32_t pngle_get_height(pngle_t *pngle);
-
-void pngle_set_init_callback(pngle_t *png, pngle_init_callback_t callback);
-void pngle_set_draw_callback(pngle_t *png, struct DrawState *ds);
-void pngle_set_done_callback(pngle_t *png, pngle_done_callback_t callback);
-
-void pngle_set_display_gamma(pngle_t *pngle, double display_gamma); // enables gamma correction by specifying display gamma, typically 2.2. No effect when gAMA chunk is missing
-
-void pngle_set_user_data(pngle_t *pngle, void *user_data);
-void *pngle_get_user_data(pngle_t *pngle);
-
-// ----------------
-// Provided externally, linked directly for speed
-// ----------------
-void on_draw(pngle_t *pngle, uint_fast16_t x, uint_fast16_t y, uint_fast16_t vR, uint_fast16_t vG, uint_fast16_t vB, uint_fast16_t vA, struct DrawState *ds);
- 
-// ----------------
-// Debug interfaces
-// ----------------
-
-typedef struct _pngle_ihdr_t {
-	uint32_t width;
-	uint32_t height;
-	uint8_t depth;
-	uint8_t color_type;
-	uint8_t compression;
-	uint8_t filter;
-	uint8_t interlace;
-} pngle_ihdr_t;
-
-// Get IHDR information
-pngle_ihdr_t *pngle_get_ihdr(pngle_t *pngle);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __PNGLE_H__ */
\ No newline at end of file
diff --git a/gccisms/PalmTypes.h b/gccisms/PalmTypes.h
index 1c05d05..0584719 100644
--- a/gccisms/PalmTypes.h
+++ b/gccisms/PalmTypes.h
@@ -91,7 +91,7 @@ typedef Int32 (*ProcPtr)();
  *************************************************************/
 
 // The min() and max() macros which used to be defined here have been removed
-// because they conflicted with facilities in C.  If you need them, you
+// because they conflicted with facilities in C++.  If you need them, you
 // should define them yourself, or see PalmUtils.h -- but please read the
 // comments in that file before using it in your own projects.
 
@@ -202,10 +202,10 @@ typedef Int32 (*ProcPtr)();
 
 	#if 1
 
-		#define _OS_CALL(table, vector)												__attribute__((__raw_inline__(0x4E40  table, vector)));
-		#define _OS_CALL_WITH_SELECTOR(table, vector, selector)						__attribute__((__raw_inline__(0x7400  selector, 0x4E40  table, vector)));
-		#define _OS_CALL_WITH_16BIT_SELECTOR(table, vector, selector)				__attribute__((__raw_inline__(0x3F3C, selector, 0x4E40  table, vector, 0x544F)));
-		#define _OS_CALL_WITH_UNPOPPED_16BIT_SELECTOR(table, vector, selector)		__attribute__((__raw_inline__(0x3F3C, selector, 0x4E40  table, vector)));
+		#define _OS_CALL(table, vector)												__attribute__((__raw_inline__(0x4E40 + table, vector)));
+		#define _OS_CALL_WITH_SELECTOR(table, vector, selector)						__attribute__((__raw_inline__(0x7400 + selector, 0x4E40 + table, vector)));
+		#define _OS_CALL_WITH_16BIT_SELECTOR(table, vector, selector)				__attribute__((__raw_inline__(0x3F3C, selector, 0x4E40 + table, vector, 0x544F)));
+		#define _OS_CALL_WITH_UNPOPPED_16BIT_SELECTOR(table, vector, selector)		__attribute__((__raw_inline__(0x3F3C, selector, 0x4E40 + table, vector)));
 
 //__attribute__((__raw_inline__(word1, word2, word3)))
 
@@ -252,13 +252,13 @@ typedef Int32 (*ProcPtr)();
 #elif defined (__MWERKS__)	/* The equivalent in CodeWarrior syntax */
 
 	#define _OS_CALL(table, vector) \
-		= { 0x4E40  table, vector }
+		= { 0x4E40 + table, vector }
 
 	#define _OS_CALL_WITH_SELECTOR(table, vector, selector) \
-		= { 0x7400  selector, 0x4E40  table, vector }
+		= { 0x7400 + selector, 0x4E40 + table, vector }
 
 	#define _OS_CALL_WITH_16BIT_SELECTOR(table, vector, selector) \
-		= { 0x3F3C, selector, 0x4E40  table, vector, 0x544F }
+		= { 0x3F3C, selector, 0x4E40 + table, vector, 0x544F }
 
 #endif
 
@@ -308,8 +308,8 @@ typedef Int32 (*ProcPtr)();
 #define SYS_TRAP(trapNum)  _SYSTEM_API(_CALL)(_SYSTEM_TABLE, trapNum)
 	
 #define ASM_SYS_TRAP(trapNum)	\
-			DC.W	m68kTrapInstrsysDispatchTrapNum; \
+			DC.W	m68kTrapInstr+sysDispatchTrapNum; \
 			DC.W	trapNum
 	
 
-#endif //__PALMTYPES_H__
\ No newline at end of file
+#endif //__PALMTYPES_H__
diff --git a/tools/aci/README.txt b/tools/aci/README.txt
new file mode 100644
index 0000000..465807c
--- /dev/null
+++ b/tools/aci/README.txt
@@ -0,0 +1,12 @@
+ACI (Adequately Compressed Image) Format is an image compression format designed for low-colour-number sprites with a few major colours.
+The format optionally supports a colour table (for colour images). Greyscale images do not provide a colour table and thus save space.
+The file format is maximally smiple and optimized for adequate decoding speed on the m68k platform. The first four bytes in the file are width and height, in big-endian 16-bit format. Then comes a single flags/version byte. wWat follows depends on it. Currently only version 1 of the format is defined, which is designated by the bit #0 of the flags/version byte being set. If so, the other bits in the byte are as follows: bit #1 - set if there is a colour table. Other bits reserved and must be clear. Next comes a byte (called numColoursM2) specifying how many colours the bitmap has. It is offset by one, thus a value of 7 means that this image has 8 colours. That is, the image is composed of (numColoursM2 + 1) colours. If there is a colour table, it comes next, three bytes for each: R, G, and B. There are (numColoursM2 + 1) entries. The colours are sorted by the encoder from most common to least. This allows the decoder to give preference to more common colours when displaying the image, if the number of colours that can be displayed is limited. If there is not a colour table, the image is greyscale, and the proper grey scale (from full white to full black) will be created by the decoder to create the required number of colours. Next, come (numColoursM2 + 1) bytes that are "ranges" - they describe relative frequency of each colour (in colour table order) in the source image. There is an implied, but not written extra value, which would make these all add up to 256. The extra symbol is called "RLE marker" and means "same as last pixel". Then comes the data, arithmetically-coded based on the provided range widths.
+
+The provided encoder/decoder is NOT meant for pseed, but as a reference. It can be used to decompress an image into a 24-bit BMP easily, like so:
+	./aci d < img.aci > img.bmp
+It can be used to compress an image like so:
+	./aci c < img.bmp > img.aci
+The bitmap must be a 24-bits-per-pixel uncompressed bitmap, preferably with a low number of colours. This will produce an ACI image with a colourtable.
+If you wish to produce a greyscale colour-table-less image, instead of "c", pass "c4", "c2", or "c1" parameters, for 4bpp, 2bpp, or 1bpp colour (16, 4, 2 colours). The format is not limited to this, but this tool, for ease, is. All incoming images will be converted to greyscale if not already so.
+
+The decoder in 68k assembly is optimised for speed in the common cases and is pretty fast. It provides the colour table in a callback at the start of the decoding process (even for greyscale images) and always outputs one byte per pixel.
\ No newline at end of file
diff --git a/tools/aci/aci.c b/tools/aci/aci.c
new file mode 100644
index 0000000..0015ddc
--- /dev/null
+++ b/tools/aci/aci.c
@@ -0,0 +1,593 @@
+#include <stdbool.h>
+#include <endian.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdio.h>
+
+#define FLAGS_V1			0x01		//must be set for this v1 format, if clear, format differs
+#define FLAGS_HAS_CLUT		0x02		//if no, assume greyscale of given depth and no actual CLUT
+
+#define LOG(...)		//fprintf(stderr, __VA_ARGS__)
+
+struct BmpHdr {
+	uint8_t magic[2];
+	uint32_t fileSz;
+	uint16_t rfu[2];
+	uint32_t dataOfst;
+} __attribute__((packed));
+
+struct DibHdr {
+	uint32_t hdrSz;
+	int32_t width;
+	int32_t height;
+	uint16_t numColorPlanes;	//must be 1
+	uint16_t bpp;
+	uint32_t compressionType;	//zero for none
+	uint32_t dataSz;			//can be zero
+	uint32_t ppmH;
+	uint32_t ppmV;
+	uint32_t numColorsInPalette;
+	uint32_t numImportantColors;
+} __attribute__((packed));
+
+struct Pixel {
+	uint8_t b, g, r;
+} __attribute__((packed));
+
+struct PixelHist {
+	struct Pixel color;
+	uint32_t counter;
+};
+
+struct PixelRange {
+	struct Pixel color;
+	uint32_t counter;
+	uint16_t start;
+	uint16_t end;
+};
+
+struct BitBuffer {
+	uint8_t bitBuf;
+	uint8_t numBitsHere;
+};
+
+static bool readIn(void *dstP, uint32_t len);
+
+static uint_fast8_t bbRead(struct BitBuffer *bb)	//read a bit
+{
+	uint_fast8_t ret;
+	
+	if (!bb->numBitsHere) {
+		
+		bb->numBitsHere = 8;
+		if (!readIn(&bb->bitBuf, 1)) {
+			
+			//this is ok
+			bb->bitBuf = 0;
+		}
+	}
+	
+	bb->numBitsHere--;
+	ret = bb->bitBuf & 1;
+	bb->bitBuf >>= 1;
+
+	return ret;
+}
+
+static void bbWrite(struct BitBuffer *bb, uint_fast8_t val)
+{
+	bb->bitBuf += val << bb->numBitsHere;
+	if (++bb->numBitsHere == 8) {
+		putchar(bb->bitBuf);
+		bb->bitBuf = 0;
+		bb->numBitsHere = 0;
+	}
+}
+
+static void bbFlush(struct BitBuffer *bb)
+{
+	while (bb->numBitsHere)
+		bbWrite(bb, 0);
+}
+
+static void compressImage(struct Pixel *pixels, uint32_t w, uint32_t h, uint_fast8_t numGreyBits)
+{
+	struct PixelHist *hist = calloc(sizeof(struct PixelHist), w * h);
+	uint32_t numColors = 1, totalPixels = w * h, i, j, k, numTruncated = 0;
+	struct PixelRange *ranges;
+	struct BitBuffer bb = {};
+	uint16_t min, max;
+	
+	//here, 0th color means "same as last" (pseudo-RLE)
+	
+	//collect histogram
+	if (numGreyBits) {	//init histogram to make sure we have order
+		
+		for (i = 1; i <= (1u << numGreyBits); i++)
+			hist[i].color.r = hist[i].color.g = hist[i].color.b = i - 1;
+			
+		numColors = i;
+	}
+	
+	for (i = 0; i < totalPixels; i++) {
+		
+		for (j = 1; j < numColors && memcmp(&pixels[i], &hist[j].color, sizeof(struct Pixel)); j++);
+		if (j == numColors) {		//new color
+			
+			if (numGreyBits) {
+				
+				fprintf(stderr, "did not expect a new color for a grey bitmap: (%u,%u,%u)!\n", pixels[i].r, pixels[i].g, pixels[i].b);
+				abort();
+			}
+			
+			hist[j].color = pixels[i];
+			numColors++;
+		}
+		else if (i && !memcmp(&pixels[i - 1], &pixels[i], sizeof(struct Pixel)))
+			hist[0].counter++;
+		else
+			hist[j].counter++;
+	}
+	
+	LOG("Bitmap is %ux%u and has %u colors\n", w, h, numColors);
+	if (numColors >= 256)
+		exit(-1);
+	
+	if (!numGreyBits) {
+		//sort colors from least used to most for color modes so that the more used colors can get into the palette
+		for (i = 1; i < numColors; i++) {
+			
+			struct PixelHist tmp;
+			
+			for (k = i, j = i + 1; j < numColors; j++) {
+				
+				if (hist[k].counter > hist[j].counter)
+					k = j;
+			}
+			
+			tmp = hist[k];
+			hist[k] = hist[i];
+			hist[i] = tmp;
+		}
+	}
+	
+	//make our range list, make RLE entry be at the end, now [numColors - 1] means "RLE color"
+	//most used color is first, this will allow, on decode, to pick which color(s) to favour...
+	ranges = calloc(sizeof(struct PixelRange), numColors);
+	for (i = 0; i < numColors; i++) {
+		ranges[numColors - i - 1].color = hist[i].color;
+		ranges[numColors - i - 1].counter = hist[i].counter;
+	}
+	free(hist);
+	hist = NULL;
+	
+	//allocate bit ranges
+	k = 0;
+	for (i = 0; i < numColors - 1; i++) {
+		
+		uint32_t len;
+		
+		ranges[i].start = k;
+		len = ranges[i].counter * 256 / totalPixels;
+		if (!len)
+			len++;
+		ranges[i].end = ranges[i].start + len;
+		k += len;
+	}
+	ranges[i].start = k;
+	ranges[i].end = 256;
+	
+	for (i = 0; i < numColors - 1; i++) {
+		
+		LOG("color [%3u] (%3u, %3u, %3u) is used by %4u pixels and gets range %02xh...%02xh\n", i,
+			ranges[i].color.r, ranges[i].color.g, ranges[i].color.b, ranges[i].counter, ranges[i].start, ranges[i].end);
+	}
+	LOG("RLE entry is used by %4u pixels and gets range %02xh...%02xh\n", 
+			ranges[i].counter, ranges[i].start, ranges[i].end);
+	
+	//emit W & H
+	putchar(w >> 8);
+	putchar(w);
+	putchar(h >> 8);
+	putchar(h);
+	
+	//flags/status byte
+	putchar(FLAGS_V1 | (numGreyBits ? 0 : FLAGS_HAS_CLUT));
+	
+	//emit num colors
+	putchar(numColors - 2);	//do not count RLE color, and offset by one to allow for 256 colors
+	
+	if (!numGreyBits) {
+		//emit clut
+		for (i = 0; i < numColors - 1; i++) {
+			
+			putchar(ranges[i].color.r);
+			putchar(ranges[i].color.g);
+			putchar(ranges[i].color.b);
+		}
+	}
+	
+	//emit "start" of each value (except first for which we know it)
+	for (i = 1; i < numColors; i++)
+		putchar(ranges[i].start);
+	
+	//emit pixels
+	min = 0;
+	max = 0xffff;
+	k = numColors - 1;	//previndex, this is guaranteed to not match 0th pixel
+	for (i = 0; i < totalPixels; i++) {
+		
+		uint32_t width = (uint32_t)max - min + 1;
+		
+		//find the index
+		for (j = 0; j < numColors - 1 && memcmp(&pixels[i], &ranges[j].color, sizeof(struct Pixel)); j++);
+		
+		//see if it matches prev and if so, apply that special marker
+		if (j == k)
+			j = numColors - 1;
+		else
+			k = j;
+		
+		LOG("[%4u/%4u] idx %2u applying range %02xh...%02xh to %08xh...%08xh", i, totalPixels, j, 
+			ranges[j].start, ranges[j].end, (unsigned)(uint32_t)min, (unsigned)(uint32_t)max);
+		
+		//calc new range
+		max = min + width * ranges[j].end / 256 - 1;
+		min = min + width * ranges[j].start / 256;
+		
+		LOG(" produces a range of %08xh...%08xh\n", (unsigned)(uint32_t)min, (unsigned)(uint32_t)max);
+		
+		while ((min >> 15) == (max >> 15)) {
+			
+			uint_fast8_t bit = min >> 15;
+			
+			bbWrite(&bb, bit);
+			LOG(" emitting %u\n", bit);
+			bit = 1 - bit;
+			while (numTruncated) {
+				bbWrite(&bb, bit);
+				LOG(" emitting %u (from truncation)\n", bit);
+				numTruncated--;
+			}
+			
+			
+			min = min * 2;
+			max = max * 2 + 1;
+		}
+		
+		while ((min >> 14) == 1 && (max >> 14) == 2) {
+			
+			LOG(" truncating\n");
+			numTruncated++;
+			min = (min << 1) ^ 0x8000;
+			max = (max << 1) ^ 0x8001;
+		}
+	}
+	
+	//the end
+	bbWrite(&bb, 1);
+	LOG(" emitting %u\n", 1);
+	
+	//emit all the remaining bits we need to encode the range
+	bbFlush(&bb);
+	
+	free(ranges);
+}
+
+static bool readIn(void *dstP, uint32_t len)
+{
+	uint8_t *dst = dstP;
+	int c;
+	
+	while (len--) {
+		if ((c = getchar()) == EOF)
+			return false;
+		
+		if (dst)
+			*dst++ = c;
+	}
+	
+	return true;
+}
+
+static void decompressImage(uint_fast16_t w, uint_fast16_t h, uint_fast16_t rowExtraBytes, const struct PixelRange *ranges, uint_fast16_t numColors)
+{
+	uint32_t i, r, c;
+	uint16_t min = 0, max = 0xffff, val = 0;
+	uint_fast16_t prevIdx = numColors - 1;
+	struct BitBuffer bb = {};
+	
+	//init state
+	for (i = 0; i < sizeof(val) * 8; i++)
+		val = val * 2 + bbRead(&bb);
+	
+	for (r = 0; r < h; r++) {
+		
+		for (c = 0; c < w; c++) {
+			
+			uint32_t width = (uint32_t)max - min + 1;
+			uint32_t above = val - min;
+			uint32_t now = ((above + 1) * 256 - 1) / width;
+			uint_fast8_t idxNow;
+			
+			//find matching symbol for "now". binary search
+			uint_fast16_t end = numColors, start = 0, center;
+			
+			LOG(">> val 0x%08xh, above 0x%08xh, looking for %08xh\n", val, above, now);
+			
+			while (end > start) {
+				
+				center = (end + start) / 2;
+				
+				if (ranges[center].end <= now)
+					start = center;
+				else if (ranges[center].start > now)
+					end = center;
+				else
+					break;
+			}
+			
+			idxNow = (center == numColors - 1) ? prevIdx : center;
+			prevIdx = idxNow;
+			
+			//emit the pixel
+			putchar(ranges[idxNow].color.b);
+			putchar(ranges[idxNow].color.g);
+			putchar(ranges[idxNow].color.b);
+			
+			//adjust state
+			LOG("[%4u/%4u] idx %2u applying range %02xh...%02xh to %08xh...%08xh", (unsigned)(r * w + c), (unsigned)(w * h), center, 
+				ranges[center].start, ranges[center].end, (unsigned)(uint32_t)min, (unsigned)(uint32_t)max);
+			
+			//calc new range
+			max = min + width * ranges[center].end / 256 - 1;
+			min = min + width * ranges[center].start / 256;
+			
+			LOG(" produces a range of %08xh...%08xh\n", (unsigned)(uint32_t)min, (unsigned)(uint32_t)max);
+			
+			while ((min >> 15) == (max >> 15)) {
+				
+				min = min * 2;
+				max = max * 2 + 1;
+				
+				val = val * 2 + bbRead(&bb);
+				LOG(" reading %u -> %08xh\n", val & 1, (unsigned)val);
+				LOG("  %08xh...%08xh\n", (unsigned)(uint32_t)min, (unsigned)(uint32_t)max);
+			}
+			
+			while ((min >> 14) == 1 && (max >> 14) == 2) {
+				
+				min = (min << 1) ^ 0x8000;
+				max = (max << 1) ^ 0x8001;
+				
+				val = (val & 0x8000) + (val & 0x3fff) * 2 + bbRead(&bb);
+				LOG(" truncate-reading %u-> %08xh\n", val & 1, (unsigned)val);
+				LOG("  %08xh...%08xh\n", (unsigned)(uint32_t)min, (unsigned)(uint32_t)max);
+			}
+
+			if (min > max) {
+				
+				fprintf(stderr, "range crossed\n");
+				abort();
+			}
+			if (val < min || val > max) {
+				
+				fprintf(stderr, "val OOB: %08xh\n", val);
+				abort();
+			}
+		}
+		for (c = 0; c < rowExtraBytes; c++)
+			putchar(0);
+	}
+}
+
+static void usage(const char *self)
+{
+	fprintf(stderr, 
+		"USAGE:\n"
+		"\tcompress: %s c[n] < in.bmp > out.bin\n"
+		"\t\tBitmap must be a 24 bits per pixel uncompressed bitmap under 65535 x 65535.\n"
+		"\t\tn, if present, must be 4, 2, or 1 to signify bits of grey to encode\n"
+		"\tdecompress: %s d < in.bin > out.bmp\n",
+		self, self);
+	
+	exit(-1);
+}
+
+int main(int argc, char **argv)
+{
+	uint32_t i, r, c, rowBytes, rowExtraBytes;
+	struct BmpHdr hdrBmp = {};
+	struct DibHdr hdrDib = {};
+		
+	if (argc != 2 || (argv[1][0] != 'c' && argv[1][0] != 'd'))
+		usage(argv[0]);
+	
+	if (argv[1][0] == 'c') {	//compress
+		
+		uint_fast8_t numGreyBits = 0;
+		
+		switch (argv[1][1]) {
+			case 0:
+				break;
+			
+			case '1':
+			case '2':
+			case '4':
+				numGreyBits = argv[1][1] - '0';
+				if (!(argv[1][2]))
+					break;
+				//fallthrough
+			
+			default:
+				usage(argv[0]);
+				break;
+		}
+		
+		bool rightSideUp = false;
+		struct Pixel *pixels;
+		int32_t w, h;
+	
+		if (!readIn(&hdrBmp, sizeof(hdrBmp)) ||
+				!readIn(&hdrDib, sizeof(hdrDib)) ||
+				hdrBmp.magic[0] != 'B' ||
+				hdrBmp.magic[1] != 'M' ||
+				le32toh(hdrBmp.dataOfst) < sizeof(struct BmpHdr) + sizeof(struct DibHdr) ||
+				le32toh(hdrDib.hdrSz) < sizeof(struct DibHdr) ||
+				le16toh(hdrDib.numColorPlanes) != 1 ||
+				le16toh(hdrDib.bpp) != 24 ||
+				le32toh(hdrDib.compressionType) ||
+				!(w = le32toh(hdrDib.width)) ||
+				!(h = le32toh(hdrDib.height)) ||
+				abs(w) >> 16 ||
+				abs(h) >> 16 || 
+				!readIn(NULL, le32toh(hdrBmp.dataOfst) - sizeof(struct BmpHdr) - sizeof(struct DibHdr)))
+			usage(argv[0]);
+	
+		if (h < 0) {
+			h = -h;
+			rightSideUp = true;
+		}
+	
+		rowBytes = w * 3 + 3 / 4 * 4;
+		rowExtraBytes = rowBytes - w * 3;
+		
+		pixels = malloc(sizeof(struct Pixel) * w * h);
+		for (r = 0; r < (uint32_t)h; r++) {
+			
+			for (c = 0; c < (uint32_t)w; c++) {
+				
+				struct Pixel *dstPixel = &pixels[c + w * (rightSideUp ? r : h - r - 1)];
+				
+				if (!readIn(dstPixel, sizeof(struct Pixel))) {		//we always encode right side up
+					
+					fprintf(stderr, "cannot read pixel data for row %u col %u\n", r, c);
+					return -1;
+				}
+				
+				if (numGreyBits) {
+					
+					static const uint32_t divBy[] = {[1] = 0xff0000, [2] = 0x550000, [4] = 0x110000};
+					uint32_t r = dstPixel->r;
+					uint32_t g = dstPixel->g;
+					uint32_t b = dstPixel->b;
+					uint32_t greyLevel;
+					
+					r *= 19595;
+					g *= 38470;
+					b *= 7471;
+					
+					greyLevel = r + g + b; //0..FF0000
+					
+					greyLevel = (greyLevel + divBy[numGreyBits] / 2) / divBy[numGreyBits];		//this is black-to-white, we need to reverse it
+					greyLevel = (1 << numGreyBits) - 1 - greyLevel;
+					
+					dstPixel->r = greyLevel;
+					dstPixel->g = greyLevel;
+					dstPixel->b = greyLevel;
+				}
+			}
+			if (!readIn(NULL, rowExtraBytes)) {
+				
+				fprintf(stderr, "cannot read dummy data for row  %u\n", r);
+				return -1;
+			}
+		}
+		
+		compressImage(pixels, w, h, numGreyBits);
+		
+		free(pixels);
+	}
+	else if (argv[1][1])
+		usage(argv[0]);
+	else {	//decompress
+		
+		struct PixelRange *ranges;
+		uint16_t w, h, numColors;
+		uint8_t numcolorsM2, flags;
+		
+		//the basics
+		if (!readIn(&w, sizeof(w)) || !readIn(&h, sizeof(h)) || !readIn(&flags, sizeof(flags)) || !readIn(&numcolorsM2, sizeof(numcolorsM2)))
+			usage(argv[1]);
+		w = be16toh(w);
+		h = be16toh(h);
+		numColors = (uint16_t)numcolorsM2 + 2;
+		if (!(flags & FLAGS_V1)) {
+			fprintf(stderr, "unknown version\n");
+			exit(-2);
+		}
+		
+		ranges = calloc(sizeof(struct PixelRange), numColors);
+		
+		//read & decode the clut, if it exists (last entry is the RLE entry and has no color)
+		if (flags & FLAGS_HAS_CLUT) {
+			for (i = 0; i < (uint16_t)(numColors - 1); i++) {
+				
+				if (!readIn(&ranges[i].color.r, 1) || !readIn(&ranges[i].color.g, 1) || !readIn(&ranges[i].color.b, 1))
+					usage(argv[1]);
+			}
+		}
+		else {
+			
+			//create a white-to-black clut
+			for (i = 0; i < (uint16_t)(numColors - 1); i++) {
+				
+				ranges[i].color.r = ranges[i].color.g = ranges[i].color.b = 255 - (255 * i + (numColors - 2) / 2) / (numColors - 2);
+			}
+		}
+		
+		//read and calculate the ranges
+		for (i = 1; i < numColors; i++) {
+			
+			uint8_t tmp;
+			
+			if (!readIn(&tmp, 1))
+				usage(argv[1]);
+			ranges[i].start = tmp;
+			ranges[i - 1].end = ranges[i].start;
+		}
+		ranges[numColors - 1].end = 256;
+		
+		for (i = 0; i < (uint16_t)(numColors - 1); i++) {
+			
+			LOG("color (%3u, %3u, %3u) gets range %02xh...%02xh\n", 
+				ranges[i].color.r, ranges[i].color.g, ranges[i].color.b, ranges[i].start, ranges[i].end);
+		}
+		LOG("RLE entry gets range %02xh...%02xh\n", ranges[i].start, ranges[i].end);
+		
+		//emit bitmap and DIB headers
+		rowBytes = w * 3 + 3 / 4 * 4;
+		rowExtraBytes = rowBytes - w * 3;
+		
+		hdrBmp.magic[0] = 'B';
+		hdrBmp.magic[1] = 'M';
+		hdrBmp.fileSz = htole32(sizeof(struct BmpHdr) + sizeof(struct DibHdr) + rowBytes * h);
+		hdrBmp.dataOfst = htole32(sizeof(struct BmpHdr) + sizeof(struct DibHdr));
+		if (fwrite(&hdrBmp, 1, sizeof(struct BmpHdr), stdout) != sizeof(struct BmpHdr))
+			abort();
+		
+		hdrDib.hdrSz = htole32(sizeof(struct DibHdr));
+		hdrDib.width = htole32(w);
+		hdrDib.height = htole32(-h);
+		hdrDib.numColorPlanes = htole16(1);
+		hdrDib.bpp = htole16(24);
+		hdrDib.compressionType = htole32(0);
+		hdrDib.dataSz = htole32(rowBytes * h);
+		hdrDib.ppmH = htole32(2834);
+		hdrDib.ppmV = htole32(2834);
+		hdrDib.numColorsInPalette = htole32(0);
+		hdrDib.numImportantColors = htole32(0);
+		if (fwrite(&hdrDib, 1, sizeof(struct DibHdr), stdout) != sizeof(struct DibHdr))
+			abort();
+		
+		decompressImage(w, h, rowExtraBytes, ranges, numColors);
+		
+		free(ranges);
+	}
+	
+	
+	return 0;
+}
+
+
