commit 754402450476f9c43561206fc228efa48c51a829
Author: Dmitry Grinberg <dmitrygr@gmail.com>
Date:   Wed Dec 28 01:55:07 2022 -0600

    add some black magic for OS1/2

diff --git a/Src/PkmnMain.c b/Src/PkmnMain.c
index 259dec4..666b01b 100644
--- a/Src/PkmnMain.c
+++ b/Src/PkmnMain.c
@@ -3,7 +3,10 @@
 #include "Palmkedex.h"
 #include "Rsc/Palmkedex_Rsc.h"
 #include "Src/imgDraw.h"
+#include "osExtra.h"
 
+#define POKE_IMAGE_AT_X		1
+#define POKE_IMAGE_AT_Y		16
 
 void DrawPkmnPlaceholder()
 {
@@ -14,7 +17,7 @@ void DrawPkmnPlaceholder()
 	bitmapP = (BitmapPtr)MemHandleLock(h);
 	ErrFatalDisplayIf(!bitmapP, "Failed to lock placeholder bmp");
 
-	WinDrawBitmap(bitmapP, 1, 16);
+	WinDrawBitmap(bitmapP, POKE_IMAGE_AT_X, POKE_IMAGE_AT_Y);
 	MemPtrUnlock(bitmapP);
 	DmReleaseResource(h);
 }
@@ -29,7 +32,7 @@ void DrawPkmnSprite(UInt16 selectedPkmnId)
 	BitmapType *bmpP;
 	WinHandle win;
 	Err error;
-	struct DrawState *ds;
+	struct DrawState *ds = NULL;
 
 	// Check if the PNG for the current pkmn
 	// is already decoded in memory
@@ -37,29 +40,24 @@ void DrawPkmnSprite(UInt16 selectedPkmnId)
 	if (error == errNone)
 	{
 		// If it is, draw it and return
-		imgDrawRedraw(ds, 1, 16);
+		imgDrawRedraw(ds, POKE_IMAGE_AT_X, POKE_IMAGE_AT_Y);
 		return;
 	}
 
 	// Check if there is any PNG for current pkmn
 	dbRef = DmOpenDatabaseByTypeCreator('pSPR', 'PKSP', dmModeReadOnly);
-	imgMemHandle = DmGet1Resource('pSPT', selectedPkmnId);
-	if (!imgMemHandle)
-	{
-		// If there isnt, draw the placeholder and return
-		DrawPkmnPlaceholder();
-		if (dbRef)
-		{
-			DmCloseDatabase(dbRef);
+	if (dbRef) {
+		
+		imgMemHandle = DmGet1Resource('pSPT', selectedPkmnId);
+		if (!imgMemHandle)
+			DrawPkmnPlaceholder();
+		else {
+			
+			if (imgDecode(&ds, MemHandleLock(imgMemHandle), MemHandleSize(imgMemHandle), 64, 64, 0))
+				imgDrawRedraw(ds, POKE_IMAGE_AT_X, POKE_IMAGE_AT_Y);
+			MemHandleUnlock(imgMemHandle);
+			DmReleaseResource(imgMemHandle);
 		}
-		return;
-	}
-	
-	imgDrawAt(&ds, MemHandleLock(imgMemHandle), MemHandleSize(imgMemHandle), 1, 16, 64, 64); 
-	MemHandleUnlock(imgMemHandle);
-	DmReleaseResource(imgMemHandle);
-	if (dbRef)
-	{
 		DmCloseDatabase(dbRef);
 	}
 	// And store its pointer to quickly redraw it
@@ -259,6 +257,133 @@ static Boolean PkmnMainFormDoCommand(UInt16 command)
 	return handled;
 }
 
+struct m68kLCDC {	//@0xfffffa00
+	volatile UInt32 LSSA;
+	UInt8 rfu0[1];
+	volatile UInt8 LVPW;
+	UInt8 rfu1[2];
+	volatile UInt16 LXMAX;
+	volatile UInt16 LYMAX;
+	UInt8 rfu2[12];
+	volatile UInt16 LCXP;
+	volatile UInt16 LCYP;
+	volatile UInt16 LCWCH;
+	UInt8 rfu3[1];
+	volatile UInt8 LBLKC;
+	volatile UInt8 LPICF;
+	volatile UInt8 LPOLCF;
+	UInt8 rfu4[1];
+	volatile UInt8 LACDRC;
+	UInt8 rfu5[1];
+	volatile UInt8 LPXCD;
+	UInt8 rfu6[1];
+	volatile UInt8 LCKCON;
+	UInt8 rfu7[1];
+	volatile UInt8 LLBAR;
+	UInt8 rfu8[1];
+	volatile UInt8 LOTCR;
+	UInt8 rfu9[1];
+	volatile UInt8 LPOSR;
+	UInt8 rfuA[3];
+	volatile UInt8 LFRCM;
+	volatile UInt16 LGPMR;
+};
+
+static const RectangleType imageRect = {.topLeft = {.x = 1, .y = 16}, .extent = {.x = 64, .y = 64, }};
+/*
+	There is black magic in play here, tread with caution...
+*/
+static void drawMagicandTrackPenRelease(Int16 x, Int16 y)
+{
+	struct m68kLCDC *LCDC = (struct m68kLCDC*)0xfffffa00;
+	UInt8 prevVPW, prevLBAR, prevLPICF;
+	UInt8 *restrict newSSA = NULL;
+	Boolean down, success = false;
+	SharedVariables *sharedVars;
+	UInt32 prevSSA, romVersion;
+	MemHandle imgMemHandle;
+	DmOpenRef dbRef;
+	UInt16 i, r, c;
+	
+	//this hackery is only for OS 1 & 2, which lack greyscale mode!
+	if (errNone == FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion) && romVersion >= sysMakeROMVersion(3,0,0,sysROMStageDevelopment,0))
+		return;
+	
+	if (errNone != FtrGet(appFileCreator, ftrShrdVarsNum, (UInt32*)&sharedVars))
+		return;
+	
+	dbRef = DmOpenDatabaseByTypeCreator('pSPR', 'PKSP', dmModeReadOnly);
+	if (dbRef) {
+		
+		imgMemHandle = DmGet1Resource('pSPT', sharedVars->selectedPkmnId);
+		if (imgMemHandle) {
+			
+			MemHandle mh = DmNewHandle((DmOpenRef)(SysCurAppInfoPV20()->dmAccessP), 160u * 160u * 2u / 8u);
+			if (mh)
+				newSSA = MemHandleLock(mh);
+			if (newSSA) {
+			
+				struct DrawState *ds = NULL;
+			
+				MemSemaphoreReserve(true);
+				if (imgDecode(&ds, MemHandleLock(imgMemHandle), MemHandleSize(imgMemHandle), 64, 64, 2)) {
+					
+					static const UInt16 expandTab[] = {0x0000, 0x0005, 0x000a, 0x000f, 0x0050, 0x0055, 0x005a, 0x005f, 0x00a0, 0x00a5, 0x00aa, 0x00af, 0x00f0, 0x00f5, 0x00fa, 0x00ff, 0x0500, 0x0505, 0x050a, 0x050f, 0x0550, 0x0555, 0x055a, 0x055f, 0x05a0, 0x05a5, 0x05aa, 0x05af, 0x05f0, 0x05f5, 0x05fa, 0x05ff, 0x0a00, 0x0a05, 0x0a0a, 0x0a0f, 0x0a50, 0x0a55, 0x0a5a, 0x0a5f, 0x0aa0, 0x0aa5, 0x0aaa, 0x0aaf, 0x0af0, 0x0af5, 0x0afa, 0x0aff, 0x0f00, 0x0f05, 0x0f0a, 0x0f0f, 0x0f50, 0x0f55, 0x0f5a, 0x0f5f, 0x0fa0, 0x0fa5, 0x0faa, 0x0faf, 0x0ff0, 0x0ff5, 0x0ffa, 0x0fff, 0x5000, 0x5005, 0x500a, 0x500f, 0x5050, 0x5055, 0x505a, 0x505f, 0x50a0, 0x50a5, 0x50aa, 0x50af, 0x50f0, 0x50f5, 0x50fa, 0x50ff, 0x5500, 0x5505, 0x550a, 0x550f, 0x5550, 0x5555, 0x555a, 0x555f, 0x55a0, 0x55a5, 0x55aa, 0x55af, 0x55f0, 0x55f5, 0x55fa, 0x55ff, 0x5a00, 0x5a05, 0x5a0a, 0x5a0f, 0x5a50, 0x5a55, 0x5a5a, 0x5a5f, 0x5aa0, 0x5aa5, 0x5aaa, 0x5aaf, 0x5af0, 0x5af5, 0x5afa, 0x5aff, 0x5f00, 0x5f05, 0x5f0a, 0x5f0f, 0x5f50, 0x5f55, 0x5f5a, 0x5f5f, 0x5fa0, 0x5fa5, 0x5faa, 0x5faf, 0x5ff0, 0x5ff5, 0x5ffa, 0x5fff, 0xa000, 0xa005, 0xa00a, 0xa00f, 0xa050, 0xa055, 0xa05a, 0xa05f, 0xa0a0, 0xa0a5, 0xa0aa, 0xa0af, 0xa0f0, 0xa0f5, 0xa0fa, 0xa0ff, 0xa500, 0xa505, 0xa50a, 0xa50f, 0xa550, 0xa555, 0xa55a, 0xa55f, 0xa5a0, 0xa5a5, 0xa5aa, 0xa5af, 0xa5f0, 0xa5f5, 0xa5fa, 0xa5ff, 0xaa00, 0xaa05, 0xaa0a, 0xaa0f, 0xaa50, 0xaa55, 0xaa5a, 0xaa5f, 0xaaa0, 0xaaa5, 0xaaaa, 0xaaaf, 0xaaf0, 0xaaf5, 0xaafa, 0xaaff, 0xaf00, 0xaf05, 0xaf0a, 0xaf0f, 0xaf50, 0xaf55, 0xaf5a, 0xaf5f, 0xafa0, 0xafa5, 0xafaa, 0xafaf, 0xaff0, 0xaff5, 0xaffa, 0xafff, 0xf000, 0xf005, 0xf00a, 0xf00f, 0xf050, 0xf055, 0xf05a, 0xf05f, 0xf0a0, 0xf0a5, 0xf0aa, 0xf0af, 0xf0f0, 0xf0f5, 0xf0fa, 0xf0ff, 0xf500, 0xf505, 0xf50a, 0xf50f, 0xf550, 0xf555, 0xf55a, 0xf55f, 0xf5a0, 0xf5a5, 0xf5aa, 0xf5af, 0xf5f0, 0xf5f5, 0xf5fa, 0xf5ff, 0xfa00, 0xfa05, 0xfa0a, 0xfa0f, 0xfa50, 0xfa55, 0xfa5a, 0xfa5f, 0xfaa0, 0xfaa5, 0xfaaa, 0xfaaf, 0xfaf0, 0xfaf5, 0xfafa, 0xfaff, 0xff00, 0xff05, 0xff0a, 0xff0f, 0xff50, 0xff55, 0xff5a, 0xff5f, 0xffa0, 0xffa5, 0xffaa, 0xffaf, 0xfff0, 0xfff5, 0xfffa, 0xffff, };
+					const volatile UInt8 *src = imgGetBits(ds);
+					UInt16 *dst = (UInt16*)newSSA;
+					
+					MemSet(newSSA, 160u * 160u * 2u / 8u, 0);
+					
+					dst += 160 * 16 * 2 / 16;
+					for (r = 0; r < 128; r++) {
+						
+						dst += 2;
+						for (c = 0; c < 128 / 8; c++) {
+							
+							*dst++ = expandTab[src[c]];
+						}
+						dst += 2;
+						if (r & 1)
+							src += 64 * 2 / 8;
+					}
+					
+					prevSSA = LCDC->LSSA;
+					LCDC->LSSA = (UInt32)newSSA;
+					prevVPW = LCDC->LVPW;
+					prevLBAR = LCDC->LLBAR;
+					LCDC->LLBAR = 20;
+					LCDC->LVPW = 20;
+					prevLPICF = LCDC->LPICF;
+					LCDC->LPICF |= 1;
+					
+					success = true;
+					imgDrawStateFree(ds);
+				}
+				MemSemaphoreRelease(true);
+				MemHandleUnlock(imgMemHandle);
+				DmReleaseResource(imgMemHandle);
+			}
+		}
+		DmCloseDatabase(dbRef);
+	}
+	
+	if (success) {
+		
+		do {
+			EvtGetPen(&x, &y, &down);
+		} while (down);
+		LCDC->LPICF = prevLPICF;
+		LCDC->LLBAR = prevLBAR;
+		LCDC->LVPW = prevVPW;
+		LCDC->LSSA = prevSSA;
+		
+		FrmDrawForm(FrmGetActiveForm());
+		DrawPkmnSprite(sharedVars->selectedPkmnId);
+	}
+	if (newSSA)
+		MemPtrFree(newSSA);
+}
+
 /*
  * FUNCTION: PkmnMainFormHandleEvent
  *
@@ -284,6 +409,13 @@ Boolean PkmnMainFormHandleEvent(EventType *eventP)
 
 	switch (eventP->eType)
 	{
+	case penDownEvent:
+		if (RctPtInRectangle(eventP->screenX, eventP->screenY, &imageRect)) {
+			drawMagicandTrackPenRelease(eventP->screenX, eventP->screenY);
+			return true;
+		}
+		break;
+	
 	case ctlSelectEvent:
 		return PkmnMainFormDoCommand(eventP->data.menu.itemID);
 
diff --git a/Src/imgDraw.c b/Src/imgDraw.c
index 8fcd11e..d3ceaaf 100644
--- a/Src/imgDraw.c
+++ b/Src/imgDraw.c
@@ -5,8 +5,8 @@
 #include <SonyCLIE.h>
 #include "imgDrawInt.h"
 #include "imgDraw.h"
+#include "osExtra.h"
 
-SysAppInfoPtr SysCurAppInfoPV20(void)	SYS_TRAP(sysTrapSysCurAppInfoPV20);	//not declared anywhere
 
 
 #define PNG_HI_RES_SUPPORTED				1		//sonyHR only supports double
@@ -88,6 +88,10 @@ static unsigned char imgDrawHdrCbk(struct DrawState *ds, uint32_t w, uint32_t h,
 		
 		colorSupport = false;
 	}
+	
+	//honour requested depth
+	if (ds->depth)
+		curDepth = ds->depth;
 
 	//check for nonzero exact integer or 1/2 multiple of size, same for W & H
 	if (!w || !h || w * 2 % ds->expectedW || h * 2 % ds->expectedW || w * 2 / ds->expectedW != h * 2 / ds->expectedW)
@@ -314,7 +318,7 @@ static int imgDecodeCall(struct DrawState *ds, const void *data, uint32_t dataSz
 	return ret;
 }
 
-bool imgDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_t x, int16_t y, uint32_t expectedW, uint32_t expectedH)
+bool imgDecode(struct DrawState **dsP, const void *data, uint32_t dataSz, uint32_t expectedW, uint32_t expectedH, uint8_t decodeAtThisDepth /* 0 for whatever screen is */)
 {
 	uint8_t densitySupportFlags = 0;
 	struct DrawState *ds;
@@ -334,6 +338,7 @@ bool imgDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_
 	ds->expectedW = expectedW;
 	ds->expectedH = expectedH;
 	ds->densitySupportFlags = densitySupportFlags;
+	ds->depth = decodeAtThisDepth;
 
 	ret = imgDecodeCall(ds, data, dataSz);
 	if (ret < 0) {
@@ -341,10 +346,12 @@ bool imgDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_
 		imgDrawStateFree(ds);
 		return false;
 	}
-		
-	imgDrawRedraw(ds, x, y);
 	
 	*dsP = ds;
 	return true;
 }
 
+const void* imgGetBits(struct DrawState *ds)
+{
+	return ds->bits;
+}
diff --git a/Src/imgDraw.h b/Src/imgDraw.h
index bcf4f52..376a178 100644
--- a/Src/imgDraw.h
+++ b/Src/imgDraw.h
@@ -8,7 +8,7 @@ struct BitmapType;
 struct DrawState;
 
 //decodes and stores state in "dsP"
-bool imgDrawAt(struct DrawState **dsP, const void *data, uint32_t dataSz, int16_t x, int16_t y, uint32_t expectedW, uint32_t expectedH); 
+bool imgDecode(struct DrawState **dsP, const void *data, uint32_t dataSz, uint32_t expectedW, uint32_t expectedH, uint8_t decodeAtThisDepth /* 0 for whatever screen is */); 
 
 //delete am already-decoded state
 void imgDrawStateFree(struct DrawState *ds);
@@ -16,6 +16,7 @@ void imgDrawStateFree(struct DrawState *ds);
 //redraw an already-decoded state
 void imgDrawRedraw(struct DrawState *ds, int16_t x, int16_t y);
 
-
+//do not use this unless you really need it
+const void* imgGetBits(struct DrawState *ds);
 
 #endif
diff --git a/Src/osExtra.h b/Src/osExtra.h
new file mode 100644
index 0000000..3ec1fa5
--- /dev/null
+++ b/Src/osExtra.h
@@ -0,0 +1,14 @@
+#ifndef _OS_EXTRA_H_
+#define _OS_EXTRA_H_
+
+//not defineed but should be
+
+#include <PalmOS.h>
+
+
+SysAppInfoPtr SysCurAppInfoPV20(void)	SYS_TRAP(sysTrapSysCurAppInfoPV20);	//not declared anywhere
+
+
+
+
+#endif
